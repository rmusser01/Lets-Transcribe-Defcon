{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 21.240000000000002,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Hi, so thanks everybody for coming. This talk is called Morph Your Malware. My name is Sebastian."
    },
    {
      "Time_Start": 21.240000000000002,
      "Time_End": 26.48,
      "Text": " I'm working as a red team operator at a company called Code White. We're basically doing all"
    },
    {
      "Time_Start": 26.48,
      "Time_End": 31.880000000000003,
      "Text": " sorts of red teaming, purple teaming, also regular pen tests, but we're specialized on"
    },
    {
      "Time_Start": 31.880000000000003,
      "Time_End": 37.32,
      "Text": " red and purple teaming. My main part in the team is the creation of offensive tools and"
    },
    {
      "Time_Start": 37.32,
      "Time_End": 42.96,
      "Text": " probably most importantly the creation of a custom C2 which we're using in our assessments."
    },
    {
      "Time_Start": 42.96,
      "Time_End": 51.120000000000005,
      "Text": " And this talk is about the execution and the hiding of malware in the context of another"
    },
    {
      "Time_Start": 51.120000000000005,
      "Time_End": 57.080000000000005,
      "Text": " process. We will be taking a look at techniques which are typically used by adversaries to avoid"
    },
    {
      "Time_Start": 57.080000000000005,
      "Time_End": 63.00000000000001,
      "Text": " detection either by security products or by analysts which are manually taking a look at"
    },
    {
      "Time_Start": 63.00000000000001,
      "Time_End": 69.88000000000001,
      "Text": " processes which might be infected. And we will be trying to fingerprint infected processes simply"
    },
    {
      "Time_Start": 69.88000000000001,
      "Time_End": 77.60000000000001,
      "Text": " by looking at the memory, the states of certain threats, and by taking a look at the call stack"
    },
    {
      "Time_Start": 77.60000000000001,
      "Time_End": 84.48,
      "Text": " of certain threats. I then show you, or I will try to give you an idea of how to avoid being"
    },
    {
      "Time_Start": 84.48,
      "Time_End": 91.16000000000001,
      "Text": " fingerprinted by blending in with false positives or by using a bit more advanced techniques."
    },
    {
      "Time_Start": 91.16000000000001,
      "Time_End": 101.12,
      "Text": " So two slides of general talk. Why does it actually matter? For us red teams protecting"
    },
    {
      "Time_Start": 101.12,
      "Time_End": 105.68,
      "Text": " and hiding our tools definitely has priority for two reasons. The first reason is that we"
    },
    {
      "Time_Start": 105.68,
      "Time_End": 110.4,
      "Text": " obviously do not want to get caught. If we get caught then the operation is pretty much ruined."
    },
    {
      "Time_Start": 110.4,
      "Time_End": 115.4,
      "Text": " We didn't fulfill the goal. The second reason is that custom tooling is quite complex and also"
    },
    {
      "Time_Start": 115.4,
      "Time_End": 120.44000000000001,
      "Text": " precious. Those of you who are developing their own C2 know that it's a quite painful task and"
    },
    {
      "Time_Start": 120.44000000000001,
      "Time_End": 126.76,
      "Text": " it might take ages to achieve it. Dropping tools on disk is obviously considered an obstacle fail."
    },
    {
      "Time_Start": 126.76,
      "Time_End": 133.60000000000002,
      "Text": " Operators tend to forget their tools on disk which is a big problem because security solutions are"
    },
    {
      "Time_Start": 133.6,
      "Time_End": 139.4,
      "Text": " really good at analyzing stuff that you ever put on disk. But even more important, for real"
    },
    {
      "Time_Start": 139.4,
      "Time_End": 146.28,
      "Text": " operators forget what they stored on disk at some point. The thing with the memory malware is that"
    },
    {
      "Time_Start": 146.28,
      "Time_End": 150.72,
      "Text": " it needs a host process otherwise it wouldn't work. You cannot simply choose any process that"
    },
    {
      "Time_Start": 150.72,
      "Time_End": 156.79999999999998,
      "Text": " you like. Notepad.exe for example, that doesn't make any sense. Why? Because usually the process"
    },
    {
      "Time_Start": 156.88000000000002,
      "Time_End": 164.48000000000002,
      "Text": " you're injecting your tool into, the behavior of this process should be as similar as possible"
    },
    {
      "Time_Start": 164.48000000000002,
      "Time_End": 168.48000000000002,
      "Text": " compared to the tool that you're injecting. For example, it doesn't make any sense to inject"
    },
    {
      "Time_Start": 168.48000000000002,
      "Time_End": 171.92000000000002,
      "Text": " Cobalt Slug Beacon into Notepad. Why? Because Notepad usually doesn't have any internet"
    },
    {
      "Time_Start": 171.92000000000002,
      "Time_End": 179.32000000000002,
      "Text": " connections, right? So you will have to carefully choose the host process based on does it make any"
    },
    {
      "Time_Start": 179.32000000000002,
      "Time_End": 184.16000000000003,
      "Text": " internet or internet connections, is it making use of DPAPI or is it even probably known to"
    },
    {
      "Time_Start": 184.16,
      "Time_End": 188.84,
      "Text": " legitimately access others. I personally like to target browsers because they're doing pretty"
    },
    {
      "Time_Start": 188.84,
      "Time_End": 193.68,
      "Text": " much all of this. So and the thing with process injection is that it's nowadays quite heavily"
    },
    {
      "Time_Start": 193.68,
      "Time_End": 199.16,
      "Text": " monitored and this is what this talk is going to be about. So how does it work? Basically it works"
    },
    {
      "Time_Start": 199.16,
      "Time_End": 203.51999999999998,
      "Text": " in three steps. The first step being that you kind of need to open a handle on the process that"
    },
    {
      "Time_Start": 203.51999999999998,
      "Time_End": 208.07999999999998,
      "Text": " you're trying to inject into. A handle basically allows you to perform certain operations on the"
    },
    {
      "Time_Start": 208.07999999999998,
      "Time_End": 213.4,
      "Text": " process that you're trying to fiddle with. The second step is then to kind of somehow inject"
    },
    {
      "Time_Start": 213.4,
      "Time_End": 217.84,
      "Text": " the payload that you're trying to execute. So you need to write code into the context of another"
    },
    {
      "Time_Start": 217.84,
      "Time_End": 222.48000000000002,
      "Text": " process. And the last step is that you somehow need to make the process into which you're injecting"
    },
    {
      "Time_Start": 222.48000000000002,
      "Time_End": 231.04000000000002,
      "Text": " to actually execute the payload. So once again, first step handle creation. The most obvious way"
    },
    {
      "Time_Start": 231.04000000000002,
      "Time_End": 235.64000000000001,
      "Text": " to do this is to simply make use of an API call called open process. You specify a PID, you"
    },
    {
      "Time_Start": 235.64000000000001,
      "Time_End": 242.68,
      "Text": " specify a process access mask and depending on if you have the right permissions on the process"
    },
    {
      "Time_Start": 242.68,
      "Time_End": 246.96,
      "Text": " that you're trying to access, you will be given a handle. There are a bunch of problems with this"
    },
    {
      "Time_Start": 246.96,
      "Time_End": 253.96,
      "Text": " approach. The first or the big problem is that upon process access there's a there's a kernel"
    },
    {
      "Time_Start": 253.96,
      "Time_End": 259.92,
      "Text": " callback. Meaning that the kernel is going to notify every single driver which is subscribing"
    },
    {
      "Time_Start": 259.92,
      "Time_End": 264.96000000000004,
      "Text": " to this kernel callback about this process is actually opening another process with this"
    },
    {
      "Time_Start": 264.96000000000004,
      "Time_End": 271.36,
      "Text": " access mask. Which makes the creation of a new handle quite easy to observe for security products"
    },
    {
      "Time_Start": 271.36,
      "Time_End": 277.04,
      "Text": " because of this kernel callback. And this is why you have the Sysmon event which is letting you"
    },
    {
      "Time_Start": 277.04,
      "Time_End": 283.16,
      "Text": " know that scratchpad.exe is opening notepad.exe in this case. A probably better way would be to make"
    },
    {
      "Time_Start": 283.16,
      "Time_End": 287.72,
      "Text": " use of a concept called handle application and that basically works as follows. The observation is"
    },
    {
      "Time_Start": 287.72,
      "Time_End": 293.6,
      "Text": " that there are multiple processes on Windows and there might even be a process which is already"
    },
    {
      "Time_Start": 293.6,
      "Time_End": 299.08000000000004,
      "Text": " holding a handle on the process that you're trying to inject into. That means that everything you"
    },
    {
      "Time_Start": 299.08,
      "Time_End": 302.71999999999997,
      "Text": " need to do is you need to open the other process which already holds a handle to the process that"
    },
    {
      "Time_Start": 302.71999999999997,
      "Time_End": 307.96,
      "Text": " you're trying to inject into. Duplicate or steal this handle from the other process and then"
    },
    {
      "Time_Start": 307.96,
      "Time_End": 313.08,
      "Text": " reuse it in another context. Like this you're kind of shifting the problem away from opening the"
    },
    {
      "Time_Start": 313.08,
      "Time_End": 319.12,
      "Text": " target process but you're opening another process. Last year I released a tool which"
    },
    {
      "Time_Start": 319.12,
      "Time_End": 324.76,
      "Text": " is called HandleCats. It leverages this exact technique to obtain a handle to else's and it"
    },
    {
      "Time_Start": 325.12,
      "Time_End": 330.48,
      "Text": " pretty well by bypassing a bunch of security products because there's no process access"
    },
    {
      "Time_Start": 330.48,
      "Time_End": 335.44,
      "Text": " event anymore on else's. There's a big problem with this approach however and this approach is"
    },
    {
      "Time_Start": 335.44,
      "Time_End": 339.88,
      "Text": " that there is not always a suitable handle pre-existing on the system that you infected"
    },
    {
      "Time_Start": 339.88,
      "Time_End": 346.48,
      "Text": " so it's not really reliable. What is probably a bit less known is that existing handles can"
    },
    {
      "Time_Start": 346.48,
      "Time_End": 351.64,
      "Text": " also be upgraded. This means that you can basically create a new handle on the target"
    },
    {
      "Time_Start": 351.64,
      "Time_End": 356.64,
      "Text": " process with a very limited access mask which doesn't show your real intent and before you"
    },
    {
      "Time_Start": 356.64,
      "Time_End": 360.44,
      "Text": " actually use it you duplicate it once again and when you duplicate it you say well the"
    },
    {
      "Time_Start": 360.44,
      "Time_End": 365.4,
      "Text": " duplicated version of this handle it would be nice if it had another process, another access"
    },
    {
      "Time_Start": 365.4,
      "Time_End": 372.59999999999997,
      "Text": " mask. This is really cool because there's no suspicious process access event. There's only"
    },
    {
      "Time_Start": 372.59999999999997,
      "Time_End": 379.28,
      "Text": " process the duplication of a pre-existing handle with another access mask. This is quite cool"
    },
    {
      "Time_Start": 379.36,
      "Time_End": 384.88000000000005,
      "Text": " because there are kernel callbacks for handle duplication but system for example is not"
    },
    {
      "Time_Start": 384.88000000000005,
      "Time_End": 392.56000000000006,
      "Text": " subscribing to this kernel callback. You can still observe this in the Windows security log"
    },
    {
      "Time_Start": 392.56000000000006,
      "Time_End": 398.08000000000004,
      "Text": " but the problem with this is that it must actually be configured per process and it's"
    },
    {
      "Time_Start": 398.08000000000004,
      "Time_End": 402.28000000000003,
      "Text": " not enabled by default so I really like to go with this approach in order to get a handle to"
    },
    {
      "Time_Start": 402.28000000000003,
      "Time_End": 407.32000000000005,
      "Text": " another process. The thing is that obtaining a handle was only the first step right. I showed"
    },
    {
      "Time_Start": 407.32,
      "Time_End": 413.4,
      "Text": " you three steps that we need to do. The first step was actually not that difficult. The real"
    },
    {
      "Time_Start": 413.4,
      "Time_End": 418.76,
      "Text": " problem starts we need to we now need to use our newly created handle in order to inject the"
    },
    {
      "Time_Start": 418.76,
      "Time_End": 424.6,
      "Text": " payload into another process. How do we do this? The problem with this is that there are a bunch"
    },
    {
      "Time_Start": 424.6,
      "Time_End": 430.92,
      "Text": " of security techniques trying to make your life more difficult. For example you guys might have"
    },
    {
      "Time_Start": 430.92,
      "Time_End": 435.03999999999996,
      "Text": " heard of a concept called user land hooks. There are even more kernel callbacks and there's also"
    },
    {
      "Time_Start": 435.16,
      "Time_End": 443.24,
      "Text": " event tracing for Windows. Let us first talk a bit about user land hooks and system calls. This"
    },
    {
      "Time_Start": 443.24,
      "Time_End": 448.6,
      "Text": " is a quite old concept and it's being widely used and exploited in the security scene but for those"
    },
    {
      "Time_Start": 448.6,
      "Time_End": 455.04,
      "Text": " of you who might have never heard of two slides of theory. The thing is that antivirus really like"
    },
    {
      "Time_Start": 455.04,
      "Time_End": 461.48,
      "Text": " to redirect the execution flow of suspicious API calls. They do so so that they understand when a"
    },
    {
      "Time_Start": 461.56,
      "Time_End": 467.56,
      "Text": " certain API call was used by a process and with which parameters it was used. They do so because"
    },
    {
      "Time_Start": 467.56,
      "Time_End": 473.36,
      "Text": " they do not really have any other chance to understand when a certain API call is used. There"
    },
    {
      "Time_Start": 473.36,
      "Time_End": 478.40000000000003,
      "Text": " are not there's not a kernel callback for every single system call. This used to be true. We will"
    },
    {
      "Time_Start": 478.40000000000003,
      "Time_End": 485.24,
      "Text": " later get to how it is nowadays. The thing is that system calls which are usually used for process"
    },
    {
      "Time_Start": 485.24,
      "Time_End": 490.56,
      "Text": " injection are obviously hooked because the antivirus product is quite interested in why this"
    },
    {
      "Time_Start": 490.64,
      "Time_End": 500.04,
      "Text": " API is actually used and how it is used. So basically if you're making use of if you're"
    },
    {
      "Time_Start": 500.04,
      "Time_End": 505.92,
      "Text": " trying to create a remote threat the malware is going to go through the extraction layer in kernel"
    },
    {
      "Time_Start": 505.92,
      "Time_End": 511.64,
      "Text": " 32 DLL which is then calling something in the entity layer and the entity layer is then going"
    },
    {
      "Time_Start": 511.64,
      "Time_End": 520.0,
      "Text": " to perform the system call for you. If there's a user land hook in place the first steps are"
    },
    {
      "Time_Start": 520.0,
      "Time_End": 527.36,
      "Text": " similar you still go through kernel DLL you then go to entity layer and last but not least you end"
    },
    {
      "Time_Start": 527.36,
      "Time_End": 534.2,
      "Text": " up in the antivirus DLL which is then doing some analysis for you. There are some obvious ways to"
    },
    {
      "Time_Start": 534.2,
      "Time_End": 539.12,
      "Text": " bypass user land hooks and there are I don't know there are a hundred thousand ways probably. The"
    },
    {
      "Time_Start": 539.12,
      "Time_End": 544.24,
      "Text": " most obvious way to bypass this is to directly conduct a system call and this is doable by"
    },
    {
      "Time_Start": 544.24,
      "Time_End": 552.28,
      "Text": " simply embedding the code snippets of the entity layer into your own malware and then doing letting"
    },
    {
      "Time_Start": 552.28,
      "Time_End": 557.32,
      "Text": " your malware actually do with the the system call for you which directly which effectively bypasses"
    },
    {
      "Time_Start": 557.32,
      "Time_End": 564.52,
      "Text": " kernel 32 entity layer and the other antivirus DLL. However I mean it does bypass user land hooks but"
    },
    {
      "Time_Start": 564.52,
      "Time_End": 569.32,
      "Text": " there are some very obvious problems with this approach. The obvious problem is that all system"
    },
    {
      "Time_Start": 569.36,
      "Time_End": 575.44,
      "Text": " calls should go through entity layer. If any other module than entity DLL is doing a system call then"
    },
    {
      "Time_Start": 575.44,
      "Time_End": 581.4000000000001,
      "Text": " this is quite suspicious because this should actually never be the case and if you take a"
    },
    {
      "Time_Start": 581.4000000000001,
      "Time_End": 586.48,
      "Text": " look at Sysmon in the first in the upper screenshot we see the usage of the Windows API and we see"
    },
    {
      "Time_Start": 586.48,
      "Time_End": 591.12,
      "Text": " that the last module in the call trace is actually entity DLL but if you make use of direct system"
    },
    {
      "Time_Start": 591.12,
      "Time_End": 600.0,
      "Text": " calls here I use the tool by Outflank. We see that the last module in the call trace is actually"
    },
    {
      "Time_Start": 600.0,
      "Time_End": 605.48,
      "Text": " not entity DLL but it's Outflank dumper DLL which is a big indicator of compromise I'm assuming."
    },
    {
      "Time_Start": 605.48,
      "Time_End": 612.64,
      "Text": " The problem however is that yes you can sometimes observe direct system calls using Sysmon but there"
    },
    {
      "Time_Start": 612.64,
      "Time_End": 617.52,
      "Text": " are not kernel callbacks for every single system call there is. There's one for empty open process"
    },
    {
      "Time_Start": 617.72,
      "Time_End": 625.76,
      "Text": " but there are way more system calls you guys might be interested in. And since there is no kernel"
    },
    {
      "Time_Start": 625.76,
      "Time_End": 632.76,
      "Text": " callback for every single system call you might want to use an additional framework. And an"
    },
    {
      "Time_Start": 632.76,
      "Time_End": 636.48,
      "Text": " additional framework which you might be leveraging is called Novana which is an"
    },
    {
      "Time_Start": 636.48,
      "Time_End": 641.68,
      "Text": " instrumentation engine used by Microsoft. It's present in Windows Sense Vista. It's a quite"
    },
    {
      "Time_Start": 641.68,
      "Time_End": 646.52,
      "Text": " complicated thing and I'm not going to get into too many details here but it can actually be used"
    },
    {
      "Time_Start": 646.52,
      "Time_End": 652.76,
      "Text": " to monitor and control user met processes without recompiling the target. More importantly it even"
    },
    {
      "Time_Start": 652.76,
      "Time_End": 658.04,
      "Text": " allows us to define callbacks for system calls upon return from kernel mode. And what that means"
    },
    {
      "Time_Start": 658.04,
      "Time_End": 666.16,
      "Text": " is that we can basically specify if a system call returns from kernel mode it should before it"
    },
    {
      "Time_Start": 666.16,
      "Time_End": 672.84,
      "Text": " continues execution in user mode it should execute our user specified callback. And this actually"
    },
    {
      "Time_Start": 672.88,
      "Time_End": 680.0,
      "Text": " allows us to hook basically every single system call and perform some additional code before it"
    },
    {
      "Time_Start": 680.0,
      "Time_End": 685.88,
      "Text": " transitions back to user mode. More importantly it allows us to check where the system call is"
    },
    {
      "Time_Start": 685.88,
      "Time_End": 690.4,
      "Text": " returning in user mode. If it's not returning to somewhere in NTDLL then this is obviously an IOC."
    },
    {
      "Time_Start": 690.4,
      "Time_End": 696.4,
      "Text": " And there's a really cool sample implementation by Winternal and if you make use of this"
    },
    {
      "Time_Start": 696.4,
      "Time_End": 704.4,
      "Text": " implementation again against outflank dumper the implementation by Winternal I think it's"
    },
    {
      "Time_Start": 704.4,
      "Time_End": 710.16,
      "Text": " called syscall detect is immediately complaining that the kernel returns to an unverified module"
    },
    {
      "Time_Start": 710.16,
      "Time_End": 716.12,
      "Text": " and it's going to exit. So this can actually potentially be used by security products in"
    },
    {
      "Time_Start": 716.12,
      "Time_End": 720.52,
      "Text": " order to identify direct system calls it's just that the performance overhead might actually be"
    },
    {
      "Time_Start": 720.56,
      "Time_End": 727.3199999999999,
      "Text": " a big issue here. Okay so what can we do against this? Obviously we need to make sure that our"
    },
    {
      "Time_Start": 727.3199999999999,
      "Time_End": 733.48,
      "Text": " system calls go through NTDLL and bypass userland hooks at the same time. And the cool observation"
    },
    {
      "Time_Start": 733.48,
      "Time_End": 738.64,
      "Text": " is that an antivirus product does of course not hook every single system call there is otherwise"
    },
    {
      "Time_Start": 738.64,
      "Time_End": 744.76,
      "Text": " it would also run into performance problems. It only hooks those system calls it's actually"
    },
    {
      "Time_Start": 744.76,
      "Time_End": 750.3199999999999,
      "Text": " interested in. This leaves us to the observation or this brings us to the observation that some"
    },
    {
      "Time_Start": 750.36,
      "Time_End": 755.36,
      "Text": " system call stops are simply not hooked because the API calls are simply not interesting enough."
    },
    {
      "Time_Start": 755.36,
      "Time_End": 761.5200000000001,
      "Text": " Yet all system call stops do pretty much the same thing but they use a different system call number"
    },
    {
      "Time_Start": 761.5200000000001,
      "Time_End": 766.72,
      "Text": " so basically they move the system call number to EAX and then perform the system call by syscall"
    },
    {
      "Time_Start": 766.72,
      "Time_End": 775.6,
      "Text": " read. What can we do? The idea could be to first resolve the system call number by using a technique"
    },
    {
      "Time_Start": 775.6,
      "Time_End": 781.52,
      "Text": " called HaloSkate which is by sector 7 and then we initialize the system call manually and then"
    },
    {
      "Time_Start": 781.52,
      "Time_End": 787.16,
      "Text": " we reuse existing syscall read instructions from a clean system call stop in order to perform system"
    },
    {
      "Time_Start": 787.16,
      "Time_End": 794.6800000000001,
      "Text": " call. So we basically jump to a very certain location of a clean system call stop which is"
    },
    {
      "Time_Start": 794.6800000000001,
      "Time_End": 799.76,
      "Text": " the system call read instruction we basically reuse these instructions from a clean system call"
    },
    {
      "Time_Start": 799.76,
      "Time_End": 810.2,
      "Text": " stop. So I'm a paint master. We first set up the registers then we kind of reuse the stop once"
    },
    {
      "Time_Start": 810.2,
      "Time_End": 814.56,
      "Text": " again meaning that we choose a clean system call stop which is not hooked and then we use the"
    },
    {
      "Time_Start": 814.56,
      "Time_End": 818.12,
      "Text": " system call read instructions from there which effectively bypasses userland hooks and we're"
    },
    {
      "Time_Start": 818.12,
      "Time_End": 823.48,
      "Text": " going through entity layer at the same time. I wrote a small implementation for this you can find it on"
    },
    {
      "Time_Start": 823.48,
      "Time_End": 829.96,
      "Text": " my github and if I make use of this and I use the syscall detect to at the same time it's not"
    },
    {
      "Time_Start": 829.96,
      "Time_End": 836.08,
      "Text": " complaining. Why is it not complaining? Because the system calls they all return to entity DLL and you"
    },
    {
      "Time_Start": 836.08,
      "Time_End": 843.28,
      "Text": " see on the last module on the call stack is entity DLL. There are still some IOCs though because"
    },
    {
      "Time_Start": 843.28,
      "Time_End": 849.9200000000001,
      "Text": " usually system calls go through kernel based DLL and then to entity DLL. This is the first IOC. The"
    },
    {
      "Time_Start": 849.9200000000001,
      "Time_End": 854.72,
      "Text": " second IOC is that yeah the system call returns to entity DLL but it does not return to the correct"
    },
    {
      "Time_Start": 854.72,
      "Time_End": 860.1600000000001,
      "Text": " stop which is associated with the executed system call and by leveraging hooking nirvana this might"
    },
    {
      "Time_Start": 860.1600000000001,
      "Time_End": 867.08,
      "Text": " be an idea in order to leverage this. So userland hooks are still a thing in 2022 actually and I"
    },
    {
      "Time_Start": 867.08,
      "Time_End": 871.48,
      "Text": " was quite surprised about this because I thought it's like a relict from the past but that's not"
    },
    {
      "Time_Start": 871.48,
      "Time_End": 878.5600000000001,
      "Text": " the case. Many antivirus security products still rely heavily on them and the question is why. The"
    },
    {
      "Time_Start": 878.6800000000001,
      "Time_End": 885.24,
      "Text": " first reason is that monitoring from kernel only can cause stability issues because if you fuck up"
    },
    {
      "Time_Start": 885.24,
      "Time_End": 892.12,
      "Text": " your kernel driver then your client won't be protected but has a blue screen and the second"
    },
    {
      "Time_Start": 892.12,
      "Time_End": 897.84,
      "Text": " problem was, this is not the case anymore, but it was that missing telemetry because there was no"
    },
    {
      "Time_Start": 897.84,
      "Time_End": 903.72,
      "Text": " other way for an antivirus to understand if and how a certain API call was used. So it was used"
    },
    {
      "Time_Start": 903.88,
      "Time_End": 910.0400000000001,
      "Text": " as a patch to get more telemetry. What matters from the attacker's perspective is basically that"
    },
    {
      "Time_Start": 910.0400000000001,
      "Time_End": 915.24,
      "Text": " userland hooks are not a problem. They can always be efficiently and stealthily bypassed and GitHub"
    },
    {
      "Time_Start": 915.24,
      "Time_End": 920.84,
      "Text": " is full of userland hook bypassing techniques. So now we should be able to conduct memory"
    },
    {
      "Time_Start": 920.84,
      "Time_End": 925.76,
      "Text": " operations on the remote process with the handle we gained earlier in a very stealth way. So we"
    },
    {
      "Time_Start": 925.76,
      "Time_End": 931.52,
      "Text": " should be able to inject our payload using every single API call we want. Is that true? And the"
    },
    {
      "Time_Start": 931.52,
      "Time_End": 936.4,
      "Text": " thing is we still need to keep some facts in mind because some system calls trigger a kernel"
    },
    {
      "Time_Start": 936.4,
      "Time_End": 941.76,
      "Text": " callback as I was saying before and others can actually be observed by ETW because there's a"
    },
    {
      "Time_Start": 941.76,
      "Time_End": 949.24,
      "Text": " ETW provider which many security solutions have begun subscribing on and it's called the Microsoft"
    },
    {
      "Time_Start": 949.24,
      "Time_End": 954.8,
      "Text": " Windows Threat Intelligence ETW provider. The provider sits in kernel so there's not a lot you"
    },
    {
      "Time_Start": 954.8000000000001,
      "Time_End": 961.6800000000001,
      "Text": " can do against this from user mode and for us it's kind of a problem because it delivers events"
    },
    {
      "Time_Start": 961.6800000000001,
      "Time_End": 966.4000000000001,
      "Text": " for everything that might be used for process injection. You know, APCs, suspending threats,"
    },
    {
      "Time_Start": 966.4000000000001,
      "Time_End": 971.6400000000001,
      "Text": " resuming threats and so on and so on. So it should provide enough telemetry in order to observe"
    },
    {
      "Time_Start": 971.6400000000001,
      "Time_End": 977.32,
      "Text": " typical process injection techniques and there are a bunch of device event action types you can use."
    },
    {
      "Time_Start": 978.1600000000001,
      "Time_End": 984.5600000000001,
      "Text": " I tried to write rules for this for a client, for a very big client in a purple teaming assessment"
    },
    {
      "Time_Start": 984.5600000000001,
      "Time_End": 991.24,
      "Text": " and yeah you can see the process injection it's just that these API calls are often so often used"
    },
    {
      "Time_Start": 991.24,
      "Time_End": 995.6,
      "Text": " in a legitimate context that it's almost impossible to write a working detection rule for this without"
    },
    {
      "Time_Start": 995.6,
      "Time_End": 1000.96,
      "Text": " having any false positives. So what actually matters in my opinion is which process and"
    },
    {
      "Time_Start": 1000.96,
      "Time_End": 1005.36,
      "Text": " injects into which other process and more importantly what is actually being injected."
    },
    {
      "Time_Start": 1005.36,
      "Time_End": 1010.48,
      "Text": " If you inject a plain Cobalt Stoic beacon into another process in the most stealth way it will"
    },
    {
      "Time_Start": 1010.48,
      "Time_End": 1015.6,
      "Text": " still be it will still be picked up simply because it's Cobalt Stoic. So our next problem is actually"
    },
    {
      "Time_Start": 1015.6,
      "Time_End": 1021.64,
      "Text": " static signatures and we need to think about how to avoid static signatures or evade static"
    },
    {
      "Time_Start": 1021.64,
      "Time_End": 1026.72,
      "Text": " signatures. Okay once again we successfully injected our payload into the target process"
    },
    {
      "Time_Start": 1026.72,
      "Time_End": 1032.0,
      "Text": " and obviously now YARA rules are applied by security products in order to identify if it is"
    },
    {
      "Time_Start": 1032.0,
      "Time_End": 1036.12,
      "Text": " something they already know and there are multiple ways to bypass this some are better than others"
    },
    {
      "Time_Start": 1036.12,
      "Time_End": 1042.56,
      "Text": " but let us take a look at this. The first concept is called polymorphism but it's a very old concept"
    },
    {
      "Time_Start": 1042.56,
      "Time_End": 1046.76,
      "Text": " what you're doing is basically you encrypt your payload and you glue it together with a decryption"
    },
    {
      "Time_Start": 1046.76,
      "Time_End": 1053.32,
      "Text": " stop the decryption stop decrypts the payload and then actually executes it. So here we have a"
    },
    {
      "Time_Start": 1053.32,
      "Time_End": 1058.6,
      "Text": " hello world.bin which basically pops up a message box and we remember it starts with ASCII VH"
    },
    {
      "Time_Start": 1058.6799999999998,
      "Time_End": 1065.1999999999998,
      "Text": " something something. If you put it into executable memory it pops a message box and we see the VH"
    },
    {
      "Time_Start": 1065.1999999999998,
      "Time_End": 1071.04,
      "Text": " something something in the executable memory page. Cool. Now if you make use of Shikata Ganai which"
    },
    {
      "Time_Start": 1071.04,
      "Time_End": 1075.48,
      "Text": " is a polymorph encoder we see that yeah it looks really different it doesn't start with VH and"
    },
    {
      "Time_Start": 1075.48,
      "Time_End": 1080.24,
      "Text": " there's no VH something something anymore because it's encrypted but what happens if we actually"
    },
    {
      "Time_Start": 1080.24,
      "Time_End": 1085.36,
      "Text": " actually execute it in memory we see that the first bytes are different but at some point our VH"
    },
    {
      "Time_Start": 1085.72,
      "Time_End": 1091.8000000000002,
      "Text": " something something pops up once again and we wanted to avoid this wasn't it. So there are a"
    },
    {
      "Time_Start": 1091.8000000000002,
      "Time_End": 1098.2,
      "Text": " bunch of problems with polymorphism. First it needs RWX which is an indicator as such. Second"
    },
    {
      "Time_Start": 1098.2,
      "Time_End": 1102.88,
      "Text": " thing the decryption stop as such can be fingerprinted and after decryption your malware or"
    },
    {
      "Time_Start": 1102.88,
      "Time_End": 1107.72,
      "Text": " your tool or whatever is not protected in plain in memory. So it might have to bypass the initial"
    },
    {
      "Time_Start": 1107.72,
      "Time_End": 1113.0400000000002,
      "Text": " memory scan but at some point if memory scan happens like I don't know 20 minutes later your"
    },
    {
      "Time_Start": 1113.2,
      "Time_End": 1118.44,
      "Text": " Cobalt Strike beacon or whatever is going to be plain in memory. Cobalt Strike makes use of or"
    },
    {
      "Time_Start": 1118.44,
      "Time_End": 1123.36,
      "Text": " tackles this problem with a concept called sleep mask. It was introduced in version 4 the 3 is"
    },
    {
      "Time_Start": 1123.36,
      "Time_End": 1129.12,
      "Text": " wrong it's 4 something and the core idea is actually quite simple. The observation is that a"
    },
    {
      "Time_Start": 1129.12,
      "Time_End": 1133.8799999999999,
      "Text": " beacon basically spends most of the time sleeping and waiting for new commands. So what you can do"
    },
    {
      "Time_Start": 1133.8799999999999,
      "Time_End": 1139.28,
      "Text": " is while sleeping the beacon actually obfuscates and encrypts itself in memory while it is sleeping"
    },
    {
      "Time_Start": 1139.44,
      "Time_End": 1145.32,
      "Text": " and you must be quite unlucky if the memory scanner hits you right in the in the situation"
    },
    {
      "Time_Start": 1145.32,
      "Time_End": 1150.24,
      "Text": " where your beacon is active because usually beacon is active only for I don't know a fraction of a"
    },
    {
      "Time_Start": 1150.24,
      "Time_End": 1154.56,
      "Text": " second or something like that. There are some limitations with this however because the first"
    },
    {
      "Time_Start": 1154.56,
      "Time_End": 1158.48,
      "Text": " limitation might be that the sleep mask itself can be fingerprinted you can customize this in"
    },
    {
      "Time_Start": 1158.48,
      "Time_End": 1163.04,
      "Text": " Cobalt Strike and we also have other memory artifacts which we will which we will take a"
    },
    {
      "Time_Start": 1163.04,
      "Time_End": 1169.08,
      "Text": " look at later. I however like to use another concept and the idea is to change the appearance"
    },
    {
      "Time_Start": 1169.12,
      "Time_End": 1174.04,
      "Text": " of a program on instruction level. If we change the appearance of a program on instruction level"
    },
    {
      "Time_Start": 1174.04,
      "Time_End": 1179.52,
      "Text": " we do not need any encoding or encrypting or whatever and we do also not need any RWX because"
    },
    {
      "Time_Start": 1179.52,
      "Time_End": 1185.4399999999998,
      "Text": " we're not encrypting anything. There are multiple ways to achieve this. One way to achieve this is"
    },
    {
      "Time_Start": 1185.4399999999998,
      "Time_End": 1191.3999999999999,
      "Text": " to substitute instructions with a sequence of instructions which lead to the same result yet"
    },
    {
      "Time_Start": 1191.3999999999999,
      "Time_End": 1197.76,
      "Text": " these are other instructions. What you could also be doing is add useless instructions or add trash"
    },
    {
      "Time_Start": 1197.8799999999999,
      "Time_End": 1204.04,
      "Text": " and jump over the trash or you shuffle the basic blocks or whatever. The terminology for this is"
    },
    {
      "Time_Start": 1204.04,
      "Time_End": 1207.68,
      "Text": " quite unclear for me if you google this some actually call it a variant of polymorphism"
    },
    {
      "Time_Start": 1207.68,
      "Time_End": 1215.12,
      "Text": " other call it metamorphism. In this talk we call it keyless polymorphism. So some ideas for"
    },
    {
      "Time_Start": 1215.12,
      "Time_End": 1220.28,
      "Text": " substitutions if you want to null out a register either you can write XOR iX iX or you move a zero"
    },
    {
      "Time_Start": 1220.28,
      "Time_End": 1226.44,
      "Text": " to iX or you store another register on the stack null out this register move this register to iX"
    },
    {
      "Time_Start": 1226.52,
      "Time_End": 1231.8400000000001,
      "Text": " and then restore this register. If you want to jump to our RCX you could also write push RCX and"
    },
    {
      "Time_Start": 1231.8400000000001,
      "Time_End": 1237.64,
      "Text": " then return where push RCX could also be written like this. So there are a bunch of ideas or"
    },
    {
      "Time_Start": 1237.64,
      "Time_End": 1244.0,
      "Text": " instructions which can be substituted with an equivalent of other instructions. By adding trash"
    },
    {
      "Time_Start": 1244.0,
      "Time_End": 1249.0800000000002,
      "Text": " as I said basically you add complete trash bytes or instructions which don't make any sense at all"
    },
    {
      "Time_Start": 1249.0800000000002,
      "Time_End": 1255.6000000000001,
      "Text": " and you add a jump over the trash and however you do it in the end of the day so on the left side"
    },
    {
      "Time_Start": 1255.8000000000002,
      "Time_End": 1262.96,
      "Text": " we see our actual program which is not obfuscated or whatever and on the right side we see that the"
    },
    {
      "Time_Start": 1262.96,
      "Time_End": 1268.3200000000002,
      "Text": " first instruction was substituted with another instruction second one is also substituted then"
    },
    {
      "Time_Start": 1268.3200000000002,
      "Time_End": 1272.5200000000002,
      "Text": " we have a jump over the trash and probably an instruction which could not be substituted and"
    },
    {
      "Time_Start": 1272.5200000000002,
      "Time_End": 1278.2800000000002,
      "Text": " last but not least another substitution. I really like to leverage this technique to protect my"
    },
    {
      "Time_Start": 1278.2800000000002,
      "Time_End": 1282.72,
      "Text": " tools from automated memory scanners and it's quite powerful if enough instructions are substituted."
    },
    {
      "Time_Start": 1282.84,
      "Time_End": 1287.1200000000001,
      "Text": " You obviously need the source code for this because otherwise you would be breaking relative"
    },
    {
      "Time_Start": 1287.1200000000001,
      "Time_End": 1292.64,
      "Text": " jumps and if you consider this to be a problem it makes a payload obviously significantly larger."
    },
    {
      "Time_Start": 1292.64,
      "Time_End": 1298.68,
      "Text": " Also you need to take into consideration that strings and constants need to be encrypted and"
    },
    {
      "Time_Start": 1298.68,
      "Time_End": 1304.44,
      "Text": " obfuscated additionally because this is not part of the polymorph process. Doing this by hand is"
    },
    {
      "Time_Start": 1304.44,
      "Time_End": 1309.88,
      "Text": " really really annoying and you should automate this. I will later get back to how to automate"
    },
    {
      "Time_Start": 1309.88,
      "Time_End": 1316.5200000000002,
      "Text": " this. Cool so once again we remember our VH something something shellcode that pops a message"
    },
    {
      "Time_Start": 1316.5200000000002,
      "Time_End": 1323.44,
      "Text": " box and here if we use this keyless polymorph concept we see that it actually doesn't start"
    },
    {
      "Time_Start": 1323.44,
      "Time_End": 1329.72,
      "Text": " with VH anymore actually you don't find these constants anymore in an executable memory page"
    },
    {
      "Time_Start": 1329.72,
      "Time_End": 1336.8400000000001,
      "Text": " yet the message box still pops up. If there's someone really careful you see that this is"
    },
    {
      "Time_Start": 1336.84,
      "Time_End": 1342.0,
      "Text": " actually in an rwx page I earlier said you don't need rwx it's because I forgot to change the page"
    },
    {
      "Time_Start": 1342.0,
      "Time_End": 1348.9599999999998,
      "Text": " permissions. Cool so now we gained a handle in a very stealthy way. We defended user land hooks"
    },
    {
      "Time_Start": 1348.9599999999998,
      "Time_End": 1355.24,
      "Text": " while still we go through NTDLL and we defeated scanners using some kind of polymorphism. The"
    },
    {
      "Time_Start": 1355.24,
      "Time_End": 1359.52,
      "Text": " problem now is that in fact the processes leave a lot of other IRCs so even if you manage to"
    },
    {
      "Time_Start": 1359.52,
      "Time_End": 1365.0,
      "Text": " infect a process that you wanted to infect you still have a lot of other IRCs. Let us take a"
    },
    {
      "Time_Start": 1365.2,
      "Time_End": 1373.56,
      "Text": " look at suspicious artifacts. To understand this some basics Windows roughly has three types of"
    },
    {
      "Time_Start": 1373.56,
      "Time_End": 1377.6,
      "Text": " memory there's private committed memory which is reserved for heap and stack there's map memory"
    },
    {
      "Time_Start": 1377.6,
      "Time_End": 1382.28,
      "Text": " which is used for file mapping and IPC and there's also image committed memory which is basically"
    },
    {
      "Time_Start": 1382.28,
      "Time_End": 1390.2,
      "Text": " used by PE files and executable executables and the thing is that usually only image committed"
    },
    {
      "Time_Start": 1390.24,
      "Time_End": 1396.52,
      "Text": " memory should be marked as executable. There are some false positives or there's some exceptions"
    },
    {
      "Time_Start": 1396.52,
      "Time_End": 1403.8,
      "Text": " for example managed code like C sharp because it's bytecode which is compiled interpreted at"
    },
    {
      "Time_Start": 1403.8,
      "Time_End": 1409.8400000000001,
      "Text": " runtime but as we see on the screenshot actually only or normally only image committed memory"
    },
    {
      "Time_Start": 1409.8400000000001,
      "Time_End": 1416.0800000000002,
      "Text": " should be marked as executable and this gives us a big problem because somehow we need to gain"
    },
    {
      "Time_Start": 1416.24,
      "Time_End": 1421.6,
      "Text": " executable memory while injecting into remote process and the problem is how do we actually"
    },
    {
      "Time_Start": 1421.6,
      "Time_End": 1428.1599999999999,
      "Text": " get executable memory in a remote process and there are a bunch of memory scanners which are"
    },
    {
      "Time_Start": 1428.1599999999999,
      "Time_End": 1435.6,
      "Text": " really really good at finding memories or abnormal memory allocations the one by Monita is really"
    },
    {
      "Time_Start": 1435.6,
      "Time_End": 1440.8799999999999,
      "Text": " popular and they're really good at detecting abnormal memory allocations so for example if"
    },
    {
      "Time_Start": 1440.88,
      "Time_End": 1446.3200000000002,
      "Text": " you make use of virtual alloc or anti-map view of section or whatever Monita is quickly complaining"
    },
    {
      "Time_Start": 1446.3200000000002,
      "Time_End": 1452.48,
      "Text": " about hey there are two pages which are marked as executable yet they are marked as private"
    },
    {
      "Time_Start": 1452.48,
      "Time_End": 1458.6000000000001,
      "Text": " commit what the fuck is this that doesn't make any sense the next next try could be to make use"
    },
    {
      "Time_Start": 1458.6000000000001,
      "Time_End": 1464.3600000000001,
      "Text": " of DLL hollowing where we load an unused DLL into the remote process and then we place the text"
    },
    {
      "Time_Start": 1464.3600000000001,
      "Time_End": 1471.7600000000002,
      "Text": " segment with our own code problem Monita is complaining again why for two reasons first"
    },
    {
      "Time_Start": 1471.7600000000002,
      "Time_End": 1478.2,
      "Text": " Monita is asking why did this process load this DLL it's not declared in the PB or anywhere why"
    },
    {
      "Time_Start": 1478.2,
      "Time_End": 1484.48,
      "Text": " did it decide to load this DLL second problem the text segment of the DLL on disk is not the"
    },
    {
      "Time_Start": 1484.48,
      "Time_End": 1490.48,
      "Text": " same as the text segment of the DLL in memory it's also a big problem for Monita and there"
    },
    {
      "Time_Start": 1490.48,
      "Time_End": 1498.24,
      "Text": " are a bunch of ways to bypass memory scanners and they basically all boil down to changing the"
    },
    {
      "Time_Start": 1498.24,
      "Time_End": 1505.08,
      "Text": " page permission of the beacon while it's actually sleeping because memory scanners only check for"
    },
    {
      "Time_Start": 1505.08,
      "Time_End": 1512.28,
      "Text": " executable memory regions in order to find known better this leaves us this brings us a big problem"
    },
    {
      "Time_Start": 1512.28,
      "Time_End": 1517.84,
      "Text": " because how do you mark your own code as not executable while you're executing this should"
    },
    {
      "Time_Start": 1517.84,
      "Time_End": 1524.1599999999999,
      "Text": " not actually happen this note should not work but it does work with a bit of black magic and"
    },
    {
      "Time_Start": 1524.1599999999999,
      "Time_End": 1529.12,
      "Text": " I like to you leverage a concept used by exploit coders which is called return oriented programming"
    },
    {
      "Time_Start": 1529.12,
      "Time_End": 1537.32,
      "Text": " which leverages stack pivoting and existing small code snippets from any entity or other execute"
    },
    {
      "Time_Start": 1537.32,
      "Time_End": 1543.1999999999998,
      "Text": " memory which is there legitimately so the idea is before the beacon goes to sleep we set up a"
    },
    {
      "Time_Start": 1543.28,
      "Time_End": 1548.64,
      "Text": " chain which first calls virtual protect marking our beacon as not executable then it drops itself"
    },
    {
      "Time_Start": 1548.64,
      "Time_End": 1557.1200000000001,
      "Text": " to sleep and then it rubs itself again to page execute read this is nothing new as such the"
    },
    {
      "Time_Start": 1557.1200000000001,
      "Time_End": 1562.92,
      "Text": " original idea was called gargoyle I'm assuming it was first implemented by F secure but I'm not sure"
    },
    {
      "Time_Start": 1562.92,
      "Time_End": 1569.72,
      "Text": " about this and the core idea here is that before we go to sleep we set up the stack and we set up"
    },
    {
      "Time_Start": 1569.72,
      "Time_End": 1575.48,
      "Text": " the stack as follows the first return address on the stack points to a gadget which sets up"
    },
    {
      "Time_Start": 1575.48,
      "Time_End": 1581.56,
      "Text": " the registers or which pop which pops the other values on the stack in a certain way and in such"
    },
    {
      "Time_Start": 1581.56,
      "Time_End": 1587.96,
      "Text": " a way that on the next return when virtual protect happens the address of the beacon is not marked or"
    },
    {
      "Time_Start": 1587.96,
      "Time_End": 1592.84,
      "Text": " the page of the beacon is not marked as executable anymore so upon the next return our beacon looks"
    },
    {
      "Time_Start": 1592.84,
      "Time_End": 1597.88,
      "Text": " like this it's not executable anymore and the stack looks like this and now the first gadget on"
    },
    {
      "Time_Start": 1597.88,
      "Time_End": 1606.0800000000002,
      "Text": " the stack points to a pop RCX gadget which effectively puts the 5,000 on the stack to RCX"
    },
    {
      "Time_Start": 1606.0800000000002,
      "Time_End": 1610.0800000000002,
      "Text": " which is the first parameter for sleep and then it pops the return address of sleep and goes to"
    },
    {
      "Time_Start": 1610.0800000000002,
      "Time_End": 1615.5600000000002,
      "Text": " sleep for 5,000 milliseconds now the beacon is not executable and it's sleeping at the same time"
    },
    {
      "Time_Start": 1615.5600000000002,
      "Time_End": 1623.4,
      "Text": " and when the beacon returns obviously it takes a first return address from the stack again setting"
    },
    {
      "Time_Start": 1623.4,
      "Time_End": 1631.76,
      "Text": " up the registers for virtual protect which then upon returning makes our beacon resuming I released"
    },
    {
      "Time_Start": 1631.76,
      "Time_End": 1638.3600000000001,
      "Text": " the small proof of concept for this which I call deep sleep it's awesome like it up while it is"
    },
    {
      "Time_Start": 1638.3600000000001,
      "Time_End": 1643.68,
      "Text": " active it's actually popping a message box and monitor complains why because there is private"
    },
    {
      "Time_Start": 1643.68,
      "Time_End": 1650.94,
      "Text": " executable memory or something but while sleeping we see that the page of deep sleep is actually"
    },
    {
      "Time_Start": 1650.94,
      "Time_End": 1660.3,
      "Text": " marked as not available or execute we'd only we'd only make sense so we bypass memory scanners"
    },
    {
      "Time_Start": 1660.3,
      "Time_End": 1666.94,
      "Text": " looking for executable memory there are a bunch of other implementations they all boil down once"
    },
    {
      "Time_Start": 1666.94,
      "Time_End": 1671.66,
      "Text": " again to the to the same idea which is changing the page permissions while sleeping there's one"
    },
    {
      "Time_Start": 1671.66,
      "Time_End": 1677.46,
      "Text": " by cracked spider there's one by sec idiot called foliage yeah but they are all pretty much boiled"
    },
    {
      "Time_Start": 1677.46,
      "Time_End": 1682.9,
      "Text": " onto the same idea now the question is actually this was quite complicated and the question is"
    },
    {
      "Time_Start": 1682.9,
      "Time_End": 1689.06,
      "Text": " is that actually necessary and I would say no because if you run monitor on Firefox for example"
    },
    {
      "Time_Start": 1689.06,
      "Time_End": 1693.9,
      "Text": " you see a bunch of false positives once again so you also see in Firefox there's that there is a"
    },
    {
      "Time_Start": 1693.9,
      "Time_End": 1699.98,
      "Text": " bunch of private and executable memory and even modified it on its own delay its own entity"
    },
    {
      "Time_Start": 1700.14,
      "Time_End": 1707.6200000000001,
      "Text": " so I believe that memory artifacts alone quite good first indicator but they have way way too"
    },
    {
      "Time_Start": 1707.6200000000001,
      "Time_End": 1713.6200000000001,
      "Text": " many false positives for example why did Firefox change its own entity layer it's because it would"
    },
    {
      "Time_Start": 1713.6200000000001,
      "Time_End": 1719.18,
      "Text": " likes to hook its own create thread as a matter of an anti-exploit mechanism memory scanners can"
    },
    {
      "Time_Start": 1719.18,
      "Time_End": 1725.1,
      "Text": " also be bypassed using gargoyle like techniques and so the problem is that we definitely more need"
    },
    {
      "Time_Start": 1725.38,
      "Time_End": 1732.8200000000002,
      "Text": " metrics in order to identify in fact the processes once again the observation is that beacons spend"
    },
    {
      "Time_Start": 1732.8200000000002,
      "Time_End": 1738.8600000000001,
      "Text": " most of the time waiting for new commands and what developers really like to do to make the"
    },
    {
      "Time_Start": 1738.8600000000001,
      "Time_End": 1744.42,
      "Text": " beacon sleep is to simply call sleep this is really obvious right but there's a big problem"
    },
    {
      "Time_Start": 1744.42,
      "Time_End": 1750.3400000000001,
      "Text": " with sleep and the problem with this API call is that it sets this threat which is calling sleep"
    },
    {
      "Time_Start": 1750.38,
      "Time_End": 1757.38,
      "Text": " to a very special state it's called anti it's called delay execution and on my machine I had"
    },
    {
      "Time_Start": 1757.38,
      "Time_End": 1765.3400000000001,
      "Text": " 1500 threats out of these one 1,500 threats and only 20 were in the state delay execution so we"
    },
    {
      "Time_Start": 1765.3400000000001,
      "Time_End": 1773.18,
      "Text": " boiled down from 1500 to 20 threats which might be a beacon 20 are still too many to check so we"
    },
    {
      "Time_Start": 1773.18,
      "Time_End": 1778.9,
      "Text": " need another metric the next metric could be a call stack on the left side we see a normal call"
    },
    {
      "Time_Start": 1778.9,
      "Time_End": 1784.9,
      "Text": " stack we see that that it starts somewhere in user thread start and it can map every return"
    },
    {
      "Time_Start": 1784.9,
      "Time_End": 1791.9,
      "Text": " address on the stack to a module on disk on the right side we see the one of a cobblestock beacon"
    },
    {
      "Time_Start": 1791.9,
      "Time_End": 1796.02,
      "Text": " and we see that it does not start where it's supposed to start and at the same time there is"
    },
    {
      "Time_Start": 1796.02,
      "Time_End": 1803.5400000000002,
      "Text": " this hex 1a what is this this cannot be associated with a file on disk this is quite abnormal and if"
    },
    {
      "Time_Start": 1803.54,
      "Time_End": 1809.1,
      "Text": " you take a look at the implementation of gargoyles of the deep sleep thing the cost that looks even"
    },
    {
      "Time_Start": 1809.1,
      "Time_End": 1813.62,
      "Text": " more broken because there are a bunch of pointers which cannot be mapped to a file on disk and it"
    },
    {
      "Time_Start": 1813.62,
      "Time_End": 1818.54,
      "Text": " looks like virtual protect is calling sleep if you show me a developer who does this legitimacy I"
    },
    {
      "Time_Start": 1818.54,
      "Time_End": 1826.34,
      "Text": " want to talk to him so yeah call stacks are also a thing and now the question is out of the 1500"
    },
    {
      "Time_Start": 1826.34,
      "Time_End": 1832.02,
      "Text": " threads I have on my machine how many of these are in delay execution and have a stack trace to delay"
    },
    {
      "Time_Start": 1832.1,
      "Time_End": 1836.9,
      "Text": " execution which contains unknown or tempered regions the answer it's only one and it's a"
    },
    {
      "Time_Start": 1836.9,
      "Time_End": 1843.22,
      "Text": " beacon so also for this I created a small tool to automate these steps it's called Hans sleeping"
    },
    {
      "Time_Start": 1843.22,
      "Time_End": 1849.06,
      "Text": " beacons and it first enumerates threats which are in delay execution and then it checks the call"
    },
    {
      "Time_Start": 1849.06,
      "Time_End": 1856.46,
      "Text": " stack for unknown regions and also for text segments which do differ compared from the"
    },
    {
      "Time_Start": 1856.78,
      "Time_End": 1866.66,
      "Text": " in memory compared to the version on disk yeah it picks up deep sleep because this the threat"
    },
    {
      "Time_Start": 1866.66,
      "Time_End": 1873.66,
      "Text": " is caught is in delay execution and the stack is really really broken I had some false positives"
    },
    {
      "Time_Start": 1873.66,
      "Time_End": 1879.38,
      "Text": " with this approach I had positive false positives with update us which are trying to protect itself"
    },
    {
      "Time_Start": 1879.38,
      "Time_End": 1883.74,
      "Text": " because they're actually behaving like a beacon you know they're also trying to obfuscate themselves"
    },
    {
      "Time_Start": 1883.74,
      "Time_End": 1888.22,
      "Text": " in memory because you don't they don't want you to reverse it at the same time they're also"
    },
    {
      "Time_Start": 1888.22,
      "Time_End": 1895.54,
      "Text": " sleeping between their intervals and I also had some false positives with very crappy C sharp"
    },
    {
      "Time_Start": 1895.54,
      "Time_End": 1900.34,
      "Text": " applications there are some other very easy bypasses from sleeping beacons the first idea"
    },
    {
      "Time_Start": 1900.34,
      "Time_End": 1904.5,
      "Text": " could be to simply spoof the call stack which is actually not very easy if you want to do it"
    },
    {
      "Time_Start": 1904.5,
      "Time_End": 1910.6200000000001,
      "Text": " correctly but the more easy way would even be to simply don't use sleep to wait between your"
    },
    {
      "Time_Start": 1910.6200000000001,
      "Time_End": 1916.46,
      "Text": " callbacks you can also make use of rateable timers in order to have a bit of delay this then"
    },
    {
      "Time_Start": 1916.46,
      "Time_End": 1920.5000000000002,
      "Text": " sets the threat in a state called wait user requests which is way more common than delay"
    },
    {
      "Time_Start": 1920.5000000000002,
      "Time_End": 1926.94,
      "Text": " execution cool so call stacks definitely leave significant IOCs and this does not only apply"
    },
    {
      "Time_Start": 1926.94,
      "Time_End": 1932.0600000000002,
      "Text": " to empty delay execution but it also applies to other system calls memory scanners can actually"
    },
    {
      "Time_Start": 1932.0600000000002,
      "Time_End": 1937.98,
      "Text": " fully be bypassed using gargoyle or gargoyle like techniques and C2 coders should"
    },
    {
      "Time_Start": 1937.98,
      "Time_End": 1944.18,
      "Text": " definitely avoid using sleep internally for my C2 I use a modified version of deep sleep"
    },
    {
      "Time_Start": 1944.18,
      "Time_End": 1951.1,
      "Text": " which is using rateable timers cool this is almost the end of my presentation I have some"
    },
    {
      "Time_Start": 1951.1,
      "Time_End": 1957.58,
      "Text": " tools to release we were earlier we were talking about keyless polymorphism I created a tool to"
    },
    {
      "Time_Start": 1957.58,
      "Time_End": 1965.38,
      "Text": " automate the step which I call spider pick and it actually does the obfuscation on assembly"
    },
    {
      "Time_Start": 1965.38,
      "Time_End": 1973.42,
      "Text": " level so what you do is you first compile it using GCC or whatever to make the compiler output"
    },
    {
      "Time_Start": 1973.42,
      "Time_End": 1979.5800000000002,
      "Text": " assembly then you make that spider pick do its job it's doing the obfuscation and then you compile"
    },
    {
      "Time_Start": 1979.5800000000002,
      "Time_End": 1985.7,
      "Text": " it just as normal and in order to show how greatly this actually works are we also releasing a socks"
    },
    {
      "Time_Start": 1985.7,
      "Time_End": 1990.46,
      "Text": " proxy which is implemented as position independent code the client makes use of web sockets and is"
    },
    {
      "Time_Start": 1990.46,
      "Time_End": 1995.54,
      "Text": " implemented as pick and the spider pick is integrated into make file so it looks differently"
    },
    {
      "Time_Start": 1995.54,
      "Time_End": 2002.38,
      "Text": " every single time you compile the the client version the back end is written by my colleague"
    },
    {
      "Time_Start": 2002.38,
      "Time_End": 2010.02,
      "Text": " and good friend Christian and yeah you can find it on our github so if every time you compile"
    },
    {
      "Time_Start": 2010.02,
      "Time_End": 2015.7,
      "Text": " lessons look you see that the fuzzy hash is completely different yet they are all the same"
    },
    {
      "Time_Start": 2015.7,
      "Time_End": 2020.82,
      "Text": " program you can find it here on our github I think my boss clicked on release right now"
    },
    {
      "Time_Start": 2020.82,
      "Time_End": 2025.54,
      "Text": " and you simply type make to build it okay"
    }
  ]
}