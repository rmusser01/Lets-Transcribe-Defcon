{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 13.280000000000001,
      "Text": "This text was transcribed using whisper model: large-v2\n\n So this talk will be about, titled Demystifying Threats Called Stack Spoofing, we'll talk"
    },
    {
      "Time_Start": 13.280000000000001,
      "Time_End": 20.28,
      "Text": " about the technique known as stack spoofing, which is an evasion technique."
    },
    {
      "Time_Start": 20.28,
      "Time_End": 25.080000000000002,
      "Text": " Before starting, a few words about me, I'm Alessandro, this fancy guy is an AI-generated"
    },
    {
      "Time_Start": 25.080000000000002,
      "Time_End": 27.28,
      "Text": " avatar of course."
    },
    {
      "Time_Start": 27.28,
      "Time_End": 32.56,
      "Text": " I'm principal security consultant in BSI, where I serve as a Red Teamer, malware developer"
    },
    {
      "Time_Start": 32.56,
      "Time_End": 35.28,
      "Text": " and source code reviewer."
    },
    {
      "Time_Start": 35.28,
      "Time_End": 39.96,
      "Text": " Because work is never enough, I also work in the Porchetta industry with Marcello Salvati,"
    },
    {
      "Time_Start": 39.96,
      "Time_End": 48.92,
      "Text": " where I maintain some open source tools, and I'm a bug bounty hunter for SYNAC Red Team."
    },
    {
      "Time_Start": 48.92,
      "Time_End": 54.92,
      "Text": " I go as class virus, if you want to drop a message after this talk, feel free to do that."
    },
    {
      "Time_Start": 54.92,
      "Time_End": 61.6,
      "Text": " So today, what we will talk about, I will give you an introduction about stack spoofing,"
    },
    {
      "Time_Start": 61.6,
      "Time_End": 65.44,
      "Text": " what it is, why we want to use it."
    },
    {
      "Time_Start": 65.44,
      "Time_End": 72.56,
      "Text": " And then to explain this technique a bit more, I will give you an overview about the relevant"
    },
    {
      "Time_Start": 72.56,
      "Time_End": 79.08,
      "Text": " Windows internals and the Windows ABI, especially talking about the calling convention, the"
    },
    {
      "Time_Start": 79.08,
      "Time_End": 82.2,
      "Text": " stack management."
    },
    {
      "Time_Start": 82.2,
      "Time_End": 88.08,
      "Text": " And then we will see some stack spoofing approaches that have been released in the past, and after"
    },
    {
      "Time_Start": 88.08,
      "Time_End": 93.72,
      "Text": " that I will give you an overview of the technique that we refer to as stack moonwalking, which"
    },
    {
      "Time_Start": 93.72,
      "Time_End": 100.04,
      "Text": " is kind of a new technique, we developed the POC not long ago."
    },
    {
      "Time_Start": 100.04,
      "Time_End": 105.80000000000001,
      "Text": " And after that, I will also talk about, I will give you some defensive consideration,"
    },
    {
      "Time_Start": 105.80000000000001,
      "Time_End": 111.4,
      "Text": " some direction for future research, and I will discuss the impact of hardware-enforced"
    },
    {
      "Time_Start": 111.4,
      "Time_End": 116.96000000000001,
      "Text": " stack protection on all these stack spoofing techniques."
    },
    {
      "Time_Start": 116.96000000000001,
      "Time_End": 117.96000000000001,
      "Text": " So let's start."
    },
    {
      "Time_Start": 117.96000000000001,
      "Time_End": 119.64,
      "Text": " I'll start with two questions."
    },
    {
      "Time_Start": 119.64,
      "Time_End": 122.32000000000001,
      "Text": " The first one is, why a thread called stack spoofing?"
    },
    {
      "Time_Start": 122.32000000000001,
      "Time_End": 123.52000000000001,
      "Text": " Why not just stack spoofing?"
    },
    {
      "Time_Start": 123.52000000000001,
      "Time_End": 126.56,
      "Text": " Of course, the terms are interchangeable."
    },
    {
      "Time_Start": 126.56,
      "Time_End": 130.88,
      "Text": " And the reason is that the thread is the main unit in the Windows operating system that"
    },
    {
      "Time_Start": 130.88,
      "Time_End": 137.08,
      "Text": " executes code, is the thread, every thread inside, like the process access as a container."
    },
    {
      "Time_Start": 137.08,
      "Time_End": 144.28,
      "Text": " And we have a lot of threads that all maintains their own respective stack."
    },
    {
      "Time_Start": 144.28,
      "Time_End": 155.04000000000002,
      "Text": " Cold stack, of course, is something like this, is like a sequence, like a sequential memory"
    },
    {
      "Time_Start": 155.04000000000002,
      "Time_End": 156.32000000000002,
      "Text": " space."
    },
    {
      "Time_Start": 156.32000000000002,
      "Time_End": 163.14000000000001,
      "Text": " And whenever you call a function in a programming language, what happens is that the function"
    },
    {
      "Time_Start": 163.14000000000001,
      "Time_End": 169.46,
      "Text": " allocates some space on the stack to handle parameters, the locals, save the context from"
    },
    {
      "Time_Start": 169.46,
      "Time_End": 176.02,
      "Text": " the previous function, something that we refer to as, like, nonvolatile registers."
    },
    {
      "Time_Start": 176.02,
      "Time_End": 180.34,
      "Text": " And by calling nested functions, of course, because when you call an API, of course, this"
    },
    {
      "Time_Start": 180.34,
      "Time_End": 185.98000000000002,
      "Text": " recursively calls another function that calls another function, you create a cold stack."
    },
    {
      "Time_Start": 185.98000000000002,
      "Time_End": 191.06,
      "Text": " And spoofing, because, of course, we want to somehow tamper this cold stack in order"
    },
    {
      "Time_Start": 191.06,
      "Time_End": 195.22,
      "Text": " to avoid some sort of detection mechanism."
    },
    {
      "Time_Start": 195.22,
      "Time_End": 197.9,
      "Text": " And the motivation is always detection, yes."
    },
    {
      "Time_Start": 197.9,
      "Time_End": 204.14000000000001,
      "Text": " So if you use something like this, it's a process injection technique."
    },
    {
      "Time_Start": 204.14000000000001,
      "Time_End": 206.58,
      "Text": " And you can see the reference here."
    },
    {
      "Time_Start": 206.58,
      "Time_End": 207.58,
      "Text": " Very easy to understand."
    },
    {
      "Time_Start": 207.58,
      "Time_End": 211.02,
      "Text": " It can be process injection or self injection, it doesn't matter."
    },
    {
      "Time_Start": 211.02,
      "Time_End": 215.3,
      "Text": " If you locate something on the heap and you try to execute something from there, you will"
    },
    {
      "Time_Start": 215.3,
      "Time_End": 221.42000000000002,
      "Text": " see that your thread stack, cold stack, will show something like this."
    },
    {
      "Time_Start": 221.42000000000002,
      "Time_End": 222.42000000000002,
      "Text": " Okay."
    },
    {
      "Time_Start": 222.42000000000002,
      "Time_End": 223.42000000000002,
      "Text": " Something like this."
    },
    {
      "Time_Start": 223.42000000000002,
      "Time_End": 225.22,
      "Text": " So some garbage in the cold stack."
    },
    {
      "Time_Start": 225.22,
      "Time_End": 229.14000000000001,
      "Text": " And the reason is because there is no exception information associated for something that"
    },
    {
      "Time_Start": 229.14000000000001,
      "Time_End": 231.62,
      "Text": " you're looking at dynamically in memory."
    },
    {
      "Time_Start": 231.62,
      "Time_End": 235.14000000000001,
      "Text": " We will talk about that more in the next slides."
    },
    {
      "Time_Start": 235.14000000000001,
      "Time_End": 238.44,
      "Text": " And so you have a message box, like, coming from nowhere."
    },
    {
      "Time_Start": 238.44,
      "Time_End": 243.5,
      "Text": " And of course, this means, like, this cold stack is invalid because it doesn't unwind"
    },
    {
      "Time_Start": 243.5,
      "Time_End": 249.54,
      "Text": " to the bottom, as we say, because, like, a valid cold stack should look like this."
    },
    {
      "Time_Start": 249.54,
      "Time_End": 257.06,
      "Text": " Where you can actually locate the start of the thread by locating RTL user thread stack,"
    },
    {
      "Time_Start": 257.06,
      "Time_End": 262.14,
      "Text": " which is usually the first frame of any cold stack, because it's the way you actually create"
    },
    {
      "Time_Start": 262.14,
      "Time_End": 266.94,
      "Text": " a thread in the Windows operating system in user land."
    },
    {
      "Time_Start": 266.94,
      "Time_End": 272.8,
      "Text": " And so we have this in memory execution kind of detection, where you locate some garbage"
    },
    {
      "Time_Start": 272.92,
      "Time_End": 277.2,
      "Text": " in the code, because the cold stack doesn't unwind correctly."
    },
    {
      "Time_Start": 277.2,
      "Time_End": 281.96000000000004,
      "Text": " But you can also have, like, broadly speaking, you also have caller detection."
    },
    {
      "Time_Start": 281.96000000000004,
      "Time_End": 290.12,
      "Text": " Sometimes you can enforce some rules to avoid a specific call to, like, that is originating"
    },
    {
      "Time_Start": 290.12,
      "Time_End": 293.48,
      "Text": " from a specific caller, and you can block that."
    },
    {
      "Time_Start": 293.48,
      "Time_End": 296.6,
      "Text": " Or you have direct and indirect syscall detection."
    },
    {
      "Time_Start": 296.6,
      "Time_End": 301.2,
      "Text": " Because analyzing the cold stack, you can understand the path that the specific call"
    },
    {
      "Time_Start": 301.2,
      "Time_End": 303.59999999999997,
      "Text": " has taken in the thread."
    },
    {
      "Time_Start": 303.59999999999997,
      "Time_End": 309.4,
      "Text": " So you can understand if it's originating by a module instead of passing through kernel"
    },
    {
      "Time_Start": 309.4,
      "Time_End": 312.4,
      "Text": " base."
    },
    {
      "Time_Start": 312.4,
      "Time_End": 319.76,
      "Text": " But also important to understand is where this detection when this detection can happen."
    },
    {
      "Time_Start": 319.76,
      "Time_End": 323.26,
      "Text": " And there are mainly three techniques to detect this stack spoofing."
    },
    {
      "Time_Start": 323.26,
      "Time_End": 324.36,
      "Text": " One is periodic."
    },
    {
      "Time_Start": 324.36,
      "Time_End": 333.44,
      "Text": " You select a frame, a time period T, and every T seconds, you just system wide scan"
    },
    {
      "Time_Start": 333.44,
      "Time_End": 336.08000000000004,
      "Text": " all the processes."
    },
    {
      "Time_Start": 336.08000000000004,
      "Time_End": 340.52000000000004,
      "Text": " You stop every thread in the process."
    },
    {
      "Time_Start": 340.52000000000004,
      "Time_End": 341.52000000000004,
      "Text": " Sorry for that."
    },
    {
      "Time_Start": 341.52000000000004,
      "Time_End": 346.92,
      "Text": " Probably need some water."
    },
    {
      "Time_Start": 346.92,
      "Time_End": 350.3,
      "Text": " And you analyze the cold stack."
    },
    {
      "Time_Start": 350.3,
      "Time_End": 358.18,
      "Text": " So this is not as impacting on performance as you may expect."
    },
    {
      "Time_Start": 358.18,
      "Time_End": 363.54,
      "Text": " But if you're worried about impacting the system performances, you can just decide to"
    },
    {
      "Time_Start": 363.54,
      "Time_End": 366.02000000000004,
      "Text": " do a conditional periodic scan."
    },
    {
      "Time_Start": 366.02000000000004,
      "Time_End": 370.62,
      "Text": " So the EDR just scan threads that are in a specific state."
    },
    {
      "Time_Start": 370.62,
      "Time_End": 376.26,
      "Text": " So if you ever heard about the tool named ANT for sleeping beacons, this is a technique"
    },
    {
      "Time_Start": 376.26,
      "Time_End": 381.82,
      "Text": " that is used in that tool, for example, that just loops through all the threads."
    },
    {
      "Time_Start": 381.82,
      "Time_End": 385.65999999999997,
      "Text": " It detects the threads that are in a wait state, user requested wait state."
    },
    {
      "Time_Start": 385.65999999999997,
      "Time_End": 392.18,
      "Text": " That means that like the state was introduced by a call to wait for a single object or similar."
    },
    {
      "Time_Start": 392.18,
      "Time_End": 394.53999999999996,
      "Text": " And or just delayed execution."
    },
    {
      "Time_Start": 394.53999999999996,
      "Time_End": 396.44,
      "Text": " So you have a sleep."
    },
    {
      "Time_Start": 396.44,
      "Time_End": 403.98,
      "Text": " And it will just scan that kind of threads to analyze for, to want for sleeping beacons."
    },
    {
      "Time_Start": 403.98,
      "Time_End": 407.98,
      "Text": " And the same can apply to the cold stack analysis."
    },
    {
      "Time_Start": 407.98,
      "Time_End": 411.34000000000003,
      "Text": " It's not working anymore."
    },
    {
      "Time_Start": 411.34000000000003,
      "Time_End": 415.22,
      "Text": " It's incredible."
    },
    {
      "Time_Start": 415.22,
      "Time_End": 418.18,
      "Text": " Just finish the battery probably."
    },
    {
      "Time_Start": 418.18,
      "Time_End": 421.62,
      "Text": " So and then you have the hooking."
    },
    {
      "Time_Start": 421.62,
      "Time_End": 427.3,
      "Text": " Of course, you can also do this inspection in using another approach, which is via hooking."
    },
    {
      "Time_Start": 427.3,
      "Time_End": 430.3,
      "Text": " When I say hooking, it can be user level hooking."
    },
    {
      "Time_Start": 430.3,
      "Time_End": 437.54,
      "Text": " So when a call is, when a specific call is hooked and the hook is hit, you can trace"
    },
    {
      "Time_Start": 437.54,
      "Time_End": 442.82,
      "Text": " back the cold stack, which is something you can do, for example, with Frida, if you're"
    },
    {
      "Time_Start": 442.82,
      "Time_End": 447.14,
      "Text": " interested in doing something like that."
    },
    {
      "Time_Start": 447.14,
      "Time_End": 451.1,
      "Text": " Or otherwise, you can do kernel based hooking, which is something you can do with Dtrace,"
    },
    {
      "Time_Start": 451.1,
      "Time_End": 457.06,
      "Text": " for example, where a system call, a specific system call is hit, you can trace back the"
    },
    {
      "Time_Start": 457.06,
      "Time_End": 462.06,
      "Text": " execution and analyze where it's coming from."
    },
    {
      "Time_Start": 462.06,
      "Time_End": 467.5,
      "Text": " And turns out, sorry, just to stay here for a second, and it turns out that in the, in"
    },
    {
      "Time_Start": 467.5,
      "Time_End": 472.54,
      "Text": " like in the field, we developed a lot of techniques to defend against conditional scanning and"
    },
    {
      "Time_Start": 472.54,
      "Time_End": 473.86,
      "Text": " periodic scanning."
    },
    {
      "Time_Start": 473.86,
      "Time_End": 479.78,
      "Text": " But we don't have a lot of techniques to defend against, for example, tracing done at kernel"
    },
    {
      "Time_Start": 479.78,
      "Time_End": 482.9,
      "Text": " level or by hooking."
    },
    {
      "Time_Start": 482.90000000000003,
      "Time_End": 489.50000000000006,
      "Text": " So before going further, let's just define a bit of prerequisites, because this is a"
    },
    {
      "Time_Start": 489.50000000000006,
      "Time_End": 491.46000000000004,
      "Text": " user, like a beginner friendly talk."
    },
    {
      "Time_Start": 491.46000000000004,
      "Time_End": 496.78000000000003,
      "Text": " So we will talk about the calling convention a bit, which we need for understanding things"
    },
    {
      "Time_Start": 496.78000000000003,
      "Time_End": 497.78000000000003,
      "Text": " further."
    },
    {
      "Time_Start": 497.78000000000003,
      "Time_End": 504.90000000000003,
      "Text": " So of course the Windows 64 calling convention, if you're used to 32 bit Windows, it's a bit"
    },
    {
      "Time_Start": 504.90000000000003,
      "Time_End": 506.14000000000004,
      "Text": " different."
    },
    {
      "Time_Start": 506.14000000000004,
      "Time_End": 510.70000000000005,
      "Text": " So in Windows, of course, you had this, like the calling convention defined that you could"
    },
    {
      "Time_Start": 510.7,
      "Time_End": 515.14,
      "Text": " push all the register, all the parameters for a function call directly on the stack"
    },
    {
      "Time_Start": 515.14,
      "Time_End": 518.5,
      "Text": " and then push the return address and call the function."
    },
    {
      "Time_Start": 518.5,
      "Time_End": 520.3,
      "Text": " In 64 bits, it's a bit different."
    },
    {
      "Time_Start": 520.3,
      "Time_End": 523.98,
      "Text": " You use the fast call calling convention."
    },
    {
      "Time_Start": 523.98,
      "Time_End": 530.38,
      "Text": " And this fast call defined that the first four parameters get passed to R8, R9, sorry,"
    },
    {
      "Time_Start": 530.38,
      "Time_End": 536.7,
      "Text": " CX, RDX, R8 and R9, which are called the fast call registers."
    },
    {
      "Time_Start": 536.7,
      "Time_End": 543.5400000000001,
      "Text": " And then there are other, like the other parameters are all pushed on the stack, but"
    },
    {
      "Time_Start": 543.5400000000001,
      "Time_End": 549.5,
      "Text": " after something that we call homing space, which is the space that would require to handle"
    },
    {
      "Time_Start": 549.5,
      "Time_End": 556.86,
      "Text": " this first four register in case they need to be pushed on the stack."
    },
    {
      "Time_Start": 556.86,
      "Time_End": 563.9000000000001,
      "Text": " So the main difference, though, between 64 and 32 is the usage of EBP, potentially, and"
    },
    {
      "Time_Start": 563.9000000000001,
      "Time_End": 566.6600000000001,
      "Text": " this is what we care the most."
    },
    {
      "Time_Start": 566.66,
      "Time_End": 572.9399999999999,
      "Text": " In 32 bit, you have the EBP acting as a base pointer, of course, extended base pointer,"
    },
    {
      "Time_Start": 572.9399999999999,
      "Time_End": 578.4599999999999,
      "Text": " you would expect that it's a base pointer, but in 64 bit, this is no longer the case."
    },
    {
      "Time_Start": 578.4599999999999,
      "Time_End": 586.1,
      "Text": " So if you remember in 32 bits, every prologue was actually starting by push RBP, move EBP,"
    },
    {
      "Time_Start": 586.1,
      "Time_End": 591.6999999999999,
      "Text": " ESP, and that was literally moving and allocating and starting the allocation of a frame by"
    },
    {
      "Time_Start": 591.7,
      "Time_End": 603.1,
      "Text": " just resetting the base pointer and extending ESP then to the value that needs to be allocated"
    },
    {
      "Time_Start": 603.1,
      "Time_End": 604.86,
      "Text": " on the stack."
    },
    {
      "Time_Start": 604.86,
      "Time_End": 609.6600000000001,
      "Text": " But this is no longer the case, because in 64 bits, you have RSP acting as both the base"
    },
    {
      "Time_Start": 609.6600000000001,
      "Time_End": 613.58,
      "Text": " pointer and the stack pointer."
    },
    {
      "Time_Start": 613.58,
      "Time_End": 619.6600000000001,
      "Text": " And so, sorry, this is just for defining the against the parameters, and so what happens"
    },
    {
      "Time_Start": 619.74,
      "Time_End": 626.26,
      "Text": " when you call a function, you have just like this call sequence, like you call a function"
    },
    {
      "Time_Start": 626.26,
      "Time_End": 632.74,
      "Text": " from a function A, call a function B, and you can see that the function A will take"
    },
    {
      "Time_Start": 632.74,
      "Time_End": 638.14,
      "Text": " care of allocating the stack parameters, leave the own space, push its return address, and"
    },
    {
      "Time_Start": 638.14,
      "Time_End": 644.5799999999999,
      "Text": " then pass execution to the frame of function B where you have the space for allocating"
    },
    {
      "Time_Start": 644.5799999999999,
      "Time_End": 648.6999999999999,
      "Text": " nonvolatile registers and additional locals."
    },
    {
      "Time_Start": 648.74,
      "Time_End": 659.5400000000001,
      "Text": " So important for this is that all the instructions needed for function B to push nonvolatile"
    },
    {
      "Time_Start": 659.5400000000001,
      "Time_End": 664.58,
      "Text": " registers and allocate space for locals is called prologue."
    },
    {
      "Time_Start": 664.58,
      "Time_End": 673.26,
      "Text": " Practically is the part of a function that is responsible for allocating everything that"
    },
    {
      "Time_Start": 673.26,
      "Time_End": 675.9000000000001,
      "Text": " is needed for the function execution."
    },
    {
      "Time_Start": 675.9,
      "Time_End": 682.78,
      "Text": " Under the prologue, RSP is static for the full execution of B, and this is needed exactly"
    },
    {
      "Time_Start": 682.78,
      "Time_End": 690.1,
      "Text": " because RSP is base pointer and stack pointer, and you can't just do modification within"
    },
    {
      "Time_Start": 690.1,
      "Time_End": 695.14,
      "Text": " the body of a function, otherwise you would lose all references, because as you can see"
    },
    {
      "Time_Start": 695.14,
      "Time_End": 703.5,
      "Text": " from this image, everything is actually referred within a function as a reference to RSP."
    },
    {
      "Time_Start": 703.5,
      "Time_End": 709.78,
      "Text": " So you can't just modify it arbitrarily."
    },
    {
      "Time_Start": 709.78,
      "Time_End": 716.74,
      "Text": " And because RSP is used both as a base pointer and a stack pointer, you can also use the"
    },
    {
      "Time_Start": 716.74,
      "Time_End": 723.34,
      "Text": " base pointer to trace back execution and unwind the stack, so to locate all the code stack."
    },
    {
      "Time_Start": 723.34,
      "Time_End": 728.38,
      "Text": " So in 32-bits, what you would do is just, because there was this function paradigm,"
    },
    {
      "Time_Start": 728.38,
      "Time_End": 738.9,
      "Text": " you push RBP, you move ESP into EBP, et cetera, you could do the same thing on the contrary."
    },
    {
      "Time_Start": 738.9,
      "Time_End": 745.66,
      "Text": " So at a certain point, EBP was always pushed on the stack, and ESP moved, and EBP moved"
    },
    {
      "Time_Start": 745.66,
      "Time_End": 747.86,
      "Text": " to ESP, and ESP moved back."
    },
    {
      "Time_Start": 747.86,
      "Time_End": 755.46,
      "Text": " So if you wanted to trace the old code stack, you just needed to literally locate the address"
    },
    {
      "Time_Start": 755.5,
      "Time_End": 762.02,
      "Text": " where EBP was pushed, get the EBP and trace back again, and do this process until you"
    },
    {
      "Time_Start": 762.02,
      "Time_End": 766.0600000000001,
      "Text": " reach the bottom of the stack."
    },
    {
      "Time_Start": 766.0600000000001,
      "Time_End": 770.6600000000001,
      "Text": " So you could just follow the, what we call the chain of EBP pointers."
    },
    {
      "Time_Start": 770.6600000000001,
      "Time_End": 778.94,
      "Text": " But in this case, we don't have this information anymore, because RSP is not, like EBP is not"
    },
    {
      "Time_Start": 778.94,
      "Time_End": 783.98,
      "Text": " used anymore, like RBP is just a global general purpose register."
    },
    {
      "Time_Start": 783.98,
      "Time_End": 793.66,
      "Text": " So to keep track of this code stack, Windows introduced a new unwinding algorithm, which"
    },
    {
      "Time_Start": 793.66,
      "Time_End": 799.66,
      "Text": " is an algorithm that is actually responsible for understanding and detecting, based on"
    },
    {
      "Time_Start": 799.66,
      "Time_End": 807.24,
      "Text": " the current location of the program and the current frame, to actually virtually reconstruct"
    },
    {
      "Time_Start": 807.24,
      "Time_End": 809.34,
      "Text": " the code stack."
    },
    {
      "Time_Start": 809.4200000000001,
      "Time_End": 816.82,
      "Text": " And this works because whenever you create a program, the compiler automatically creates"
    },
    {
      "Time_Start": 816.82,
      "Time_End": 824.98,
      "Text": " a section, actually two, like a section that is called pdata, with d and x data, but let's"
    },
    {
      "Time_Start": 824.98,
      "Time_End": 831.98,
      "Text": " just say pdata to simplify, that contains all the instructions that are relevant to"
    },
    {
      "Time_Start": 831.98,
      "Time_End": 836.3000000000001,
      "Text": " a specific function prolog."
    },
    {
      "Time_Start": 836.3000000000001,
      "Time_End": 837.3000000000001,
      "Text": " Why the prolog?"
    },
    {
      "Time_Start": 837.3000000000001,
      "Time_End": 843.0600000000001,
      "Text": " Because as we said, RSP is static through the body, so all the information related to"
    },
    {
      "Time_Start": 843.0600000000001,
      "Time_End": 851.0600000000001,
      "Text": " the stack frame sites are defined, are a direct function of the operations performed in a"
    },
    {
      "Time_Start": 851.0600000000001,
      "Time_End": 853.3800000000001,
      "Text": " prolog of a function."
    },
    {
      "Time_Start": 853.3800000000001,
      "Time_End": 856.0600000000001,
      "Text": " So if this is not clear, I hope it will be now."
    },
    {
      "Time_Start": 856.0600000000001,
      "Time_End": 862.0600000000001,
      "Text": " So practically, the pdata section contains an exception, a directory called exception"
    },
    {
      "Time_Start": 862.0600000000001,
      "Time_End": 869.46,
      "Text": " directory, and this exception directory maintains a table, a runtime function table with a list"
    },
    {
      "Time_Start": 869.46,
      "Time_End": 871.1800000000001,
      "Text": " of all these runtime functions."
    },
    {
      "Time_Start": 871.1800000000001,
      "Time_End": 876.62,
      "Text": " You can imagine that every runtime function is a function in your PE."
    },
    {
      "Time_Start": 876.62,
      "Time_End": 884.3800000000001,
      "Text": " It can be an export, or it may be just a function, an internal function used by the PE, and this"
    },
    {
      "Time_Start": 884.38,
      "Time_End": 892.46,
      "Text": " is, there is an exception actually, because Windows also defines leaf and non-leaf functions."
    },
    {
      "Time_Start": 892.46,
      "Time_End": 898.64,
      "Text": " Of course you may, because this is an exception kind of directory, this contains information"
    },
    {
      "Time_Start": 898.64,
      "Time_End": 906.5,
      "Text": " about the exceptions of any function, and about all the functions that are located based"
    },
    {
      "Time_Start": 906.5,
      "Time_End": 907.78,
      "Text": " on the stack."
    },
    {
      "Time_Start": 907.78,
      "Time_End": 913.82,
      "Text": " So you can infer, like the question is, does every function need a stack frame?"
    },
    {
      "Time_Start": 913.82,
      "Time_End": 914.82,
      "Text": " Well, no."
    },
    {
      "Time_Start": 914.82,
      "Time_End": 918.82,
      "Text": " Windows also supports leaf, what is called a leaf function."
    },
    {
      "Time_Start": 918.82,
      "Time_End": 922.34,
      "Text": " So how can I understand if a function is a leaf or not?"
    },
    {
      "Time_Start": 922.34,
      "Time_End": 927.0200000000001,
      "Text": " So if there is a function entering the runtime function table is a non-leaf function, if"
    },
    {
      "Time_Start": 927.0200000000001,
      "Time_End": 933.9000000000001,
      "Text": " there is no function entry for that specific function, well, then it's a non-leaf function."
    },
    {
      "Time_Start": 933.9000000000001,
      "Time_End": 938.34,
      "Text": " And how, like, what is contained in this runtime function structure?"
    },
    {
      "Time_Start": 938.34,
      "Time_End": 941.3800000000001,
      "Text": " So the runtime function structure is like that."
    },
    {
      "Time_Start": 941.38,
      "Time_End": 945.46,
      "Text": " So you have, is a structure containing the beginning address of a function, the end address"
    },
    {
      "Time_Start": 945.46,
      "Time_End": 951.26,
      "Text": " of a function, and another structure, which is an unwind data structure."
    },
    {
      "Time_Start": 951.26,
      "Time_End": 957.26,
      "Text": " And this unwind data structure contains a lot of very good, very interesting information,"
    },
    {
      "Time_Start": 957.26,
      "Time_End": 964.34,
      "Text": " useful for the OS, because of course they are needed for exception handling and rolling"
    },
    {
      "Time_Start": 964.34,
      "Time_End": 968.66,
      "Text": " back the stack frames that are needed to be rolled back."
    },
    {
      "Time_Start": 968.66,
      "Time_End": 974.1,
      "Text": " And what we care about this is that in this, in this structure, we have the unwind data,"
    },
    {
      "Time_Start": 974.1,
      "Time_End": 976.06,
      "Text": " which is an unwind infrastructure."
    },
    {
      "Time_Start": 976.06,
      "Time_End": 980.3199999999999,
      "Text": " And in this unwind infrastructure, we have the unwind code array."
    },
    {
      "Time_Start": 980.3199999999999,
      "Time_End": 986.2199999999999,
      "Text": " And the unwind code array is the list of instructions that are performed within the prologue of"
    },
    {
      "Time_Start": 986.2199999999999,
      "Time_End": 987.2199999999999,
      "Text": " a function."
    },
    {
      "Time_Start": 987.2199999999999,
      "Time_End": 995.9,
      "Text": " Why this is important, because if we loop through all these unwind code structures,"
    },
    {
      "Time_Start": 995.9,
      "Time_End": 1002.34,
      "Text": " we can locate, based on the operation info and the operation code, we can understand"
    },
    {
      "Time_Start": 1002.34,
      "Time_End": 1007.6999999999999,
      "Text": " all the operations that add an impact on the stack."
    },
    {
      "Time_Start": 1007.6999999999999,
      "Time_End": 1011.38,
      "Text": " And the operation that add an impact on the stack are, for example, pushNumVol, which"
    },
    {
      "Time_Start": 1011.38,
      "Time_End": 1015.8199999999999,
      "Text": " of course extend the stack size, the stack frame size of eight."
    },
    {
      "Time_Start": 1015.8199999999999,
      "Time_End": 1022.1,
      "Text": " And then we have allocSmall and allocLarge that can extend of an arbitrary number based"
    },
    {
      "Time_Start": 1022.1,
      "Time_End": 1027.74,
      "Text": " on the allocation that was needed for the function."
    },
    {
      "Time_Start": 1027.74,
      "Time_End": 1033.06,
      "Text": " And by looping through all of this, we can dynamically detect stack frame size."
    },
    {
      "Time_Start": 1033.06,
      "Time_End": 1037.42,
      "Text": " Once we detect the stack frame size, we can locate the return address, get the return"
    },
    {
      "Time_Start": 1037.42,
      "Time_End": 1043.2,
      "Text": " address and do this again for the previous stack frame."
    },
    {
      "Time_Start": 1043.2,
      "Time_End": 1047.74,
      "Text": " And by doing this till the bottom, we can just detect all the code stack."
    },
    {
      "Time_Start": 1047.74,
      "Time_End": 1049.1,
      "Text": " This is the unwind library."
    },
    {
      "Time_Start": 1049.1,
      "Time_End": 1051.66,
      "Text": " A bit complex."
    },
    {
      "Time_Start": 1051.66,
      "Time_End": 1058.22,
      "Text": " If you ask me, it was way easier to do, to analyze the chain of the B pointers, but this"
    },
    {
      "Time_Start": 1058.22,
      "Time_End": 1061.94,
      "Text": " is for, this is what they came up with."
    },
    {
      "Time_Start": 1061.94,
      "Time_End": 1062.94,
      "Text": " Okay."
    },
    {
      "Time_Start": 1062.94,
      "Time_End": 1067.9,
      "Text": " So now let's just briefly talk about, now that we know about this, we are expert of"
    },
    {
      "Time_Start": 1067.9,
      "Time_End": 1077.46,
      "Text": " the unwinding algorithm, let's just talk a bit about what are the approaches so far that"
    },
    {
      "Time_Start": 1077.46,
      "Time_End": 1082.04,
      "Text": " were released to track stack spoofing."
    },
    {
      "Time_Start": 1082.04,
      "Time_End": 1090.02,
      "Text": " So the first one probably, and the most famous, I would say is a track stack spoofer by MGT,"
    },
    {
      "Time_Start": 1090.02,
      "Time_End": 1091.46,
      "Text": " Marius."
    },
    {
      "Time_Start": 1091.46,
      "Time_End": 1098.46,
      "Text": " And this technique is actually, it was developed to defend against on sleep, like conditional"
    },
    {
      "Time_Start": 1098.46,
      "Time_End": 1101.7,
      "Text": " scans, periodical scans."
    },
    {
      "Time_Start": 1101.7,
      "Time_End": 1109.14,
      "Text": " And what this does, I categorize this technique as stack truncation."
    },
    {
      "Time_Start": 1109.14,
      "Time_End": 1114.5800000000002,
      "Text": " And what it does is, imagine you have your implant in memory and it's executing from"
    },
    {
      "Time_Start": 1114.5800000000002,
      "Time_End": 1120.98,
      "Text": " an unbacked memory region, so you have garbage in your code stack."
    },
    {
      "Time_Start": 1120.98,
      "Time_End": 1126.3400000000001,
      "Text": " What this does is that I need to execute a frame zero function, a target function, a"
    },
    {
      "Time_Start": 1126.3400000000001,
      "Time_End": 1128.54,
      "Text": " sleep, for example."
    },
    {
      "Time_Start": 1128.54,
      "Time_End": 1133.46,
      "Text": " And of course, all the frames are legitimate, like they are resolvable, but the caller address"
    },
    {
      "Time_Start": 1133.46,
      "Time_End": 1134.46,
      "Text": " is my problem."
    },
    {
      "Time_Start": 1134.46,
      "Time_End": 1141.42,
      "Text": " So how this is solved, well, track stack spoofer will use a trampoline in its main module,"
    },
    {
      "Time_Start": 1141.42,
      "Time_End": 1145.36,
      "Text": " but this is just because it's a POC, you can literally use any kind of trampoline you want"
    },
    {
      "Time_Start": 1145.36,
      "Time_End": 1150.26,
      "Text": " in memory, even in a DLL mapped in memory."
    },
    {
      "Time_Start": 1150.26,
      "Time_End": 1156.1,
      "Text": " And then it will zero out the return address from that call."
    },
    {
      "Time_Start": 1156.1000000000001,
      "Time_End": 1161.8600000000001,
      "Text": " By doing this, the stack is truncated because the zero, it corresponds to the bottom of"
    },
    {
      "Time_Start": 1161.8600000000001,
      "Time_End": 1162.8600000000001,
      "Text": " the stack."
    },
    {
      "Time_Start": 1162.8600000000001,
      "Time_End": 1167.42,
      "Text": " When the unwinding algorithm encounters a zero address as a return address, it will"
    },
    {
      "Time_Start": 1167.42,
      "Time_End": 1172.46,
      "Text": " just stop executing because it's the bottom of the stack."
    },
    {
      "Time_Start": 1172.46,
      "Time_End": 1177.42,
      "Text": " Of course, the main limitation about this technique is that it will leave the thread"
    },
    {
      "Time_Start": 1177.42,
      "Time_End": 1180.9800000000002,
      "Text": " stack known unwindable."
    },
    {
      "Time_Start": 1181.34,
      "Time_End": 1187.58,
      "Text": " This may be an IOC or not, depending on the specific systems, there might be programs"
    },
    {
      "Time_Start": 1187.58,
      "Time_End": 1194.66,
      "Text": " that exhibits the same trait, but it's not that common."
    },
    {
      "Time_Start": 1194.66,
      "Time_End": 1202.9,
      "Text": " But surely it looks better than, so the first one is without track stack spoofer and the"
    },
    {
      "Time_Start": 1202.9,
      "Time_End": 1205.7,
      "Text": " second one is with track stack spoofer enabled."
    },
    {
      "Time_Start": 1205.7,
      "Time_End": 1212.6200000000001,
      "Text": " Of course, the second one is better, although there is this final call that is directly"
    },
    {
      "Time_Start": 1212.6200000000001,
      "Time_End": 1218.54,
      "Text": " originating from the module, which is not ideal, but it's surely better than having"
    },
    {
      "Time_Start": 1218.54,
      "Time_End": 1222.54,
      "Text": " the garbage on the stack."
    },
    {
      "Time_Start": 1222.54,
      "Time_End": 1225.14,
      "Text": " The second one is called stack crafting."
    },
    {
      "Time_Start": 1225.14,
      "Time_End": 1233.6200000000001,
      "Text": " The main POC is called stack spoofer and stack crafting is a technique that will take a good,"
    },
    {
      "Time_Start": 1234.0600000000002,
      "Time_End": 1241.9,
      "Text": " this technique is meant to protect from hook based scanning, and the point of the technique"
    },
    {
      "Time_Start": 1241.9,
      "Time_End": 1246.5400000000002,
      "Text": " is that you have a target function that you want to execute, for example, opening an handle"
    },
    {
      "Time_Start": 1246.5400000000002,
      "Time_End": 1254.66,
      "Text": " to elseus, and what you do is I will record on my system whatever legitimate function"
    },
    {
      "Time_Start": 1254.66,
      "Time_End": 1260.74,
      "Text": " is calling that function from another module, I will record that stack and I will forcefully"
    },
    {
      "Time_Start": 1260.74,
      "Time_End": 1266.18,
      "Text": " create a thread with that stack, which is legitimate and it's all load by the system,"
    },
    {
      "Time_Start": 1266.18,
      "Time_End": 1270.98,
      "Text": " and then I will forcefully put the RIP, the instruction pointer, to the target function."
    },
    {
      "Time_Start": 1270.98,
      "Time_End": 1278.02,
      "Text": " So that would originate a thread which executes a completely crafted stack and a completely"
    },
    {
      "Time_Start": 1278.02,
      "Time_End": 1285.42,
      "Text": " crafted constructed whole stack and can evade some sort of detection, and the only thing"
    },
    {
      "Time_Start": 1285.5,
      "Time_End": 1293.02,
      "Text": " you need to care about is then get the execution back on return and kill the thread or just"
    },
    {
      "Time_Start": 1293.02,
      "Time_End": 1297.5800000000002,
      "Text": " restore execution somehow, right?"
    },
    {
      "Time_Start": 1297.5800000000002,
      "Time_End": 1302.26,
      "Text": " And the third one is stack cloning."
    },
    {
      "Time_Start": 1302.26,
      "Time_End": 1308.6200000000001,
      "Text": " Stack cloning always by William Burgess, like the previous POC, I didn't tell that."
    },
    {
      "Time_Start": 1308.6200000000001,
      "Time_End": 1314.38,
      "Text": " So called stack masker implements the stack cloning technique, which is a bit more complex"
    },
    {
      "Time_Start": 1314.38,
      "Time_End": 1320.7,
      "Text": " and it's designed to protect on sleep, so during periodical scans, and what it does"
    },
    {
      "Time_Start": 1320.7,
      "Time_End": 1327.3400000000001,
      "Text": " is that it will loop through all threads in the system searching for a function which"
    },
    {
      "Time_Start": 1327.3400000000001,
      "Time_End": 1331.5400000000002,
      "Text": " is looking for a thread which is in a user requested wait state."
    },
    {
      "Time_Start": 1331.5400000000002,
      "Time_End": 1338.5800000000002,
      "Text": " The reason is I need to put my thread on sleep because I have a beacon, I want to sleep most"
    },
    {
      "Time_Start": 1338.5800000000002,
      "Time_End": 1343.3400000000001,
      "Text": " of the time so I want it to sleep, and I search for a thread that is sleeping and it's using"
    },
    {
      "Time_Start": 1343.34,
      "Time_End": 1348.9399999999998,
      "Text": " the technique I want to use, so for example wait for single object, and by locating the"
    },
    {
      "Time_Start": 1348.9399999999998,
      "Time_End": 1354.8999999999999,
      "Text": " frame of this thread, I will just clone it, easy."
    },
    {
      "Time_Start": 1354.8999999999999,
      "Time_End": 1360.5,
      "Text": " And this is very effective as a masking technique, I would say."
    },
    {
      "Time_Start": 1360.5,
      "Time_End": 1364.1399999999999,
      "Text": " And then there is another approach which is good, which is stack hiding, and stack hiding"
    },
    {
      "Time_Start": 1364.14,
      "Time_End": 1373.42,
      "Text": " by Kudos Dabba, I'm sorry if I pronounced it horribly, but so the idea is to create,"
    },
    {
      "Time_Start": 1373.42,
      "Time_End": 1379.74,
      "Text": " to convert the thread to a fiber, and literally when I create the fiber, the fiber is acting"
    },
    {
      "Time_Start": 1379.74,
      "Time_End": 1385.6200000000001,
      "Text": " as an evil fiber, so it can execute from memory, it can do a lot of other stuff."
    },
    {
      "Time_Start": 1385.6200000000001,
      "Time_End": 1391.64,
      "Text": " But then I create a second fiber, which will act as my sleep fiber, and the idea is that"
    },
    {
      "Time_Start": 1391.64,
      "Time_End": 1400.16,
      "Text": " I can switch between one and the other every time I want, and when I need to protect my"
    },
    {
      "Time_Start": 1400.16,
      "Time_End": 1406.3600000000001,
      "Text": " beacon and I need to go to sleep, I switch to the sleep fiber, and when I need to execute"
    },
    {
      "Time_Start": 1406.3600000000001,
      "Time_End": 1409.3400000000001,
      "Text": " something I switch to the evil fiber."
    },
    {
      "Time_Start": 1409.3400000000001,
      "Time_End": 1416.3200000000002,
      "Text": " So this uses literally two stacks, because the fiber, you can execute just one fiber"
    },
    {
      "Time_Start": 1416.32,
      "Time_End": 1421.6,
      "Text": " at a time in a thread, and the reason because is when you execute the fiber, the stack of"
    },
    {
      "Time_Start": 1421.6,
      "Time_End": 1424.36,
      "Text": " the fiber becomes the stack of the thread."
    },
    {
      "Time_Start": 1424.36,
      "Time_End": 1429.96,
      "Text": " So the main limitation about this technique is that, as I said, it protects on sleep,"
    },
    {
      "Time_Start": 1429.96,
      "Time_End": 1435.12,
      "Text": " because if you are not sleeping and you are executing the evil thread, the stack will"
    },
    {
      "Time_Start": 1435.12,
      "Time_End": 1443.52,
      "Text": " clearly identify garbage, and you can't just use this for protecting on hook or on kernel"
    },
    {
      "Time_Start": 1443.52,
      "Time_End": 1445.96,
      "Text": " inspection."
    },
    {
      "Time_Start": 1445.96,
      "Time_End": 1453.0,
      "Text": " And so we decided to develop something that we could use to generally protect against"
    },
    {
      "Time_Start": 1453.0,
      "Time_End": 1455.68,
      "Text": " runtime inspection."
    },
    {
      "Time_Start": 1455.68,
      "Time_End": 1460.56,
      "Text": " And we developed this stack walking approach."
    },
    {
      "Time_Start": 1460.56,
      "Time_End": 1462.16,
      "Text": " And what is the main idea?"
    },
    {
      "Time_Start": 1462.16,
      "Time_End": 1469.56,
      "Text": " We want to trick the unwinding algorithm in thinking that our call stack is done in a"
    },
    {
      "Time_Start": 1469.56,
      "Time_End": 1477.1599999999999,
      "Text": " certain way, but then we use a desynchronization approach on return to just restore the original"
    },
    {
      "Time_Start": 1477.1599999999999,
      "Time_End": 1478.1599999999999,
      "Text": " stack."
    },
    {
      "Time_Start": 1478.1599999999999,
      "Time_End": 1479.1599999999999,
      "Text": " How we do that?"
    },
    {
      "Time_Start": 1479.1599999999999,
      "Time_End": 1484.6799999999998,
      "Text": " So we need three things, three pieces for making this recipe work."
    },
    {
      "Time_Start": 1484.6799999999998,
      "Time_End": 1490.44,
      "Text": " And so we have a target function that we want to spoof, and we need a setfpreg frame."
    },
    {
      "Time_Start": 1490.44,
      "Time_End": 1493.9199999999998,
      "Text": " Okay, so a bit of about setfpreg."
    },
    {
      "Time_Start": 1493.92,
      "Time_End": 1502.76,
      "Text": " So setfpreg is a function that you can define in assembly, that you can put in a mason file."
    },
    {
      "Time_Start": 1502.76,
      "Time_End": 1510.4,
      "Text": " And the setfpreg frame is a frame that, inside the prologue, contains a win code that is"
    },
    {
      "Time_Start": 1510.4,
      "Time_End": 1515.24,
      "Text": " a UWP operation, setfpreg."
    },
    {
      "Time_Start": 1515.24,
      "Time_End": 1522.0800000000002,
      "Text": " And what it does is that it will restore the original role of the base pointer."
    },
    {
      "Time_Start": 1522.08,
      "Time_End": 1524.84,
      "Text": " Why this is needed?"
    },
    {
      "Time_Start": 1524.84,
      "Time_End": 1529.36,
      "Text": " Because of course, as I said, RSP can't be changed inside the body of a function, but"
    },
    {
      "Time_Start": 1529.36,
      "Time_End": 1530.36,
      "Text": " there are some exceptions."
    },
    {
      "Time_Start": 1530.36,
      "Time_End": 1534.72,
      "Text": " I mean, if I need to do a dynamic stack allocation, how can I do that?"
    },
    {
      "Time_Start": 1534.72,
      "Time_End": 1536.8799999999999,
      "Text": " Well, of course I can do that."
    },
    {
      "Time_Start": 1536.8799999999999,
      "Time_End": 1540.48,
      "Text": " I can call an allocate inside my function."
    },
    {
      "Time_Start": 1540.48,
      "Time_End": 1548.96,
      "Text": " So I can also use the RBP again as a base pointer or any other register for what I matter."
    },
    {
      "Time_Start": 1548.96,
      "Time_End": 1559.6000000000001,
      "Text": " And I can use RSP then to be the stack pointer and base pointer of the inner frame."
    },
    {
      "Time_Start": 1559.6000000000001,
      "Time_End": 1566.32,
      "Text": " So literally, what it does is that it performs this operation, moveRBP, RSP."
    },
    {
      "Time_Start": 1566.32,
      "Time_End": 1571.3600000000001,
      "Text": " This is very interesting, even if alone you wouldn't understand why."
    },
    {
      "Time_Start": 1571.3600000000001,
      "Time_End": 1576.24,
      "Text": " But this literally is just saying, okay, I have an inner frame, please restore the base"
    },
    {
      "Time_Start": 1576.24,
      "Time_End": 1578.3600000000001,
      "Text": " pointer."
    },
    {
      "Time_Start": 1578.3600000000001,
      "Time_End": 1584.72,
      "Text": " Of course, RSP will contain a reference to the main module, because we need to trace"
    },
    {
      "Time_Start": 1584.72,
      "Time_End": 1587.0800000000002,
      "Text": " back, right?"
    },
    {
      "Time_Start": 1587.0800000000002,
      "Time_End": 1594.5200000000002,
      "Text": " Then we have a pushRBP, a pushreg frame, and this will literally push RBP onto the stack."
    },
    {
      "Time_Start": 1594.5200000000002,
      "Time_End": 1603.0800000000002,
      "Text": " Now, maybe it's not clear why now, but let's imagine this from the perspective of the unwinding"
    },
    {
      "Time_Start": 1603.0800000000002,
      "Time_End": 1604.0800000000002,
      "Text": " algorithm."
    },
    {
      "Time_Start": 1604.1599999999999,
      "Time_End": 1609.36,
      "Text": " It means that at a certain point that RBP is pushed on the stack, if it's pushed on"
    },
    {
      "Time_Start": 1609.36,
      "Time_End": 1611.56,
      "Text": " the stack, we can modify it."
    },
    {
      "Time_Start": 1611.56,
      "Time_End": 1616.48,
      "Text": " And from the perspective of the unwinding algorithm, when I'm performing all the epilogues"
    },
    {
      "Time_Start": 1616.48,
      "Time_End": 1624.1599999999999,
      "Text": " to trace back the call stack, there will be a virtual function there doing popRBP and"
    },
    {
      "Time_Start": 1624.1599999999999,
      "Time_End": 1630.3999999999999,
      "Text": " then moveRSP, RBP, putting RSP to an arbitrary value."
    },
    {
      "Time_Start": 1630.4,
      "Time_End": 1634.8000000000002,
      "Text": " Because RBP is on the stack, we can modify it."
    },
    {
      "Time_Start": 1634.8000000000002,
      "Time_End": 1636.48,
      "Text": " So why this is handy?"
    },
    {
      "Time_Start": 1636.48,
      "Time_End": 1643.88,
      "Text": " Because that means that we can literally put any arbitrary value in RBP, and the call stack"
    },
    {
      "Time_Start": 1643.88,
      "Time_End": 1650.4,
      "Text": " will be reconstructed, taking that RBP value in account."
    },
    {
      "Time_Start": 1650.4,
      "Time_End": 1659.48,
      "Text": " So we can literally say this RBP is in NTDLL, and this would not work, but we can literally"
    },
    {
      "Time_Start": 1659.56,
      "Time_End": 1663.56,
      "Text": " put any arbitrary frame, and the call stack will actually be reconstructed by taking that"
    },
    {
      "Time_Start": 1663.56,
      "Time_End": 1670.1200000000001,
      "Text": " as the frame that is the caller frame."
    },
    {
      "Time_Start": 1670.1200000000001,
      "Time_End": 1674.28,
      "Text": " Of course, if we do that, we need a way to..."
    },
    {
      "Time_Start": 1674.28,
      "Time_End": 1676.28,
      "Text": " This will already work."
    },
    {
      "Time_Start": 1676.28,
      "Time_End": 1683.8,
      "Text": " By doing this and putting a suitable value in RBP, we can already hide the main module"
    },
    {
      "Time_Start": 1683.8,
      "Time_End": 1684.8,
      "Text": " from memory."
    },
    {
      "Time_Start": 1684.8,
      "Time_End": 1687.24,
      "Text": " But there is a problem."
    },
    {
      "Time_Start": 1687.24,
      "Time_End": 1692.28,
      "Text": " If we do that, of course, on return, this program will crash."
    },
    {
      "Time_Start": 1692.28,
      "Time_End": 1695.72,
      "Text": " So we need a way to restore execution."
    },
    {
      "Time_Start": 1695.72,
      "Time_End": 1701.48,
      "Text": " We can use timers like callStackMasker, we can use another approach that is not the one"
    },
    {
      "Time_Start": 1701.48,
      "Time_End": 1705.2,
      "Text": " I'm going to present you there, but it will not be stack-movewalking anymore."
    },
    {
      "Time_Start": 1705.2,
      "Time_End": 1710.24,
      "Text": " So what we use is a combination of..."
    },
    {
      "Time_Start": 1710.24,
      "Time_End": 1714.18,
      "Text": " Not just a combination, we will use a job gadget to solve the problem."
    },
    {
      "Time_Start": 1714.18,
      "Time_End": 1717.5800000000002,
      "Text": " We call this frame the synchronization frame."
    },
    {
      "Time_Start": 1717.5800000000002,
      "Time_End": 1720.14,
      "Text": " And this job gadget is just a jump RBX."
    },
    {
      "Time_Start": 1720.14,
      "Time_End": 1722.94,
      "Text": " You can locate it within a suitable frame."
    },
    {
      "Time_Start": 1722.94,
      "Time_End": 1725.1000000000001,
      "Text": " You locate this jump RBX in memory."
    },
    {
      "Time_Start": 1725.1000000000001,
      "Time_End": 1731.8200000000002,
      "Text": " And the reason why we select jump RBX is purely opportunistic."
    },
    {
      "Time_Start": 1731.8200000000002,
      "Time_End": 1738.14,
      "Text": " We could use any sort of job prop, and I will discuss this later, or cop gadget, because"
    },
    {
      "Time_Start": 1738.14,
      "Time_End": 1744.5800000000002,
      "Text": " RBX contains a function, a pointer to a function that we decide, we have full control of."
    },
    {
      "Time_Start": 1744.5800000000002,
      "Time_End": 1752.74,
      "Text": " So we can literally put any kind of gadget there, as long as it fits for propose."
    },
    {
      "Time_Start": 1752.74,
      "Time_End": 1757.96,
      "Text": " But because this will be too obvious, because we will have a job gadget on return, we also"
    },
    {
      "Time_Start": 1757.96,
      "Time_End": 1762.1000000000001,
      "Text": " use a concealed frame to just be a bit more stealthy."
    },
    {
      "Time_Start": 1762.1000000000001,
      "Time_End": 1765.26,
      "Text": " And the concealed frame is just a stack-movewalk gadget, right?"
    },
    {
      "Time_Start": 1766.26,
      "Time_End": 1770.02,
      "Text": " You find a lot of them in any legitimate function of Windows."
    },
    {
      "Time_Start": 1770.02,
      "Time_End": 1772.9,
      "Text": " In kernel-based, there are a lot of these functions."
    },
    {
      "Time_Start": 1772.9,
      "Time_End": 1775.86,
      "Text": " So there is no problem in finding them."
    },
    {
      "Time_Start": 1775.86,
      "Time_End": 1781.62,
      "Text": " And the other RBX is not really appearing in the middle of a function."
    },
    {
      "Time_Start": 1781.62,
      "Time_End": 1784.52,
      "Text": " It's literally the end of the function."
    },
    {
      "Time_Start": 1784.52,
      "Time_End": 1791.34,
      "Text": " So it's impossible to say this is a non-legitimate frame."
    },
    {
      "Time_Start": 1791.34,
      "Time_End": 1792.9,
      "Text": " So on return, what happens?"
    },
    {
      "Time_Start": 1792.9,
      "Time_End": 1797.7800000000002,
      "Text": " I execute my target function, and on return, I hit the stack-movewalk gadget that will"
    },
    {
      "Time_Start": 1797.7800000000002,
      "Time_End": 1800.5,
      "Text": " jump back to jump RBX."
    },
    {
      "Time_Start": 1800.5,
      "Time_End": 1807.6200000000001,
      "Text": " And jump RBX will just completely ignore both the setfpreg and pushreg frame."
    },
    {
      "Time_Start": 1807.6200000000001,
      "Time_End": 1808.6200000000001,
      "Text": " We don't care."
    },
    {
      "Time_Start": 1808.6200000000001,
      "Time_End": 1811.6200000000001,
      "Text": " And this is the reason why I said the return is not available."
    },
    {
      "Time_Start": 1811.6200000000001,
      "Time_End": 1812.6200000000001,
      "Text": " I don't care."
    },
    {
      "Time_Start": 1812.6200000000001,
      "Time_End": 1815.66,
      "Text": " I just don't care about that."
    },
    {
      "Time_Start": 1815.66,
      "Time_End": 1816.66,
      "Text": " This will hit."
    },
    {
      "Time_Start": 1817.14,
      "Time_End": 1818.14,
      "Text": " There is an error."
    },
    {
      "Time_Start": 1818.14,
      "Time_End": 1823.18,
      "Text": " This should be from jump RBX, but, yeah, I was wrong."
    },
    {
      "Time_Start": 1823.18,
      "Time_End": 1828.02,
      "Text": " That this will hit the restore, that will remove all the frames, deallocate the space,"
    },
    {
      "Time_Start": 1828.02,
      "Time_End": 1830.6200000000001,
      "Text": " and then restore execution in the main module."
    },
    {
      "Time_Start": 1830.6200000000001,
      "Time_End": 1834.9,
      "Text": " And the full technique is explained here, even though I don't know what you read."
    },
    {
      "Time_Start": 1834.9,
      "Time_End": 1840.66,
      "Text": " And when you hit the target function, what you can see from the perspective is literally"
    },
    {
      "Time_Start": 1840.66,
      "Time_End": 1846.94,
      "Text": " that pseudo stack."
    },
    {
      "Time_Start": 1846.94,
      "Time_End": 1853.1000000000001,
      "Text": " So you have RTUL user thread that started, address of return address, which is the suitable"
    },
    {
      "Time_Start": 1853.1000000000001,
      "Time_End": 1859.22,
      "Text": " return address that we want to put RBP to."
    },
    {
      "Time_Start": 1859.22,
      "Time_End": 1867.6200000000001,
      "Text": " And that would actually, if you compile the main.exe of the POC without CRT, that address"
    },
    {
      "Time_Start": 1867.6200000000001,
      "Time_End": 1871.8200000000002,
      "Text": " of return address will actually be base thread in a tank."
    },
    {
      "Time_Start": 1871.8200000000002,
      "Time_End": 1876.0600000000002,
      "Text": " And then you have four functions that are the frames that we selected."
    },
    {
      "Time_Start": 1876.0600000000002,
      "Time_End": 1879.14,
      "Text": " First frame, second frame, the jump RBX and the stack people."
    },
    {
      "Time_Start": 1879.14,
      "Time_End": 1885.0600000000002,
      "Text": " And then you have, finally, the target function."
    },
    {
      "Time_Start": 1885.0600000000002,
      "Time_End": 1889.0200000000002,
      "Text": " So very legitimate frame, very legitimate call stack."
    },
    {
      "Time_Start": 1889.0200000000002,
      "Time_End": 1897.0600000000002,
      "Text": " And just because it's fancy and I spend a lot of time to do that for marketing proposals,"
    },
    {
      "Time_Start": 1897.06,
      "Time_End": 1898.58,
      "Text": " I give that."
    },
    {
      "Time_Start": 1898.58,
      "Time_End": 1901.3799999999999,
      "Text": " So practically, there is this main executable."
    },
    {
      "Time_Start": 1901.3799999999999,
      "Time_End": 1906.22,
      "Text": " We select, my God, we select the four frames."
    },
    {
      "Time_Start": 1906.22,
      "Time_End": 1911.02,
      "Text": " And these four frames will actually obscure the main executable."
    },
    {
      "Time_Start": 1911.02,
      "Time_End": 1917.5,
      "Text": " You call the spoof function, then our return, what happens is that you will hit the restore."
    },
    {
      "Time_Start": 1917.5,
      "Time_End": 1923.7,
      "Text": " The restore will restore the stack back and you will be returned to, my God, wow, how"
    },
    {
      "Time_Start": 1923.7,
      "Time_End": 1924.8999999999999,
      "Text": " much is low."
    },
    {
      "Time_Start": 1924.9,
      "Time_End": 1928.02,
      "Text": " And it will return to the main.exe."
    },
    {
      "Time_Start": 1928.02,
      "Time_End": 1930.42,
      "Text": " That's it."
    },
    {
      "Time_Start": 1930.42,
      "Time_End": 1934.98,
      "Text": " So I want to take just one moment to thank the contributors."
    },
    {
      "Time_Start": 1934.98,
      "Time_End": 1938.66,
      "Text": " This was an adjoint research, so I want to thank Namazo."
    },
    {
      "Time_Start": 1938.66,
      "Time_End": 1943.46,
      "Text": " I didn't put it in the slide, but I want to thank Namazo for the original idea."
    },
    {
      "Time_Start": 1943.46,
      "Time_End": 1950.1000000000001,
      "Text": " We came to this independently, but we were kind of inspired by him."
    },
    {
      "Time_Start": 1950.1000000000001,
      "Time_End": 1955.8600000000001,
      "Text": " And then I want to thank Waldo and Trickster because they contribute to this research,"
    },
    {
      "Time_Start": 1955.8600000000001,
      "Time_End": 1956.8600000000001,
      "Text": " which is not finished."
    },
    {
      "Time_Start": 1956.8600000000001,
      "Time_End": 1960.42,
      "Text": " This is just the first 30% of the research."
    },
    {
      "Time_Start": 1960.42,
      "Time_End": 1963.6200000000001,
      "Text": " We have something else coming up."
    },
    {
      "Time_Start": 1963.6200000000001,
      "Time_End": 1968.1000000000001,
      "Text": " And then let's discuss about defensive considerations."
    },
    {
      "Time_Start": 1968.1000000000001,
      "Time_End": 1975.5000000000002,
      "Text": " Okay, so the first thing you want to do to protect against every stack spoofing technique,"
    },
    {
      "Time_Start": 1975.5000000000002,
      "Time_End": 1978.2600000000002,
      "Text": " including this one, is enable chat."
    },
    {
      "Time_Start": 1978.42,
      "Time_End": 1988.46,
      "Text": " Control enforcement technology, or HSP, hardware-enforced stack protection, is very effective against"
    },
    {
      "Time_Start": 1988.46,
      "Time_End": 1989.46,
      "Text": " this kind of techniques."
    },
    {
      "Time_Start": 1989.46,
      "Time_End": 1994.22,
      "Text": " If you don't know what it is, there is the link at the bottom."
    },
    {
      "Time_Start": 1994.22,
      "Time_End": 1997.3799999999999,
      "Text": " And practically what it does, it creates a shadow stack."
    },
    {
      "Time_Start": 1997.3799999999999,
      "Time_End": 2004.14,
      "Text": " And the shadow stack is a list of all the return addresses that your program took by"
    },
    {
      "Time_Start": 2004.14,
      "Time_End": 2006.74,
      "Text": " calling a specific function."
    },
    {
      "Time_Start": 2006.74,
      "Time_End": 2013.6200000000001,
      "Text": " And practically the call stack, the one you can manipulate on return, is compared to the"
    },
    {
      "Time_Start": 2013.6200000000001,
      "Time_End": 2014.6200000000001,
      "Text": " shadow stack."
    },
    {
      "Time_Start": 2014.6200000000001,
      "Time_End": 2018.74,
      "Text": " So the difference between the normal call stack and the shadow stack is that the call"
    },
    {
      "Time_Start": 2018.74,
      "Time_End": 2020.38,
      "Text": " stack contains everything."
    },
    {
      "Time_Start": 2020.38,
      "Time_End": 2024.66,
      "Text": " So the return addresses, the parameters, everything."
    },
    {
      "Time_Start": 2024.66,
      "Time_End": 2029.78,
      "Text": " So you can manipulate that from user land and kernel land."
    },
    {
      "Time_Start": 2029.82,
      "Time_End": 2037.18,
      "Text": " The hardware, the shadow stack instead, is populated only when a call occurs."
    },
    {
      "Time_Start": 2037.18,
      "Time_End": 2040.1399999999999,
      "Text": " And it's completely hardware protected."
    },
    {
      "Time_Start": 2040.1399999999999,
      "Time_End": 2044.46,
      "Text": " So you can manipulate it even if you have kernel level access."
    },
    {
      "Time_Start": 2044.46,
      "Time_End": 2050.1,
      "Text": " The way it works is similar to return throw guard, which is something Windows introduced"
    },
    {
      "Time_Start": 2050.1,
      "Time_End": 2054.14,
      "Text": " a while ago, but then discarded because it contained a lot of bugs."
    },
    {
      "Time_Start": 2054.14,
      "Time_End": 2059.62,
      "Text": " So they said, okay, let's stick to Intel implementation."
    },
    {
      "Time_Start": 2059.62,
      "Time_End": 2061.2599999999998,
      "Text": " But it's literally the same thing."
    },
    {
      "Time_Start": 2061.2599999999998,
      "Time_End": 2063.54,
      "Text": " They populate all these return addresses."
    },
    {
      "Time_Start": 2063.54,
      "Time_End": 2066.74,
      "Text": " When you hit a return, they are compared."
    },
    {
      "Time_Start": 2066.74,
      "Time_End": 2070.2999999999997,
      "Text": " If they mismatch, the program is killed."
    },
    {
      "Time_Start": 2070.2999999999997,
      "Time_End": 2077.8599999999997,
      "Text": " So all things that are relying on ROP in some sort of form will probably be a no more as"
    },
    {
      "Time_Start": 2077.8599999999997,
      "Time_End": 2080.14,
      "Text": " soon as this is widely adopted."
    },
    {
      "Time_Start": 2080.14,
      "Time_End": 2086.02,
      "Text": " The only thing that saves us so far is that this thing was introduced, the support for"
    },
    {
      "Time_Start": 2086.06,
      "Time_End": 2092.94,
      "Text": " this was actually added in all Intel CPUs from 2021, if I'm not mistaken."
    },
    {
      "Time_Start": 2092.94,
      "Time_End": 2093.94,
      "Text": " I might be mistaken."
    },
    {
      "Time_Start": 2093.94,
      "Time_End": 2096.9,
      "Text": " So they give me a grain of salt."
    },
    {
      "Time_Start": 2096.9,
      "Time_End": 2101.58,
      "Text": " But what I'm trying to say is that it's literally very young as a technology."
    },
    {
      "Time_Start": 2101.58,
      "Time_End": 2103.98,
      "Text": " So there are a lot of legacy CPUs around."
    },
    {
      "Time_Start": 2103.98,
      "Time_End": 2109.86,
      "Text": " So it's going to take a while to actually see this widely adopted."
    },
    {
      "Time_Start": 2109.86,
      "Time_End": 2114.9,
      "Text": " But Windows is starting enforcing it from Windows 11."
    },
    {
      "Time_Start": 2115.06,
      "Time_End": 2123.2200000000003,
      "Text": " So I guess we are approaching to that time."
    },
    {
      "Time_Start": 2123.2200000000003,
      "Time_End": 2126.6600000000003,
      "Text": " Another defensive consideration, until we don't have chat, is this."
    },
    {
      "Time_Start": 2126.6600000000003,
      "Time_End": 2133.14,
      "Text": " So stack moonwalking creates this completely valid, like from an unwindability perspective,"
    },
    {
      "Time_Start": 2133.14,
      "Time_End": 2134.2200000000003,
      "Text": " completely valid cold stack."
    },
    {
      "Time_Start": 2134.2200000000003,
      "Time_End": 2140.26,
      "Text": " But as William Burgess already skimmed it out, I guess, in one of his blog posts, these"
    },
    {
      "Time_Start": 2140.26,
      "Time_End": 2142.1800000000003,
      "Text": " frames are not related to each other."
    },
    {
      "Time_Start": 2142.18,
      "Time_End": 2150.1,
      "Text": " At least the current implementation of this stack moonwalking technique doesn't use frames"
    },
    {
      "Time_Start": 2150.1,
      "Time_End": 2155.94,
      "Text": " that are related, meaning that it's very unlikely that this card virtual memory would call normalized"
    },
    {
      "Time_Start": 2155.94,
      "Time_End": 2156.94,
      "Text": " string."
    },
    {
      "Time_Start": 2156.94,
      "Time_End": 2157.94,
      "Text": " Why?"
    },
    {
      "Time_Start": 2157.94,
      "Time_End": 2162.02,
      "Text": " There is no real reason."
    },
    {
      "Time_Start": 2162.02,
      "Time_End": 2169.98,
      "Text": " So you can hunt for this specific semantic kind of issues."
    },
    {
      "Time_Start": 2170.02,
      "Time_End": 2174.86,
      "Text": " And if you look further, I mean, we will release the detection algorithm very soon."
    },
    {
      "Time_Start": 2174.86,
      "Time_End": 2182.34,
      "Text": " But the detection is based on the fact that, like, if you look at that memory, so like"
    },
    {
      "Time_Start": 2182.34,
      "Time_End": 2189.38,
      "Text": " normalized string plus 66, you will see that before that operation, there is no call."
    },
    {
      "Time_Start": 2189.38,
      "Time_End": 2193.58,
      "Text": " If there is no call, then there is no possibility that function was called by anything."
    },
    {
      "Time_Start": 2193.58,
      "Time_End": 2197.22,
      "Text": " So yeah, you have a mismatch there."
    },
    {
      "Time_Start": 2197.2200000000003,
      "Time_End": 2200.78,
      "Text": " So this is the way you would hunt for this string."
    },
    {
      "Time_Start": 2200.78,
      "Time_End": 2207.5400000000004,
      "Text": " If you want to hunt instead for the gadgets, I would not recommend it, because the point"
    },
    {
      "Time_Start": 2207.5400000000004,
      "Time_End": 2215.0000000000005,
      "Text": " that I'm going to take in the key takeaways, okay, the POC is here, the moonwalk is public."
    },
    {
      "Time_Start": 2215.0000000000005,
      "Time_End": 2218.7400000000002,
      "Text": " You can go and check it out."
    },
    {
      "Time_Start": 2218.7400000000002,
      "Time_End": 2221.46,
      "Text": " And as I said, this POC is designed to obfuscate the stack around time."
    },
    {
      "Time_Start": 2221.46,
      "Time_End": 2223.34,
      "Text": " There are other, yeah."
    },
    {
      "Time_Start": 2223.34,
      "Time_End": 2230.2200000000003,
      "Text": " So for sleep obfuscation, my bad, I put what I wanted to say too late in this slide."
    },
    {
      "Time_Start": 2230.2200000000003,
      "Time_End": 2235.7400000000002,
      "Text": " So for sleep obfuscation, I would rather use another approach, because this was not meant"
    },
    {
      "Time_Start": 2235.7400000000002,
      "Time_End": 2240.34,
      "Text": " to protect the stack on sleep."
    },
    {
      "Time_Start": 2240.34,
      "Time_End": 2241.34,
      "Text": " Why I say that?"
    },
    {
      "Time_Start": 2241.34,
      "Time_End": 2245.7400000000002,
      "Text": " You can, of course, call wait for single object with stack moonwalk."
    },
    {
      "Time_Start": 2245.7400000000002,
      "Time_End": 2253.0600000000004,
      "Text": " But the more time you give a defender to analyze the stack and see, and the more it"
    },
    {
      "Time_Start": 2253.0600000000004,
      "Time_End": 2256.78,
      "Text": " will be apparent that something dodgy is happening, right?"
    },
    {
      "Time_Start": 2256.78,
      "Time_End": 2262.86,
      "Text": " Instead, if you use these as in combination with a sleep obfuscation kind of stack spoofing,"
    },
    {
      "Time_Start": 2262.86,
      "Time_End": 2269.1400000000003,
      "Text": " this will be very effective, because you literally can execute anything from memory and the call"
    },
    {
      "Time_Start": 2269.1400000000003,
      "Time_End": 2272.5800000000004,
      "Text": " stack inspector will not be able to identify anything."
    },
    {
      "Time_Start": 2272.58,
      "Time_End": 2279.14,
      "Text": " So yeah, this is probably the, it's best suited to be used in combination with another"
    },
    {
      "Time_Start": 2279.14,
      "Time_End": 2286.58,
      "Text": " obfuscation approach on sleep and use solid stack moonwalk for obfuscating call stacks"
    },
    {
      "Time_Start": 2286.58,
      "Time_End": 2290.02,
      "Text": " at runtime."
    },
    {
      "Time_Start": 2290.02,
      "Time_End": 2297.06,
      "Text": " And the thing I want you to actually understand is that the jump RBX was completely arbitrary."
    },
    {
      "Time_Start": 2297.06,
      "Time_End": 2299.14,
      "Text": " You can use another non-volatile register."
    },
    {
      "Time_Start": 2299.14,
      "Time_End": 2301.72,
      "Text": " You can use a push RET approach."
    },
    {
      "Time_Start": 2301.7200000000003,
      "Time_End": 2304.5200000000004,
      "Text": " You can use a call, a cop gadget."
    },
    {
      "Time_Start": 2304.5200000000004,
      "Time_End": 2309.44,
      "Text": " And the reason you can use a cop gadget is because restore is on you, is completely arbitrary."
    },
    {
      "Time_Start": 2309.44,
      "Time_End": 2314.8,
      "Text": " So you can literally have a push, a pop rax at the start of the restore function and get"
    },
    {
      "Time_Start": 2314.8,
      "Time_End": 2316.0400000000004,
      "Text": " rid of return address."
    },
    {
      "Time_Start": 2316.0400000000004,
      "Time_End": 2317.9,
      "Text": " So you don't need to care about that."
    },
    {
      "Time_Start": 2317.9,
      "Time_End": 2321.5600000000004,
      "Text": " So you can use cop as well."
    },
    {
      "Time_Start": 2321.5600000000004,
      "Time_End": 2327.44,
      "Text": " And it is possible to create chains of arbitrary frames, meaning that literally the concealed"
    },
    {
      "Time_Start": 2327.44,
      "Time_End": 2335.68,
      "Text": " frames that you are adding, I didn't show this here, but you can put an arbitrary number"
    },
    {
      "Time_Start": 2335.68,
      "Time_End": 2343.12,
      "Text": " of concealed frames before the job gadget and after the job gadget, and the function"
    },
    {
      "Time_Start": 2343.12,
      "Time_End": 2347.0,
      "Text": " will work as it is."
    },
    {
      "Time_Start": 2347.0,
      "Time_End": 2348.0,
      "Text": " Doesn't matter."
    },
    {
      "Time_Start": 2348.0,
      "Time_End": 2355.6,
      "Text": " So you can create literally an arbitrary stack frame, like stack frames of arbitrary length."
    },
    {
      "Time_Start": 2355.6,
      "Time_End": 2360.88,
      "Text": " And the last thing, you can actually look at this yourself."
    },
    {
      "Time_Start": 2360.88,
      "Time_End": 2363.36,
      "Text": " It will require a bit of research, though."
    },
    {
      "Time_Start": 2363.36,
      "Time_End": 2369.3199999999997,
      "Text": " It is difficult, but it's not impossible to create chains that creates completely valid"
    },
    {
      "Time_Start": 2369.3199999999997,
      "Time_End": 2371.52,
      "Text": " call stacks."
    },
    {
      "Time_Start": 2371.52,
      "Time_End": 2375.7599999999998,
      "Text": " I don't, I'm not disclosing them, but it's possible."
    },
    {
      "Time_Start": 2375.7599999999998,
      "Time_End": 2380.72,
      "Text": " It's possible to create completely valid call stacks with this."
    },
    {
      "Time_Start": 2380.72,
      "Time_End": 2381.8399999999997,
      "Text": " And that's it from me."
    }
  ]
}