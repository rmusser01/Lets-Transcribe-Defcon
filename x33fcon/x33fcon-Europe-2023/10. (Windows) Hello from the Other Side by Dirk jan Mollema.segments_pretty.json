{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 11.0,
      "Text": "This text was transcribed using whisper model: large-v2\n\n So, before we start, a little bit about me, for those who don't know me yet."
    },
    {
      "Time_Start": 11.0,
      "Time_End": 12.24,
      "Text": " I'm Dirk Jan Mollema."
    },
    {
      "Time_Start": 12.24,
      "Time_End": 17.36,
      "Text": " I live here in the Netherlands, so it's close to home for me."
    },
    {
      "Time_Start": 17.36,
      "Time_End": 21.6,
      "Text": " I work at Outsider Security, which is my own company that I started last year."
    },
    {
      "Time_Start": 21.6,
      "Time_End": 28.12,
      "Text": " I do a bit of a mix of hacking, research, writing blogs, giving trainings, doing consultancy,"
    },
    {
      "Time_Start": 28.12,
      "Time_End": 30.400000000000002,
      "Text": " so a bit of everything."
    },
    {
      "Time_Start": 30.400000000000002,
      "Time_End": 34.46,
      "Text": " I really like to give talks, so to share my knowledge with other people, so I've given"
    },
    {
      "Time_Start": 34.46,
      "Time_End": 38.84,
      "Text": " talks at several conferences in the past, and very happy to be here at Xevecon for the"
    },
    {
      "Time_Start": 38.84,
      "Time_End": 39.84,
      "Text": " first time."
    },
    {
      "Time_Start": 39.84,
      "Time_End": 42.14,
      "Text": " Not the last time, I hope."
    },
    {
      "Time_Start": 42.14,
      "Time_End": 46.88,
      "Text": " As part of my research, I usually write my own tooling, and I publish that tooling as"
    },
    {
      "Time_Start": 46.88,
      "Time_End": 51.24,
      "Text": " open source, so you can find several of those on my GitHub."
    },
    {
      "Time_Start": 51.24,
      "Time_End": 56.2,
      "Text": " I also have a blog at DirkjanM.io, and if you want, you can follow me on Twitter to"
    },
    {
      "Time_Start": 56.2,
      "Time_End": 60.120000000000005,
      "Text": " keep up to date with all the stuff that I do."
    },
    {
      "Time_Start": 60.120000000000005,
      "Time_End": 64.2,
      "Text": " So today, we're going to be talking about Windows Hello for Business."
    },
    {
      "Time_Start": 64.2,
      "Time_End": 69.96000000000001,
      "Text": " From here on, shorten to WHFB, because I don't want to type out the whole thing all the time."
    },
    {
      "Time_Start": 69.96000000000001,
      "Time_End": 74.96000000000001,
      "Text": " I'm going to look at what exactly it is, which flavors of Windows Hello for Business you"
    },
    {
      "Time_Start": 74.96000000000001,
      "Time_End": 81.2,
      "Text": " have, so in which ways you can deploy it, and have a little bit look at the internal"
    },
    {
      "Time_Start": 81.2,
      "Time_End": 87.52000000000001,
      "Text": " things, so the key enrollment process, how the keys are used in the various stages."
    },
    {
      "Time_Start": 87.52000000000001,
      "Time_End": 93.32000000000001,
      "Text": " And then on to the fun parts, or at least for the red teamers among us, bypassing MFA"
    },
    {
      "Time_Start": 93.32000000000001,
      "Time_End": 98.60000000000001,
      "Text": " with Windows Hello for Business, some lateral movement, and also looking at how Windows"
    },
    {
      "Time_Start": 98.60000000000001,
      "Time_End": 102.24000000000001,
      "Text": " Hello for Business works in hybrid setups."
    },
    {
      "Time_Start": 102.24000000000001,
      "Time_End": 107.60000000000001,
      "Text": " So first of all, Windows Hello for Business, or the normal Windows Hello, basically is"
    },
    {
      "Time_Start": 107.68,
      "Time_End": 110.36000000000001,
      "Text": " one of Microsoft's passwordless authentication offerings."
    },
    {
      "Time_Start": 110.36000000000001,
      "Time_End": 116.28,
      "Text": " So we all know that passwords, well, we're all bad at picking passwords, especially if"
    },
    {
      "Time_Start": 116.28,
      "Time_End": 120.68,
      "Text": " one thinks that a normal human being can have unique passwords for every website that he"
    },
    {
      "Time_Start": 120.68,
      "Time_End": 125.32000000000001,
      "Text": " has an account at, which is never going to happen, so people pick simple passwords, people"
    },
    {
      "Time_Start": 125.32000000000001,
      "Time_End": 131.4,
      "Text": " reuse passwords, and as part of that, Microsoft has been working on new ways to authenticate,"
    },
    {
      "Time_Start": 131.4,
      "Time_End": 136.48000000000002,
      "Text": " which is one of their passwordless authentication solutions, and Windows Hello for Business"
    },
    {
      "Time_Start": 136.48,
      "Time_End": 138.92,
      "Text": " is one of these offerings."
    },
    {
      "Time_Start": 138.92,
      "Time_End": 144.39999999999998,
      "Text": " And basically the idea about Windows Hello for Business is that it uses cryptographic"
    },
    {
      "Time_Start": 144.39999999999998,
      "Time_End": 150.44,
      "Text": " keys that are stored in your device, and you unlock these with a pin, or with a face recognition,"
    },
    {
      "Time_Start": 150.44,
      "Time_End": 157.07999999999998,
      "Text": " or with a fingerprint, or basically you have a key that's stored on a device, and you unlock"
    },
    {
      "Time_Start": 157.07999999999998,
      "Time_End": 160.92,
      "Text": " that key on your trusted device, and that you use to authenticate."
    },
    {
      "Time_Start": 160.92000000000002,
      "Time_End": 166.8,
      "Text": " So you basically replace the passwords with a key that's stored on a trusted device somewhere."
    },
    {
      "Time_Start": 166.8,
      "Time_End": 171.36,
      "Text": " And you can have Windows Hello for Business in several flavors, you can have it only in"
    },
    {
      "Time_Start": 171.36,
      "Time_End": 176.32000000000002,
      "Text": " your on-prem Active Directory, you can have it only in your Azure Active Directory, or"
    },
    {
      "Time_Start": 176.32000000000002,
      "Time_End": 181.32000000000002,
      "Text": " you can have a mix of both, so you have a hybrid setup."
    },
    {
      "Time_Start": 181.32000000000002,
      "Time_End": 186.04000000000002,
      "Text": " Basically the idea is that you have that key on the device, and you use that to authenticate"
    },
    {
      "Time_Start": 186.2,
      "Time_End": 191.51999999999998,
      "Text": " to, in this case, Azure AD, since we'll be focusing on Azure AD in this talk."
    },
    {
      "Time_Start": 191.51999999999998,
      "Time_End": 194.16,
      "Text": " I just wanted to highlight some prior work."
    },
    {
      "Time_Start": 194.16,
      "Time_End": 198.35999999999999,
      "Text": " So there have been some people that looked at Windows Hello for Business before."
    },
    {
      "Time_Start": 198.35999999999999,
      "Time_End": 202.88,
      "Text": " One of the most interesting ones, I think, is the talk, Exploiting Windows Hello for"
    },
    {
      "Time_Start": 202.88,
      "Time_End": 205.68,
      "Text": " Business by Michael Grafnetter."
    },
    {
      "Time_Start": 205.68,
      "Time_End": 210.23999999999998,
      "Text": " Basically he looked at how Windows Hello for Business works in on-prem Active Directory,"
    },
    {
      "Time_Start": 210.23999999999998,
      "Time_End": 215.28,
      "Text": " and this was also the inspiration of the shadow credentials attack in Active Directory by"
    },
    {
      "Time_Start": 215.36,
      "Time_End": 216.36,
      "Text": " Ilad Shamir."
    },
    {
      "Time_Start": 216.36,
      "Time_End": 222.52,
      "Text": " Basically this makes it possible to write keys to other users and then perform lateral"
    },
    {
      "Time_Start": 222.52,
      "Time_End": 224.24,
      "Text": " movement with that."
    },
    {
      "Time_Start": 224.24,
      "Time_End": 226.12,
      "Text": " So those are some very interesting things."
    },
    {
      "Time_Start": 226.12,
      "Time_End": 231.22,
      "Text": " And there's actually quite some parallels with the Azure AD implementation of it."
    },
    {
      "Time_Start": 231.22,
      "Time_End": 234.4,
      "Text": " So this was definitely a very useful research."
    },
    {
      "Time_Start": 234.4,
      "Time_End": 240.24,
      "Text": " I've also found several research papers that focus on the Windows implementation, bypassing"
    },
    {
      "Time_Start": 240.24,
      "Time_End": 245.12,
      "Text": " the biometrics, trying to bypass the PIN, the fingerprint and stuff."
    },
    {
      "Time_Start": 245.96,
      "Time_End": 250.6,
      "Text": " But I didn't really find much on how it works in Azure AD, seeing that I was at least the"
    },
    {
      "Time_Start": 250.6,
      "Time_End": 253.24,
      "Text": " first one to look at that and write about it."
    },
    {
      "Time_Start": 253.24,
      "Time_End": 257.4,
      "Text": " There's also been some research about the internal Windows handling of the PIN and the"
    },
    {
      "Time_Start": 257.4,
      "Time_End": 262.16,
      "Text": " encryption and stuff by several people, among which is Benjamin Delphi."
    },
    {
      "Time_Start": 262.16,
      "Time_End": 266.72,
      "Text": " So there's definitely some prior work here, and with this I'm hoping to extend on this"
    },
    {
      "Time_Start": 266.72,
      "Time_End": 269.36,
      "Text": " further."
    },
    {
      "Time_Start": 269.36,
      "Time_End": 275.44,
      "Text": " If we look at some of the key points that Microsoft basically uses to advertise this"
    },
    {
      "Time_Start": 275.44,
      "Time_End": 280.84000000000003,
      "Text": " solution, basically the good thing about this is that Windows Low for Business provides"
    },
    {
      "Time_Start": 280.84000000000003,
      "Time_End": 286.72,
      "Text": " strong phishing-resistant multi-factor authentication, not my words, these are basically what they"
    },
    {
      "Time_Start": 286.72,
      "Time_End": 288.44,
      "Text": " say about it."
    },
    {
      "Time_Start": 288.44,
      "Time_End": 294.2,
      "Text": " It requires MFA2 provision, which is also why it's considered a more secure authentication"
    },
    {
      "Time_Start": 294.2,
      "Time_End": 295.2,
      "Text": " method."
    },
    {
      "Time_Start": 295.2,
      "Time_End": 300.68,
      "Text": " It's bound to a specific device, so you cannot just take the key from the device and use"
    },
    {
      "Time_Start": 300.68,
      "Time_End": 303.15999999999997,
      "Text": " it somewhere else, in theory."
    },
    {
      "Time_Start": 303.15999999999997,
      "Time_End": 307.71999999999997,
      "Text": " And if you have a trusted platform module, then the keys are protected by hardware, preventing"
    },
    {
      "Time_Start": 307.71999999999997,
      "Time_End": 312.88,
      "Text": " attackers from stealing the keys, even if they have full privileges on your endpoint."
    },
    {
      "Time_Start": 312.88,
      "Time_End": 316.36,
      "Text": " And this all makes it more secure than password authentication."
    },
    {
      "Time_Start": 316.36,
      "Time_End": 321.4,
      "Text": " So keep these points in mind a little, we'll get back to them at the end to see which ones"
    },
    {
      "Time_Start": 321.4,
      "Time_End": 324.56,
      "Text": " are actually true or not."
    },
    {
      "Time_Start": 324.56,
      "Time_End": 328.4,
      "Text": " So if we look at some of the Windows Low for Business flavors, I already mentioned you"
    },
    {
      "Time_Start": 328.4,
      "Time_End": 334.76,
      "Text": " have it with Azure AD native, so that's just the native Azure AD implementation of it."
    },
    {
      "Time_Start": 334.76,
      "Time_End": 339.56,
      "Text": " You can have it with Active Directory only, or in a hybrid setup."
    },
    {
      "Time_Start": 339.56,
      "Time_End": 343.2,
      "Text": " And basically, if you look at the Azure AD native, that's always enabled."
    },
    {
      "Time_Start": 343.2,
      "Time_End": 348.64,
      "Text": " So if you have Azure AD as an organization, if you use Microsoft 365, then your devices"
    },
    {
      "Time_Start": 348.64,
      "Time_End": 353.0,
      "Text": " can do Windows Low for Business, and it's enabled, so I don't think there is actually"
    },
    {
      "Time_Start": 353.0,
      "Time_End": 355.24,
      "Text": " a way to disable it."
    },
    {
      "Time_Start": 355.24,
      "Time_End": 359.72,
      "Text": " You can only control whether your devices will start using it or not, but the authentication"
    },
    {
      "Time_Start": 359.72,
      "Time_End": 362.72,
      "Text": " method is always enabled, as far as I know."
    },
    {
      "Time_Start": 362.72,
      "Time_End": 366.12,
      "Text": " For Active Directory and for hybrid setups, it's a bit different."
    },
    {
      "Time_Start": 366.12,
      "Time_End": 373.12,
      "Text": " It requires some custom setup, can be a complex setup, depending on which scenario you use,"
    },
    {
      "Time_Start": 373.12,
      "Time_End": 376.72,
      "Text": " especially if we look at hybrid key trust and hybrid certificate trust."
    },
    {
      "Time_Start": 376.72,
      "Time_End": 382.44,
      "Text": " You might need ADFS or a PKI infrastructure, so definitely makes it a bit more complex"
    },
    {
      "Time_Start": 382.44,
      "Time_End": 386.6,
      "Text": " than the, especially the Azure AD native implementation, because for that, you don't"
    },
    {
      "Time_Start": 386.6,
      "Time_End": 389.56,
      "Text": " need to do anything."
    },
    {
      "Time_Start": 389.56,
      "Time_End": 395.04,
      "Text": " So if you look at this implementation in Azure AD, one thing we need is always a device,"
    },
    {
      "Time_Start": 395.04,
      "Time_End": 396.4,
      "Text": " so a device identity."
    },
    {
      "Time_Start": 396.4,
      "Time_End": 401.84,
      "Text": " So to use Windows Low for Business in Azure AD, you need to have an Azure AD joint or"
    },
    {
      "Time_Start": 401.84,
      "Time_End": 403.44,
      "Text": " registered device."
    },
    {
      "Time_Start": 403.44,
      "Time_End": 407.52,
      "Text": " Usually that will be the user's endpoint that they're using."
    },
    {
      "Time_Start": 407.59999999999997,
      "Time_End": 412.47999999999996,
      "Text": " If Windows Low for Business is enabled, then the enrollment will take place at the end"
    },
    {
      "Time_Start": 412.47999999999996,
      "Time_End": 416.88,
      "Text": " of the Windows installation, so if you set up your device the first time and the policy"
    },
    {
      "Time_Start": 416.88,
      "Time_End": 422.64,
      "Text": " is set up to use it, then it will basically prompt the user to set up Windows Hello."
    },
    {
      "Time_Start": 422.64,
      "Time_End": 426.71999999999997,
      "Text": " If you enable it later, then whenever you sign in after it's enabled, at some point"
    },
    {
      "Time_Start": 426.71999999999997,
      "Time_End": 430.59999999999997,
      "Text": " it will prompt you and say, hey, let's start setting this up."
    },
    {
      "Time_Start": 430.59999999999997,
      "Time_End": 436.2,
      "Text": " So you get a screen like this, which says, hey, now let's get rid of that password and"
    },
    {
      "Time_Start": 436.2,
      "Time_End": 437.88,
      "Text": " use Windows Hello."
    },
    {
      "Time_Start": 437.88,
      "Time_End": 443.08,
      "Text": " Basically, when you click OK, it will prompt you for multi-factor authentication, this"
    },
    {
      "Time_Start": 443.08,
      "Time_End": 447.12,
      "Text": " important part in it, because, of course, if you could enroll these things without multi-factor"
    },
    {
      "Time_Start": 447.12,
      "Time_End": 449.92,
      "Text": " authentication, it would be quite bad."
    },
    {
      "Time_Start": 449.92,
      "Time_End": 454.96,
      "Text": " So it prompts you for multi-factor authentication, and then after, it asks you to set up the"
    },
    {
      "Time_Start": 454.96,
      "Time_End": 460.96,
      "Text": " local credentials, so there's, I think, always a backup pin."
    },
    {
      "Time_Start": 460.96,
      "Time_End": 464.64,
      "Text": " Sometimes the primary authentication is the pin, but you can also use biometrics or face"
    },
    {
      "Time_Start": 464.64,
      "Time_End": 470.64,
      "Text": " unlock, basically to unlock this local credential on the device."
    },
    {
      "Time_Start": 470.64,
      "Time_End": 474.91999999999996,
      "Text": " So if you look at the technical components, there's a few things involved here."
    },
    {
      "Time_Start": 474.91999999999996,
      "Time_End": 481.15999999999997,
      "Text": " The first one is the Azure AD device identity, so devices have an identity that's true for"
    },
    {
      "Time_Start": 481.15999999999997,
      "Time_End": 486.03999999999996,
      "Text": " both the on-prem implementation as for the Azure AD implementation, and for Azure AD,"
    },
    {
      "Time_Start": 486.03999999999996,
      "Time_End": 492.15999999999997,
      "Text": " the device basically uses a certificate plus a private key to prove its identity to Azure"
    },
    {
      "Time_Start": 492.15999999999997,
      "Time_End": 493.15999999999997,
      "Text": " AD."
    },
    {
      "Time_Start": 493.68,
      "Time_End": 497.32000000000005,
      "Text": " Another thing is a primary refresh token."
    },
    {
      "Time_Start": 497.32000000000005,
      "Time_End": 502.72,
      "Text": " For those of you who are not familiar with this, basically, when you have a device that's"
    },
    {
      "Time_Start": 502.72,
      "Time_End": 508.68,
      "Text": " connected to Azure AD, then it will get a primary refresh token to do a single sign-on,"
    },
    {
      "Time_Start": 508.68,
      "Time_End": 515.0400000000001,
      "Text": " so with these single sign-on credentials, it will sign in to any other resource, so"
    },
    {
      "Time_Start": 515.0400000000001,
      "Time_End": 519.96,
      "Text": " with this, you don't need to enter your password and do MFA anymore, because it uses the primary"
    },
    {
      "Time_Start": 519.96,
      "Time_End": 522.2,
      "Text": " refresh token."
    },
    {
      "Time_Start": 522.24,
      "Time_End": 528.48,
      "Text": " The other part is the Trusted Platform Module, or TPM, and basically, this is some hardware-based"
    },
    {
      "Time_Start": 528.48,
      "Time_End": 533.48,
      "Text": " protection for private keys, so that even if an attacker has system rights, they cannot"
    },
    {
      "Time_Start": 533.48,
      "Time_End": 536.88,
      "Text": " extract these private keys because they are stored in hardware."
    },
    {
      "Time_Start": 536.88,
      "Time_End": 542.5600000000001,
      "Text": " That is true for the device key from the device identity, the session key from the primary"
    },
    {
      "Time_Start": 542.5600000000001,
      "Time_End": 547.5200000000001,
      "Text": " refresh token, and the Windows Hello for Business keys."
    },
    {
      "Time_Start": 547.52,
      "Time_End": 552.76,
      "Text": " So if we look at the technical flow, then basically, it starts off with redirecting"
    },
    {
      "Time_Start": 552.76,
      "Time_End": 558.56,
      "Text": " the user to the login of Microsoft Online, and what we can see here, or basically, this"
    },
    {
      "Time_Start": 558.56,
      "Time_End": 561.88,
      "Text": " is a normal OAuth 2.0 initiation."
    },
    {
      "Time_Start": 561.88,
      "Time_End": 567.92,
      "Text": " The thing that springs out here is basically the authentication method values that it requests,"
    },
    {
      "Time_Start": 567.92,
      "Time_End": 572.36,
      "Text": " which is the NGC MFA, and it's a bit of a special one."
    },
    {
      "Time_Start": 572.36,
      "Time_End": 577.36,
      "Text": " You don't see that much in other flows, but basically, NGC stands for Next Generation"
    },
    {
      "Time_Start": 577.4,
      "Time_End": 578.4,
      "Text": " Credentials."
    },
    {
      "Time_Start": 578.4,
      "Time_End": 583.8000000000001,
      "Text": " This is the internal name that Microsoft uses for basically passwordless credentials, and"
    },
    {
      "Time_Start": 583.8000000000001,
      "Time_End": 589.48,
      "Text": " if there is the requirement to authenticate with NGC MFA, it means that the user should"
    },
    {
      "Time_Start": 589.48,
      "Time_End": 594.92,
      "Text": " be doing a fresh MFA authentication, because normally, MFA is cached either in the browser"
    },
    {
      "Time_Start": 594.92,
      "Time_End": 602.84,
      "Text": " session or on the device, but if Azure AD sees that the process needs NGC MFA, it will"
    },
    {
      "Time_Start": 602.84,
      "Time_End": 608.72,
      "Text": " re-prompt the user for a fresh MFA to make sure that the user has access to their MFA"
    },
    {
      "Time_Start": 608.72,
      "Time_End": 613.88,
      "Text": " methods, and this is reflected as a claim in the access tokens that are issued, so if"
    },
    {
      "Time_Start": 613.88,
      "Time_End": 619.12,
      "Text": " you decode this, then you see that I, in this case, authenticated with the passwords, with"
    },
    {
      "Time_Start": 619.12,
      "Time_End": 623.9200000000001,
      "Text": " the key, and also with multi-factor authentication, and with this NGC MFA, which indicates that"
    },
    {
      "Time_Start": 623.9200000000001,
      "Time_End": 628.5600000000001,
      "Text": " I have a fresh multi-factor authentication."
    },
    {
      "Time_Start": 628.5600000000001,
      "Time_End": 634.48,
      "Text": " So in order to provision a Windows Hello for Business key, there's a few requirements,"
    },
    {
      "Time_Start": 634.48,
      "Time_End": 639.4000000000001,
      "Text": " so you cannot just do that with any token, it needs to be specifically a token that was"
    },
    {
      "Time_Start": 639.4000000000001,
      "Time_End": 645.48,
      "Text": " issued to an Azure AD joint registered device, so that means that it should originate from"
    },
    {
      "Time_Start": 645.48,
      "Time_End": 651.2,
      "Text": " an existing primary fresh token, and that the device ID is basically in the token."
    },
    {
      "Time_Start": 651.2,
      "Time_End": 656.2800000000001,
      "Text": " It should also contain the NGC MFA claim, which indicates that a recent MFA was performed,"
    },
    {
      "Time_Start": 656.28,
      "Time_End": 662.0,
      "Text": " I think it's around 10 minutes, and the audience should be the device registration service,"
    },
    {
      "Time_Start": 662.0,
      "Time_End": 667.24,
      "Text": " because that's basically the end point where this key provisioning takes place."
    },
    {
      "Time_Start": 667.24,
      "Time_End": 672.0799999999999,
      "Text": " Now the provisioning of a Windows Hello for Business key is, I expected this to be complex,"
    },
    {
      "Time_Start": 672.0799999999999,
      "Time_End": 679.12,
      "Text": " but it's really simple, it's just a post request with a JSON, with here's my public key, please"
    },
    {
      "Time_Start": 679.12,
      "Time_End": 684.68,
      "Text": " provision this, of course it also includes this access token for authentication, but"
    },
    {
      "Time_Start": 684.6800000000001,
      "Time_End": 690.2,
      "Text": " apart from that, it's just a post like, here's the public key, good luck with it."
    },
    {
      "Time_Start": 690.2,
      "Time_End": 698.0400000000001,
      "Text": " The response is equally simple, there's this KRCTX, this is not used in most flavors, I"
    },
    {
      "Time_Start": 698.0400000000001,
      "Time_End": 704.0400000000001,
      "Text": " think you need this for certificate-based or hybrid scenarios basically, but it basically"
    },
    {
      "Time_Start": 704.0400000000001,
      "Time_End": 708.8800000000001,
      "Text": " says okay, I've registered your key, and everything is fine."
    },
    {
      "Time_Start": 708.8800000000001,
      "Time_End": 714.6400000000001,
      "Text": " So now this Windows Hello for Business key is registered, and it can be used to authenticate,"
    },
    {
      "Time_Start": 714.64,
      "Time_End": 719.92,
      "Text": " and Windows will do that to obtain a primary refresh token that's basically backed by this"
    },
    {
      "Time_Start": 719.92,
      "Time_End": 727.56,
      "Text": " key, so it will send a post request to the token end point containing some JSON web token"
    },
    {
      "Time_Start": 727.56,
      "Time_End": 733.08,
      "Text": " data basically, so we see a lot of encoded stuff here, and if we decode that, then we"
    },
    {
      "Time_Start": 733.08,
      "Time_End": 739.24,
      "Text": " see that it contains a JSON web token, so this is a signed request basically, to prove"
    },
    {
      "Time_Start": 739.24,
      "Time_End": 743.4,
      "Text": " that it came from the device, it contains the device certificate in the header, so that"
    },
    {
      "Time_Start": 743.4,
      "Time_End": 750.12,
      "Text": " Azure AD knows which device made this request, and then in the body it shows several parts"
    },
    {
      "Time_Start": 750.12,
      "Time_End": 755.76,
      "Text": " as well, so we have the request nonce, this is a very common occurrence when you see primary"
    },
    {
      "Time_Start": 755.76,
      "Time_End": 760.84,
      "Text": " refresh tokens being used, it always uses this nonce to basically prevent replay attacks,"
    },
    {
      "Time_Start": 760.84,
      "Time_End": 766.04,
      "Text": " because the nonce expires after a few minutes, we see the username that's authenticating,"
    },
    {
      "Time_Start": 766.04,
      "Time_End": 771.28,
      "Text": " and we see something that's called an assertion, and here we have another JSON web token, so"
    },
    {
      "Time_Start": 771.28,
      "Time_End": 776.56,
      "Text": " there's a JSON web token in a JSON web token, and this whole payload is basically signed"
    },
    {
      "Time_Start": 776.56,
      "Time_End": 781.3199999999999,
      "Text": " with the device certificate and private key, so that Azure AD can validate it's actually"
    },
    {
      "Time_Start": 781.3199999999999,
      "Time_End": 789.04,
      "Text": " from the device, and if we decode this assertion, so we have another signed payload, and this"
    },
    {
      "Time_Start": 789.04,
      "Time_End": 793.36,
      "Text": " one is signed with the private key of the Windows low for business key that we just"
    },
    {
      "Time_Start": 793.36,
      "Time_End": 799.12,
      "Text": " provisioned, so we see in the header, we see the key ID that was used, so that Azure AD"
    },
    {
      "Time_Start": 799.12,
      "Time_End": 805.5600000000001,
      "Text": " can look up the key, and the usage is NGC to indicate we're using credentials, and in"
    },
    {
      "Time_Start": 805.5600000000001,
      "Time_End": 812.68,
      "Text": " the payload you see some variables again, so the user that is authenticating the audience,"
    },
    {
      "Time_Start": 812.68,
      "Time_End": 818.12,
      "Text": " which is the tenant ID, and you see some issued at expiry times, basically to prevent replay"
    },
    {
      "Time_Start": 818.12,
      "Time_End": 825.64,
      "Text": " attacks again, because this will obviously expire after the expiry date is gone."
    },
    {
      "Time_Start": 825.64,
      "Time_End": 826.64,
      "Text": " All right."
    },
    {
      "Time_Start": 826.64,
      "Time_End": 831.84,
      "Text": " So we send this to Azure AD, and Azure AD gives us back a primary refresh token, so"
    },
    {
      "Time_Start": 831.84,
      "Time_End": 836.12,
      "Text": " in this response, we see the refresh token, which is the primary refresh token at the"
    },
    {
      "Time_Start": 836.12,
      "Time_End": 844.6,
      "Text": " top, and we see the session key, which is basically an encrypted blob, so that the device"
    },
    {
      "Time_Start": 844.6,
      "Time_End": 848.1999999999999,
      "Text": " needs to decrypt that in order to get the session key that's needed to use the primary"
    },
    {
      "Time_Start": 848.1999999999999,
      "Time_End": 852.36,
      "Text": " refresh token, and we also see some Kerberos stuff at the bottom."
    },
    {
      "Time_Start": 852.36,
      "Time_End": 855.92,
      "Text": " We'll get into that later."
    },
    {
      "Time_Start": 855.92,
      "Time_End": 863.96,
      "Text": " So I basically emulated this flow with RhoTX, RhoTX is part of my RhoTools framework, and"
    },
    {
      "Time_Start": 863.96,
      "Time_End": 871.32,
      "Text": " RhoTX now also supports doing this key provisioning, so it can generate keys, it can request an"
    },
    {
      "Time_Start": 871.32,
      "Time_End": 877.32,
      "Text": " enrollment token with the right NGC MFA claim, and it can also request primary refresh tokens"
    },
    {
      "Time_Start": 877.32,
      "Time_End": 880.84,
      "Text": " with the private keys that are generated."
    },
    {
      "Time_Start": 880.84,
      "Time_End": 883.72,
      "Text": " So a quick demo."
    },
    {
      "Time_Start": 883.72,
      "Time_End": 888.72,
      "Text": " So basically here we start off by requesting a normal primary refresh token, so this uses"
    },
    {
      "Time_Start": 888.72,
      "Time_End": 895.08,
      "Text": " the username and password of the user, and then once we have the normal primary refresh"
    },
    {
      "Time_Start": 895.08,
      "Time_End": 902.76,
      "Text": " token, we can upgrade that with MFA, so here we have the normal primary refresh token."
    },
    {
      "Time_Start": 902.76,
      "Time_End": 909.0400000000001,
      "Text": " Now I use the PRT enrich command, so the PRT enrich command, it will prompt for the MFA"
    },
    {
      "Time_Start": 909.04,
      "Time_End": 916.5999999999999,
      "Text": " authentication on top, and I also indicate that I want to have this NGC MFA claim in"
    },
    {
      "Time_Start": 916.5999999999999,
      "Time_End": 919.36,
      "Text": " my token."
    },
    {
      "Time_Start": 919.36,
      "Time_End": 930.64,
      "Text": " So it will pop up a browser window in which we can enter the MFA code."
    },
    {
      "Time_Start": 930.64,
      "Time_End": 936.76,
      "Text": " So now we basically enrich our token with the MFA claim, and now with this access token"
    },
    {
      "Time_Start": 936.84,
      "Time_End": 943.68,
      "Text": " that I get from this, I can register this Windows hello key, so I specify the key that"
    },
    {
      "Time_Start": 943.68,
      "Time_End": 949.6,
      "Text": " it needs to be saved to, it saves the key basically on disk, so now I have generated"
    },
    {
      "Time_Start": 949.6,
      "Time_End": 957.4,
      "Text": " this key, obviously not in a TPM, but it's on my local disk, and I can also then request"
    },
    {
      "Time_Start": 957.4,
      "Time_End": 963.2,
      "Text": " a new primary refresh token, and in this case I'm getting a, I'm requesting a primary refresh"
    },
    {
      "Time_Start": 963.24,
      "Time_End": 967.5200000000001,
      "Text": " token using this private key that we just provisioned, and with this primary refresh"
    },
    {
      "Time_Start": 967.5200000000001,
      "Time_End": 974.12,
      "Text": " token I can also get some access tokens, and if we look at the access token that we get"
    },
    {
      "Time_Start": 974.12,
      "Time_End": 979.84,
      "Text": " from here, we see that the authentication methods are RSA and MFA, and this indicates"
    },
    {
      "Time_Start": 979.84,
      "Time_End": 988.36,
      "Text": " that we used a basically private key to authenticate, and also MFA, so we see that there's no PWD"
    },
    {
      "Time_Start": 988.36,
      "Time_End": 992.8000000000001,
      "Text": " claim in here, so we didn't use a password, but we used a passwordless method to authenticate."
    },
    {
      "Time_Start": 992.8000000000001,
      "Time_End": 998.1600000000001,
      "Text": " So this is how you can basically enroll a Windows hello for business key if you have"
    },
    {
      "Time_Start": 998.1600000000001,
      "Time_End": 1005.6800000000001,
      "Text": " the user credentials and the user's MFA information."
    },
    {
      "Time_Start": 1005.6800000000001,
      "Time_End": 1012.0000000000001,
      "Text": " So I dug a bit more in this, and I analyzed this whole process, and first of all, something"
    },
    {
      "Time_Start": 1012.0000000000001,
      "Time_End": 1017.6800000000001,
      "Text": " to note that the full provisioning process is controlled by the client, so you have policies"
    },
    {
      "Time_Start": 1017.6800000000001,
      "Time_End": 1022.84,
      "Text": " that you can set whether or not the client will, whether or not Windows will prompt"
    },
    {
      "Time_Start": 1022.84,
      "Time_End": 1029.0,
      "Text": " for Windows hello enrollment, but it's always possible, so even if you don't have the policy"
    },
    {
      "Time_Start": 1029.0,
      "Time_End": 1035.1200000000001,
      "Text": " enabled that your device will do it, you can still do it manually, and as a result any"
    },
    {
      "Time_Start": 1035.1200000000001,
      "Time_End": 1040.8400000000001,
      "Text": " user plus device combination in your tenant, so also if you allow people to have private"
    },
    {
      "Time_Start": 1040.8400000000001,
      "Time_End": 1047.0,
      "Text": " devices registered in your tenant, they can also be used to register Windows hello keys,"
    },
    {
      "Time_Start": 1047.0,
      "Time_End": 1051.08,
      "Text": " so even if you have an Android phone connected to your corporate thing, in theory that could"
    },
    {
      "Time_Start": 1051.08,
      "Time_End": 1060.18,
      "Text": " use Windows hello, even though Android obviously doesn't support that."
    },
    {
      "Time_Start": 1060.18,
      "Time_End": 1067.0,
      "Text": " So looking at the provisioning process again, we notice that there are two parts in this."
    },
    {
      "Time_Start": 1067.0,
      "Time_End": 1072.52,
      "Text": " Well, of course, the public key on the bottom, we can just generate ourselves, that's not"
    },
    {
      "Time_Start": 1072.52,
      "Time_End": 1077.6,
      "Text": " an issue, so the only thing that really is important here is the access token and how"
    },
    {
      "Time_Start": 1077.6,
      "Time_End": 1086.4,
      "Text": " that's checked, and it turned out that the NGC MFA was in fact not required in practice,"
    },
    {
      "Time_Start": 1086.4,
      "Time_End": 1091.68,
      "Text": " so basically we could have any token that has an MFA claim in it, and we could use that"
    },
    {
      "Time_Start": 1091.68,
      "Time_End": 1097.92,
      "Text": " to provision a new key, so if you have, if you're on a red team, you have a session on"
    },
    {
      "Time_Start": 1097.92,
      "Time_End": 1103.3600000000001,
      "Text": " a user device, or you have their cookies dumped, or you find some other way to access"
    },
    {
      "Time_Start": 1103.3600000000001,
      "Time_End": 1108.3600000000001,
      "Text": " a user's device, then with the single sign-on material that's already on the device, we"
    },
    {
      "Time_Start": 1108.3600000000001,
      "Time_End": 1116.1200000000001,
      "Text": " could basically provision a new key and use that key to provide persistence to the user."
    },
    {
      "Time_Start": 1116.1200000000001,
      "Time_End": 1122.4,
      "Text": " So just to have a schematic of this attack, imagine an attacker is running on the end"
    },
    {
      "Time_Start": 1122.4,
      "Time_End": 1127.76,
      "Text": " points, they have some low privilege access, you don't need admin access for it, you can"
    },
    {
      "Time_Start": 1127.76,
      "Time_End": 1132.84,
      "Text": " just request single sign-on data from LSS, and with that single sign-on data, you could"
    },
    {
      "Time_Start": 1132.84,
      "Time_End": 1138.92,
      "Text": " basically provision a new key, and then you would have authentication access that you"
    },
    {
      "Time_Start": 1138.92,
      "Time_End": 1144.0,
      "Text": " could use on the other device, and in this case, of course, all the credentials were"
    },
    {
      "Time_Start": 1144.0,
      "Time_End": 1149.2,
      "Text": " protected by the TPM, so this device has a TPM, everything is secure in there, we cannot"
    },
    {
      "Time_Start": 1149.2,
      "Time_End": 1154.72,
      "Text": " steal it from the TPM, but we can simply request the single sign-on data and provision a new"
    },
    {
      "Time_Start": 1154.76,
      "Time_End": 1156.84,
      "Text": " key that we control ourselves."
    },
    {
      "Time_Start": 1156.84,
      "Time_End": 1161.88,
      "Text": " So the whole TPM protection in this case doesn't really matter if we can just provision a new"
    },
    {
      "Time_Start": 1161.88,
      "Time_End": 1165.0,
      "Text": " key, basically."
    },
    {
      "Time_Start": 1165.0,
      "Time_End": 1170.4,
      "Text": " So this is how that looks, in this case I'm using rowtoken, there's also other ways to"
    },
    {
      "Time_Start": 1170.4,
      "Time_End": 1174.72,
      "Text": " do this, there's some beacon object files for Cobalt Strike if you want to do this,"
    },
    {
      "Time_Start": 1174.72,
      "Time_End": 1181.28,
      "Text": " basically request the single sign-on data, and then you can use that to get a token,"
    },
    {
      "Time_Start": 1181.28,
      "Time_End": 1186.96,
      "Text": " so you can get a token for the device registration service using rowtx, for example, and this"
    },
    {
      "Time_Start": 1186.96,
      "Time_End": 1193.76,
      "Text": " PRT cookie, as it's called, and then with this access token, you can basically provision"
    },
    {
      "Time_Start": 1193.76,
      "Time_End": 1199.6399999999999,
      "Text": " a new Windows Hello for Business key, and now we have a key that's saved on disk, and"
    },
    {
      "Time_Start": 1199.6399999999999,
      "Time_End": 1207.28,
      "Text": " we can just request new primary refresh tokens that are valid for this user, so now we have"
    },
    {
      "Time_Start": 1207.28,
      "Time_End": 1213.8799999999999,
      "Text": " persistent access to the user's identity, even if we lose access to the device, basically."
    },
    {
      "Time_Start": 1213.8799999999999,
      "Time_End": 1219.3999999999999,
      "Text": " So the TLDR, basically it was possible to overwrite the registered Windows Hello for"
    },
    {
      "Time_Start": 1219.3999999999999,
      "Time_End": 1225.72,
      "Text": " Business key from a device using a single sign-on, this kind of defeats the whole, the"
    },
    {
      "Time_Start": 1225.72,
      "Time_End": 1229.68,
      "Text": " key is in the TPM and you cannot extract it, it doesn't matter if you can just overwrite"
    },
    {
      "Time_Start": 1229.68,
      "Time_End": 1234.8,
      "Text": " it with a new key, so this is a nice way of having a persistency, and also Windows Hello"
    },
    {
      "Time_Start": 1234.8,
      "Time_End": 1241.68,
      "Text": " for Business key can be used with any device, so even if the key was technically provisioned"
    },
    {
      "Time_Start": 1241.68,
      "Time_End": 1247.1599999999999,
      "Text": " on this device, any other device could also use that private key."
    },
    {
      "Time_Start": 1247.1599999999999,
      "Time_End": 1252.96,
      "Text": " It's a feature, it's required in some scenarios, so it's not necessarily needed to use the"
    },
    {
      "Time_Start": 1252.96,
      "Time_End": 1256.52,
      "Text": " specific device identity the key is linked to."
    },
    {
      "Time_Start": 1256.52,
      "Time_End": 1260.48,
      "Text": " With some tricks, you can also restore the original key so that the user's device actually"
    },
    {
      "Time_Start": 1260.48,
      "Time_End": 1264.72,
      "Text": " keeps working, because of course if you overwrite the key, then the original device wouldn't"
    },
    {
      "Time_Start": 1264.72,
      "Time_End": 1268.16,
      "Text": " work anymore."
    },
    {
      "Time_Start": 1268.16,
      "Time_End": 1272.96,
      "Text": " So now we looked at the end point perspective, let's have a look from the perspective of"
    },
    {
      "Time_Start": 1272.96,
      "Time_End": 1273.96,
      "Text": " Azure AD."
    },
    {
      "Time_Start": 1273.96,
      "Time_End": 1280.88,
      "Text": " So if we look at Azure AD, we can see the ways that Azure AD basically stores Windows"
    },
    {
      "Time_Start": 1280.88,
      "Time_End": 1286.6000000000001,
      "Text": " Hello for Business keys, in this case we're using the graph.windows.net API, the internal"
    },
    {
      "Time_Start": 1286.6000000000001,
      "Time_End": 1292.28,
      "Text": " version, and this basically gives us a property called searchable device key, and here we"
    },
    {
      "Time_Start": 1292.28,
      "Time_End": 1298.44,
      "Text": " just see the public keys that the user has registered, so we can list all the Windows"
    },
    {
      "Time_Start": 1298.44,
      "Time_End": 1304.68,
      "Text": " Hello for Business keys, we also see the device that they were provisioned to."
    },
    {
      "Time_Start": 1304.68,
      "Time_End": 1309.96,
      "Text": " And it turns out that users can actually modify their own searchable device keys attributes,"
    },
    {
      "Time_Start": 1309.96,
      "Time_End": 1315.96,
      "Text": " so if you have permissions, or if you have access to a user account, you can just basically"
    },
    {
      "Time_Start": 1315.96,
      "Time_End": 1321.6,
      "Text": " inject a new key in here without any specific requirements, so you don't need MFA to do"
    },
    {
      "Time_Start": 1321.64,
      "Time_End": 1328.44,
      "Text": " this, as long as there is no specific policy that requires you to perform MFA, so if you"
    },
    {
      "Time_Start": 1328.44,
      "Time_End": 1333.2,
      "Text": " have, if there is no policy that requires MFA in all cases, then it would be possible"
    },
    {
      "Time_Start": 1333.2,
      "Time_End": 1338.5600000000002,
      "Text": " to bypass MFA via this case, so this depends a bit on the conditional access, but there"
    },
    {
      "Time_Start": 1338.5600000000002,
      "Time_End": 1344.1200000000001,
      "Text": " is no specific requirements, other than having a token for this specific API."
    },
    {
      "Time_Start": 1344.1200000000001,
      "Time_End": 1349.2400000000002,
      "Text": " You also needed to have a device in the tenant, that would be a legitimate device, or a device"
    },
    {
      "Time_Start": 1349.24,
      "Time_End": 1354.48,
      "Text": " that the attacker basically registers, and usually anyone is allowed to register devices,"
    },
    {
      "Time_Start": 1354.48,
      "Time_End": 1359.36,
      "Text": " and apart from that, just with a valid access token, we can provision this new key, so that"
    },
    {
      "Time_Start": 1359.36,
      "Time_End": 1362.28,
      "Text": " was pretty easy."
    },
    {
      "Time_Start": 1362.28,
      "Time_End": 1368.04,
      "Text": " There's also a command in Rotex to basically generate these keys, it will just print the"
    },
    {
      "Time_Start": 1368.04,
      "Time_End": 1376.1200000000001,
      "Text": " JSON that you need to add, and then with a simple HTTP fetch request in this case, so"
    },
    {
      "Time_Start": 1376.1200000000001,
      "Time_End": 1382.44,
      "Text": " we turn the get into a fetch, we're just inserting a new RSA public key in this list"
    },
    {
      "Time_Start": 1382.44,
      "Time_End": 1387.92,
      "Text": " of Windows Hello for Business keys, and then we can also authenticate as the user, using"
    },
    {
      "Time_Start": 1387.92,
      "Time_End": 1391.7800000000002,
      "Text": " multi-factor authentication credentials."
    },
    {
      "Time_Start": 1391.7800000000002,
      "Time_End": 1398.0400000000002,
      "Text": " So one of the attack methods for this is device code phishing, so I'm not sure if you're all"
    },
    {
      "Time_Start": 1398.0400000000002,
      "Time_End": 1402.96,
      "Text": " familiar with this, but basically device code phishing relies on initiating the flow on"
    },
    {
      "Time_Start": 1402.96,
      "Time_End": 1408.32,
      "Text": " one host, and then have the user enter the code on a different device, so the attacker"
    },
    {
      "Time_Start": 1408.32,
      "Time_End": 1414.3600000000001,
      "Text": " would initiate the device code flow from their device by talking to Azure AD, and then phish"
    },
    {
      "Time_Start": 1414.3600000000001,
      "Time_End": 1420.2,
      "Text": " the user basically into authenticating with that specific device code, and if they do"
    },
    {
      "Time_Start": 1420.2,
      "Time_End": 1424.1200000000001,
      "Text": " that, then it will actually be the attacker's device that is authenticated."
    },
    {
      "Time_Start": 1424.1200000000001,
      "Time_End": 1429.0,
      "Text": " So in this case, the attacker received the access token, and with that access token,"
    },
    {
      "Time_Start": 1429.0,
      "Time_End": 1433.44,
      "Text": " the attacker can talk with the various APIs."
    },
    {
      "Time_Start": 1433.44,
      "Time_End": 1438.28,
      "Text": " So with that access token, the attacker could just register a new device basically, and"
    },
    {
      "Time_Start": 1438.28,
      "Time_End": 1443.72,
      "Text": " also register a Windows Hello for Business key for the user, and then they have persistent"
    },
    {
      "Time_Start": 1443.72,
      "Time_End": 1449.56,
      "Text": " passwordless credentials, which count as MFA credentials as well, and they also meet basically"
    },
    {
      "Time_Start": 1449.56,
      "Time_End": 1455.44,
      "Text": " the requirements of having the strongest MFA level that there is, because by default, Windows"
    },
    {
      "Time_Start": 1455.44,
      "Time_End": 1461.2,
      "Text": " Hello for Business is considered one of the strongest MFA methods there is."
    },
    {
      "Time_Start": 1461.2,
      "Time_End": 1467.3200000000002,
      "Text": " So there's some alternative scenarios here, so I already mentioned device code phishing."
    },
    {
      "Time_Start": 1467.3200000000002,
      "Time_End": 1470.1200000000001,
      "Text": " Of course, with normal credential phishing, that also works."
    },
    {
      "Time_Start": 1470.1200000000001,
      "Time_End": 1474.8400000000001,
      "Text": " If you use a tool like Epigenix, you could also do this."
    },
    {
      "Time_Start": 1474.8400000000001,
      "Time_End": 1478.16,
      "Text": " If you have temporary access to someone's device that they left unlocked, you could"
    },
    {
      "Time_Start": 1478.16,
      "Time_End": 1483.0800000000002,
      "Text": " use this with single sign-on tokens, and also a neat thing is that if you have an admin"
    },
    {
      "Time_Start": 1483.08,
      "Time_End": 1487.96,
      "Text": " account that's allowed to basically modify other users, such as a user administrator"
    },
    {
      "Time_Start": 1487.96,
      "Time_End": 1493.4399999999998,
      "Text": " or a global administrator, these users could also like provision keys on other users."
    },
    {
      "Time_Start": 1493.4399999999998,
      "Time_End": 1500.08,
      "Text": " So then you could basically do lateral movements between users using these passwordless credentials,"
    },
    {
      "Time_Start": 1500.08,
      "Time_End": 1504.1999999999998,
      "Text": " and we'll get into that a bit more in a bit."
    },
    {
      "Time_Start": 1504.1999999999998,
      "Time_End": 1508.72,
      "Text": " So we looked at the endpoint, we looked at Azure AD, and the last one I want to look"
    },
    {
      "Time_Start": 1508.72,
      "Time_End": 1514.32,
      "Text": " at is some hybrid scenarios."
    },
    {
      "Time_Start": 1514.32,
      "Time_End": 1519.64,
      "Text": " So if we look at how Windows Hello for Business works in a hybrid setup, basically there's"
    },
    {
      "Time_Start": 1519.64,
      "Time_End": 1520.88,
      "Text": " three methods."
    },
    {
      "Time_Start": 1520.88,
      "Time_End": 1524.8,
      "Text": " The first one is Cloud Kerberos Trusts, the second is Hybrid Key Trusts, and the third"
    },
    {
      "Time_Start": 1524.8,
      "Time_End": 1527.04,
      "Text": " is Hybrid Certificate Trusts."
    },
    {
      "Time_Start": 1527.04,
      "Time_End": 1532.52,
      "Text": " I've only really looked much at the Cloud Kerberos Trusts, first because it contains"
    },
    {
      "Time_Start": 1532.52,
      "Time_End": 1537.4,
      "Text": " Kerberos, and second because it is the Microsoft's recommended way of deploying it."
    },
    {
      "Time_Start": 1537.4,
      "Time_End": 1542.64,
      "Text": " So it's the simplest method, which has the least dependencies on-prem, and like for"
    },
    {
      "Time_Start": 1542.64,
      "Time_End": 1546.88,
      "Text": " Hybrid Key Trusts and Certificate Trusts, you need to have a more complex setup."
    },
    {
      "Time_Start": 1546.88,
      "Time_End": 1552.0,
      "Text": " But the Cloud Kerberos Trusts, you just need to run some PowerShell scripts, install some"
    },
    {
      "Time_Start": 1552.0,
      "Time_End": 1555.0,
      "Text": " GPOs, and then it works, basically."
    },
    {
      "Time_Start": 1555.0,
      "Time_End": 1559.8000000000002,
      "Text": " So Windows Hello for Business Cloud Kerberos Trust is quite an interesting concept."
    },
    {
      "Time_Start": 1559.8000000000002,
      "Time_End": 1565.76,
      "Text": " So we start with Active Directory and then Azure AD, and basically once you set up the"
    },
    {
      "Time_Start": 1565.92,
      "Time_End": 1571.96,
      "Text": " Cloud Kerberos Trust, then it creates like a virtual read-only domain controller in Active"
    },
    {
      "Time_Start": 1571.96,
      "Time_End": 1572.96,
      "Text": " Directory."
    },
    {
      "Time_Start": 1572.96,
      "Time_End": 1578.72,
      "Text": " I mean virtual because there's no real server, of course, behind this, it's just an object."
    },
    {
      "Time_Start": 1578.72,
      "Time_End": 1583.4,
      "Text": " And basically the Kerberos keys are shared between Active Directory and also between"
    },
    {
      "Time_Start": 1583.4,
      "Time_End": 1584.4,
      "Text": " Azure AD."
    },
    {
      "Time_Start": 1584.4,
      "Time_End": 1588.96,
      "Text": " So in this case, you're kind of setting up a trust between Active Directory and Azure"
    },
    {
      "Time_Start": 1588.96,
      "Time_End": 1589.96,
      "Text": " AD."
    },
    {
      "Time_Start": 1590.48,
      "Time_End": 1594.88,
      "Text": " And now when a user authenticates with Windows Hello for Business authentication to Azure"
    },
    {
      "Time_Start": 1594.88,
      "Time_End": 1601.6000000000001,
      "Text": " AD, then Azure AD can provide some Kerberos tickets, which is called a partial TGT."
    },
    {
      "Time_Start": 1601.6000000000001,
      "Time_End": 1607.3600000000001,
      "Text": " So Azure AD can send a TGT for the user, but obviously Azure AD doesn't know like all the"
    },
    {
      "Time_Start": 1607.3600000000001,
      "Time_End": 1613.6000000000001,
      "Text": " information about it, but it sends a partial TGT that's signed with the Kerberos key of"
    },
    {
      "Time_Start": 1613.6000000000001,
      "Time_End": 1617.06,
      "Text": " the virtual read-only domain controller."
    },
    {
      "Time_Start": 1617.06,
      "Time_End": 1621.98,
      "Text": " And then the user can basically talk to Active Directory and exchange this for a full ticket"
    },
    {
      "Time_Start": 1621.98,
      "Time_End": 1624.62,
      "Text": " printing ticket."
    },
    {
      "Time_Start": 1624.62,
      "Time_End": 1631.1399999999999,
      "Text": " A nice part of this is also that the user can obtain the NT hash for the original account."
    },
    {
      "Time_Start": 1631.1399999999999,
      "Time_End": 1637.06,
      "Text": " Because of course, if you use certificates to authenticate, then the endpoint doesn't"
    },
    {
      "Time_Start": 1637.06,
      "Time_End": 1640.98,
      "Text": " have the password because there's no password entered."
    },
    {
      "Time_Start": 1640.98,
      "Time_End": 1646.86,
      "Text": " So it needs to somehow have the NT hash to still do legacy authentication with NTLM,"
    },
    {
      "Time_Start": 1646.8600000000001,
      "Time_End": 1649.7400000000002,
      "Text": " for example."
    },
    {
      "Time_Start": 1649.7400000000002,
      "Time_End": 1655.9,
      "Text": " So having a look at how this works in practice, we have this Azure AD Kerberos domain controller,"
    },
    {
      "Time_Start": 1655.9,
      "Time_End": 1659.5000000000002,
      "Text": " which is the virtual read-only domain controller."
    },
    {
      "Time_Start": 1659.5000000000002,
      "Time_End": 1665.5000000000002,
      "Text": " So this is not a full domain controller, but it's RODC basically."
    },
    {
      "Time_Start": 1665.5000000000002,
      "Time_End": 1670.7,
      "Text": " And when we request a PRT using the Windows Hello for Business keys, we get back a partial"
    },
    {
      "Time_Start": 1670.7,
      "Time_End": 1674.9,
      "Text": " TGT that you can exchange for a full TGT."
    },
    {
      "Time_Start": 1674.9,
      "Time_End": 1679.94,
      "Text": " And with the full TGT, we can access any resources in Active Directory, basically."
    },
    {
      "Time_Start": 1679.94,
      "Time_End": 1682.2,
      "Text": " Of course, it only works for hybrid accounts."
    },
    {
      "Time_Start": 1682.2,
      "Time_End": 1686.9,
      "Text": " If you have a account that only exists in Azure AD, then it doesn't exist on-prem."
    },
    {
      "Time_Start": 1686.9,
      "Time_End": 1692.02,
      "Text": " So you cannot get a TGT for that account, no matter what you try."
    },
    {
      "Time_Start": 1692.02,
      "Time_End": 1693.7,
      "Text": " But it basically looks like this."
    },
    {
      "Time_Start": 1693.7,
      "Time_End": 1698.06,
      "Text": " So we previously saw it's getting a primary refresh token."
    },
    {
      "Time_Start": 1698.34,
      "Time_End": 1706.5,
      "Text": " Now, if you have the Kerberos, Cloud Kerberos setup, then it will also contain a TGT underscore"
    },
    {
      "Time_Start": 1706.5,
      "Time_End": 1707.94,
      "Text": " AD."
    },
    {
      "Time_Start": 1707.94,
      "Time_End": 1714.82,
      "Text": " And this is basically the partial TGT that can be used to talk to Active Directory."
    },
    {
      "Time_Start": 1714.82,
      "Time_End": 1717.6599999999999,
      "Text": " And we'll look at how to exchange that later."
    },
    {
      "Time_Start": 1717.6599999999999,
      "Time_End": 1721.4199999999998,
      "Text": " But basically, this allowed some interesting properties."
    },
    {
      "Time_Start": 1721.46,
      "Time_End": 1728.54,
      "Text": " So because user administrators or higher roles basically could provision keys on other users,"
    },
    {
      "Time_Start": 1728.54,
      "Time_End": 1732.8600000000001,
      "Text": " it was possible to move laterally if you have admin privileges in Azure AD."
    },
    {
      "Time_Start": 1732.8600000000001,
      "Time_End": 1734.3400000000001,
      "Text": " And there are some restrictions that apply."
    },
    {
      "Time_Start": 1734.3400000000001,
      "Time_End": 1739.5,
      "Text": " So Azure AD is quite strict on which admin roles can modify other users."
    },
    {
      "Time_Start": 1739.5,
      "Time_End": 1744.02,
      "Text": " But any non-protected user was basically vulnerable to this."
    },
    {
      "Time_Start": 1744.02,
      "Time_End": 1748.1000000000001,
      "Text": " So if you had access to a user administrator account, you could provision keys on any other"
    },
    {
      "Time_Start": 1748.1000000000001,
      "Time_End": 1750.9,
      "Text": " user and authenticate as them."
    },
    {
      "Time_Start": 1750.9,
      "Time_End": 1755.8600000000001,
      "Text": " And it's also in this way possible to move between hybrid identities."
    },
    {
      "Time_Start": 1755.8600000000001,
      "Time_End": 1762.74,
      "Text": " So if you provision a key on someone else's account, then you can use that to get a PRT."
    },
    {
      "Time_Start": 1762.74,
      "Time_End": 1766.66,
      "Text": " You can use that to get a TGT on their behalf."
    },
    {
      "Time_Start": 1766.66,
      "Time_End": 1772.3000000000002,
      "Text": " And you can basically use that to authenticate in Active Directory as well."
    },
    {
      "Time_Start": 1772.3000000000002,
      "Time_End": 1777.3000000000002,
      "Text": " The only users that it doesn't work for are domain admins and some other basically tier"
    },
    {
      "Time_Start": 1777.4199999999998,
      "Time_End": 1782.18,
      "Text": " 0 equivalent accounts because these are basically protected accounts."
    },
    {
      "Time_Start": 1782.18,
      "Time_End": 1788.5,
      "Text": " And the virtual read-only domain controller doesn't have privileges to get keys for these"
    },
    {
      "Time_Start": 1788.5,
      "Time_End": 1789.74,
      "Text": " users."
    },
    {
      "Time_Start": 1789.74,
      "Time_End": 1792.58,
      "Text": " So it's not allowed to give out TGTs on those."
    },
    {
      "Time_Start": 1792.58,
      "Time_End": 1794.34,
      "Text": " So there's some restrictions."
    },
    {
      "Time_Start": 1794.34,
      "Time_End": 1800.54,
      "Text": " But for normal users, this would definitely work between any identity."
    },
    {
      "Time_Start": 1800.54,
      "Time_End": 1804.34,
      "Text": " The only additional requirement is that you would have line of sight to a domain controller,"
    },
    {
      "Time_Start": 1804.34,
      "Time_End": 1805.34,
      "Text": " of course."
    },
    {
      "Time_Start": 1805.38,
      "Time_End": 1809.0200000000002,
      "Text": " But if you only have access to Azure AD and you don't have any access to the on-prem domain"
    },
    {
      "Time_Start": 1809.0200000000002,
      "Time_End": 1811.38,
      "Text": " controllers, then this will not work."
    },
    {
      "Time_Start": 1811.38,
      "Time_End": 1817.8200000000002,
      "Text": " So you will need to be able to talk to a domain controller in order to capitalize on this"
    },
    {
      "Time_Start": 1817.8200000000002,
      "Time_End": 1819.8200000000002,
      "Text": " and get the TGTs."
    },
    {
      "Time_Start": 1819.8200000000002,
      "Time_End": 1822.42,
      "Text": " All right."
    },
    {
      "Time_Start": 1822.42,
      "Time_End": 1826.2200000000003,
      "Text": " So just having a look at how this works in practice."
    },
    {
      "Time_Start": 1826.2200000000003,
      "Time_End": 1833.2200000000003,
      "Text": " So if I authenticate as a user that is a hybrid user and has a Windows Hello for Business"
    },
    {
      "Time_Start": 1833.3,
      "Time_End": 1834.58,
      "Text": " key provisions."
    },
    {
      "Time_Start": 1834.58,
      "Time_End": 1840.22,
      "Text": " So I'm using this hybrid at the hybrid of your cloud domain with the Windows Hello key"
    },
    {
      "Time_Start": 1840.22,
      "Time_End": 1842.46,
      "Text": " that I registered for this user."
    },
    {
      "Time_Start": 1842.46,
      "Time_End": 1847.3,
      "Text": " And I'm also using a device identity because you need a device identity in order to do"
    },
    {
      "Time_Start": 1847.3,
      "Time_End": 1849.3,
      "Text": " this authentication."
    },
    {
      "Time_Start": 1849.3,
      "Time_End": 1850.42,
      "Text": " I get a session key."
    },
    {
      "Time_Start": 1850.42,
      "Time_End": 1855.82,
      "Text": " I get a primary refresh token that's basically saved on disk."
    },
    {
      "Time_Start": 1855.82,
      "Time_End": 1861.42,
      "Text": " Then I can extract this TGT from the PRT file."
    },
    {
      "Time_Start": 1861.42,
      "Time_End": 1863.9,
      "Text": " I can do this with the load ticket.py."
    },
    {
      "Time_Start": 1863.9,
      "Time_End": 1866.38,
      "Text": " There's also a different tool that can do this."
    },
    {
      "Time_Start": 1866.38,
      "Time_End": 1867.94,
      "Text": " I'll get into that later."
    },
    {
      "Time_Start": 1867.94,
      "Time_End": 1873.7,
      "Text": " But basically, I can extract the TGT from the JSON into a C cache and that I can use"
    },
    {
      "Time_Start": 1873.7,
      "Time_End": 1876.26,
      "Text": " with the normal impact tools."
    },
    {
      "Time_Start": 1876.26,
      "Time_End": 1886.3400000000001,
      "Text": " So in this case, the get-st.py uses the service ticket requests, but with the target's KBTGT."
    },
    {
      "Time_Start": 1886.3400000000001,
      "Time_End": 1892.9800000000002,
      "Text": " So it's basically requesting a full TGT based on the partial TGT that we get."
    },
    {
      "Time_Start": 1892.9800000000002,
      "Time_End": 1898.7400000000002,
      "Text": " And that saves the full TGT in the hybrid.ccache file."
    },
    {
      "Time_Start": 1898.7400000000002,
      "Time_End": 1902.8200000000002,
      "Text": " So now we have a full TGT for this user."
    },
    {
      "Time_Start": 1902.8200000000002,
      "Time_End": 1903.9800000000002,
      "Text": " So what about NTLM?"
    },
    {
      "Time_Start": 1903.9800000000002,
      "Time_End": 1909.7,
      "Text": " So of course, if you use Kerberos and you don't have a password, then Windows will not"
    },
    {
      "Time_Start": 1909.7,
      "Time_End": 1913.7400000000002,
      "Text": " have the NT hash because it cannot calculate this."
    },
    {
      "Time_Start": 1913.74,
      "Time_End": 1920.7,
      "Text": " So basically, Microsoft added a new method to their Kerberos implementation, which allows"
    },
    {
      "Time_Start": 1920.7,
      "Time_End": 1926.7,
      "Text": " the protocol to basically recover the NT hash during the TGT upgrades."
    },
    {
      "Time_Start": 1926.7,
      "Time_End": 1929.9,
      "Text": " This is documented in MS-KEIL."
    },
    {
      "Time_Start": 1929.9,
      "Time_End": 1932.1,
      "Text": " And basically, it looks a bit like this."
    },
    {
      "Time_Start": 1932.1,
      "Time_End": 1935.06,
      "Text": " So this is the TGSREC."
    },
    {
      "Time_Start": 1935.06,
      "Time_End": 1939.82,
      "Text": " So basically, this is the request to upgrade our partial TGT to a full TGT."
    },
    {
      "Time_Start": 1939.82,
      "Time_End": 1942.34,
      "Text": " We see that the target here is the KBTGT."
    },
    {
      "Time_Start": 1942.3400000000001,
      "Time_End": 1947.9800000000002,
      "Text": " So that's how we know that this is a request to get a ticket granting ticket."
    },
    {
      "Time_Start": 1947.9800000000002,
      "Time_End": 1951.14,
      "Text": " As pre-authentication data, we have our partial TGT."
    },
    {
      "Time_Start": 1951.14,
      "Time_End": 1957.14,
      "Text": " So this proved to the domain controller that we are, in fact, authenticated as that account."
    },
    {
      "Time_Start": 1957.14,
      "Time_End": 1963.0600000000002,
      "Text": " And there's also this pre-authentication data unknown with type 161."
    },
    {
      "Time_Start": 1963.0600000000002,
      "Time_End": 1970.18,
      "Text": " And if you read the documentation, basically, this is the request to get the NT hash back"
    },
    {
      "Time_Start": 1970.18,
      "Time_End": 1972.94,
      "Text": " for this account."
    },
    {
      "Time_Start": 1972.94,
      "Time_End": 1975.6200000000001,
      "Text": " So this only works in some limited scenarios."
    },
    {
      "Time_Start": 1975.6200000000001,
      "Time_End": 1980.1000000000001,
      "Text": " I don't know exactly what the requirements are, but you cannot do this with a regular"
    },
    {
      "Time_Start": 1980.1000000000001,
      "Time_End": 1982.18,
      "Text": " TGT by just including a structure."
    },
    {
      "Time_Start": 1982.18,
      "Time_End": 1988.02,
      "Text": " So it has to be a partial one, and I think also from a read-only domain controller account."
    },
    {
      "Time_Start": 1988.02,
      "Time_End": 1989.78,
      "Text": " So there's some restrictions on this."
    },
    {
      "Time_Start": 1989.78,
      "Time_End": 1995.22,
      "Text": " But basically, if you use this legitimate way with Azure AD Kerberos, then you will"
    },
    {
      "Time_Start": 1995.22,
      "Time_End": 1999.14,
      "Text": " get a TGT upgrade reply."
    },
    {
      "Time_Start": 1999.14,
      "Time_End": 2000.5800000000002,
      "Text": " This is a normal reply."
    },
    {
      "Time_Start": 2000.5800000000002,
      "Time_End": 2005.7800000000002,
      "Text": " You have the encrypted part here that's encrypted basically with the session key."
    },
    {
      "Time_Start": 2005.7800000000002,
      "Time_End": 2009.22,
      "Text": " So the user can decrypt this."
    },
    {
      "Time_Start": 2009.22,
      "Time_End": 2012.74,
      "Text": " And in this part, we have the NT hash."
    },
    {
      "Time_Start": 2012.74,
      "Time_End": 2014.5400000000002,
      "Text": " So that's the one here."
    },
    {
      "Time_Start": 2014.5400000000002,
      "Time_End": 2017.0200000000002,
      "Text": " And this contains the NT hash for this account."
    },
    {
      "Time_Start": 2017.0200000000002,
      "Time_End": 2019.5400000000002,
      "Text": " So then Windows can load that into LSS."
    },
    {
      "Time_Start": 2019.5400000000002,
      "Time_End": 2024.5800000000002,
      "Text": " And then it can also do NTLM authentication to any resources that don't support Kerberos."
    },
    {
      "Time_Start": 2024.5800000000002,
      "Time_End": 2028.66,
      "Text": " Of course, there's also a tool for this."
    },
    {
      "Time_Start": 2028.66,
      "Time_End": 2033.18,
      "Text": " This is part of the RoadTools hybrid repository."
    },
    {
      "Time_Start": 2033.18,
      "Time_End": 2039.22,
      "Text": " By the way, most of this is based on research from Leandro Cusome, who basically looked"
    },
    {
      "Time_Start": 2039.22,
      "Time_End": 2042.3000000000002,
      "Text": " at this key list attack."
    },
    {
      "Time_Start": 2042.3000000000002,
      "Time_End": 2044.66,
      "Text": " You can also use this for some other nice attacks."
    },
    {
      "Time_Start": 2044.66,
      "Time_End": 2052.82,
      "Text": " But basically, this is the legitimate implementation to exchange a partial TGT to a full TGT and"
    },
    {
      "Time_Start": 2052.82,
      "Time_End": 2058.1,
      "Text": " also recover the NT hash of the user."
    },
    {
      "Time_Start": 2058.1,
      "Time_End": 2064.5,
      "Text": " So of course, in this case, we could laterally move between users if you have a privileged"
    },
    {
      "Time_Start": 2064.5,
      "Time_End": 2066.02,
      "Text": " enough account."
    },
    {
      "Time_Start": 2066.02,
      "Time_End": 2069.42,
      "Text": " And we could also then recover the NT hash for these users."
    },
    {
      "Time_Start": 2069.42,
      "Time_End": 2074.38,
      "Text": " And of course, you can try to crack that one or just use the NT hash to authenticate as"
    },
    {
      "Time_Start": 2074.38,
      "Time_End": 2077.2999999999997,
      "Text": " the user."
    },
    {
      "Time_Start": 2077.2999999999997,
      "Time_End": 2083.3399999999997,
      "Text": " So this also brings us to some key trust consequences, I guess."
    },
    {
      "Time_Start": 2083.3399999999997,
      "Time_End": 2087.54,
      "Text": " So if you use Kerberos key trusts, Windows Hello is not the only scenario in which you"
    },
    {
      "Time_Start": 2087.54,
      "Time_End": 2088.54,
      "Text": " would do that."
    },
    {
      "Time_Start": 2088.54,
      "Time_End": 2092.9,
      "Text": " It's also the way to have FIDO2 authentication to your on-prem domain."
    },
    {
      "Time_Start": 2092.9,
      "Time_End": 2097.18,
      "Text": " So even if a company doesn't use Windows Hello for business, they could still have Kerberos"
    },
    {
      "Time_Start": 2097.18,
      "Time_End": 2098.18,
      "Text": " key trusts."
    },
    {
      "Time_Start": 2098.18,
      "Time_End": 2105.58,
      "Text": " But this establishes basically a trust relationship from the on-prem domain towards Azure AD."
    },
    {
      "Time_Start": 2105.58,
      "Time_End": 2109.82,
      "Text": " Usually it's the other way around because the on-prem domain pushes information into"
    },
    {
      "Time_Start": 2109.82,
      "Time_End": 2110.82,
      "Text": " Azure AD."
    },
    {
      "Time_Start": 2110.82,
      "Time_End": 2118.6600000000003,
      "Text": " But in this way, basically the on-prem Active Directory trusts Azure AD to do the authentication,"
    },
    {
      "Time_Start": 2118.6600000000003,
      "Time_End": 2120.98,
      "Text": " to provide Kerberos tickets."
    },
    {
      "Time_Start": 2120.98,
      "Time_End": 2126.46,
      "Text": " And Azure AD basically manages the keys of this breach-only domain controller that's"
    },
    {
      "Time_Start": 2126.46,
      "Time_End": 2127.82,
      "Text": " stored in Active Directory."
    },
    {
      "Time_Start": 2127.82,
      "Time_End": 2135.42,
      "Text": " So Azure AD has some highly privileged credentials that could grant control over your Active Directory,"
    },
    {
      "Time_Start": 2135.42,
      "Time_End": 2137.1000000000004,
      "Text": " basically."
    },
    {
      "Time_Start": 2137.1,
      "Time_End": 2142.8199999999997,
      "Text": " So as a result, if you have a global admin in Azure AD with network connectivity to a"
    },
    {
      "Time_Start": 2142.8199999999997,
      "Time_End": 2149.58,
      "Text": " domain controller, so it's not fully cloud-only, you always need some network connectivity."
    },
    {
      "Time_Start": 2149.58,
      "Time_End": 2155.14,
      "Text": " Basically a global admin, by definition, can modify accounts in Azure AD, can provision"
    },
    {
      "Time_Start": 2155.14,
      "Time_End": 2160.7,
      "Text": " passwordless credentials for them, and then also recover the NT hash basically for most"
    },
    {
      "Time_Start": 2160.7,
      "Time_End": 2161.7,
      "Text": " sync users."
    },
    {
      "Time_Start": 2161.7,
      "Time_End": 2165.7799999999997,
      "Text": " So not for domain admins or other high-privileged groups."
    },
    {
      "Time_Start": 2165.98,
      "Time_End": 2170.34,
      "Text": " Well, not that you should be syncing your domain admins anyway, but basically for any"
    },
    {
      "Time_Start": 2170.34,
      "Time_End": 2175.34,
      "Text": " synced user that's not a highly privileged user, the global admin could recover the NT"
    },
    {
      "Time_Start": 2175.34,
      "Time_End": 2180.1400000000003,
      "Text": " hash as long as they have some network connectivity to on-prem AD."
    },
    {
      "Time_Start": 2180.1400000000003,
      "Time_End": 2186.5,
      "Text": " Using this way, basically a global admin can also obtain domain admin privileges just because"
    },
    {
      "Time_Start": 2186.5,
      "Time_End": 2193.82,
      "Text": " of how you establish this trust between on-prem Active Directory and Azure AD."
    },
    {
      "Time_Start": 2193.86,
      "Time_End": 2201.94,
      "Text": " So just to end up with some conclusions and some words on the disclosure, I disclosed"
    },
    {
      "Time_Start": 2201.94,
      "Time_End": 2208.3,
      "Text": " all these cases in basically October 2022 to Microsoft, and during February to April"
    },
    {
      "Time_Start": 2208.3,
      "Time_End": 2211.7400000000002,
      "Text": " there was some back and forth about the fixed timeline."
    },
    {
      "Time_Start": 2211.7400000000002,
      "Time_End": 2217.38,
      "Text": " Of course, some of these issues were quite complex, so it required some time to fix."
    },
    {
      "Time_Start": 2217.38,
      "Time_End": 2223.1800000000003,
      "Text": " Also had some discussion about boundary classification, some disagreements on what should or shouldn't"
    },
    {
      "Time_Start": 2223.18,
      "Time_End": 2227.62,
      "Text": " be boundary-eligible in scope, what's identity-related or not."
    },
    {
      "Time_Start": 2227.62,
      "Time_End": 2231.2599999999998,
      "Text": " I'll save you that headache."
    },
    {
      "Time_Start": 2231.2599999999998,
      "Time_End": 2236.18,
      "Text": " Basically in May 2023, so a couple of weeks ago, Microsoft rolled out fixes for most of"
    },
    {
      "Time_Start": 2236.18,
      "Time_End": 2242.66,
      "Text": " the cases, so now it's not possible anymore to provision new keys by writing to the searchable"
    },
    {
      "Time_Start": 2242.66,
      "Time_End": 2250.1,
      "Text": " device key property, and it also now requires NGC MFA properly to provision a new key via"
    },
    {
      "Time_Start": 2250.1,
      "Time_End": 2252.22,
      "Text": " the device registration service."
    },
    {
      "Time_Start": 2252.26,
      "Time_End": 2258.2200000000003,
      "Text": " So you can't just modify users and then just have arbitrary keys on them."
    },
    {
      "Time_Start": 2258.2200000000003,
      "Time_End": 2264.86,
      "Text": " So that's an improvement, of course, for getting back to the Active Directory story."
    },
    {
      "Time_Start": 2264.86,
      "Time_End": 2270.9,
      "Text": " In Active Directory this is still possible, the shadow credentials stack still works,"
    },
    {
      "Time_Start": 2270.9,
      "Time_End": 2274.6600000000003,
      "Text": " but in Azure AD at least this is fixed."
    },
    {
      "Time_Start": 2274.66,
      "Time_End": 2285.66,
      "Text": " So to get back to the conclusions, I started with the key points, basically."
    },
    {
      "Time_Start": 2285.66,
      "Time_End": 2290.74,
      "Text": " So whether Windows Low for Business provides strong phishing-resistant multi-factor authentication,"
    },
    {
      "Time_Start": 2290.74,
      "Time_End": 2292.7799999999997,
      "Text": " I think it's a bit questionable."
    },
    {
      "Time_Start": 2292.7799999999997,
      "Time_End": 2298.46,
      "Text": " It certainly wasn't phishing-resistant because you could actually enroll keys with phishing,"
    },
    {
      "Time_Start": 2298.46,
      "Time_End": 2301.1,
      "Text": " so I wouldn't call that phishing-resistant."
    },
    {
      "Time_Start": 2301.5,
      "Time_End": 2308.58,
      "Text": " Even now, from the perspective of Azure AD, all that gets posted is this public RSA key."
    },
    {
      "Time_Start": 2308.58,
      "Time_End": 2315.38,
      "Text": " It doesn't prove anything about where that key is stored, how it was generated, if it's"
    },
    {
      "Time_Start": 2315.38,
      "Time_End": 2317.62,
      "Text": " stored in a TPM or not."
    },
    {
      "Time_Start": 2317.62,
      "Time_End": 2323.94,
      "Text": " So calling it multi-factor authentication kind of works, assuming that the device that"
    },
    {
      "Time_Start": 2323.94,
      "Time_End": 2329.86,
      "Text": " it was provisioned from is fully trusted, which is a bit of a bad assumption, I think."
    },
    {
      "Time_Start": 2329.86,
      "Time_End": 2334.86,
      "Text": " So I would probably call this one-and-a-half factor authentication."
    },
    {
      "Time_Start": 2334.86,
      "Time_End": 2340.26,
      "Text": " If you have very tight control over your devices and you look at which devices actually provision"
    },
    {
      "Time_Start": 2340.26,
      "Time_End": 2348.1800000000003,
      "Text": " keys, then you could read it as multi-factor authentication, but it still only relies on"
    },
    {
      "Time_Start": 2348.1800000000003,
      "Time_End": 2352.6600000000003,
      "Text": " that specific RSA key that's provisioned and how that key is unlocked."
    },
    {
      "Time_Start": 2352.6600000000003,
      "Time_End": 2356.7200000000003,
      "Text": " It's really up to your devices and also how it's protected."
    },
    {
      "Time_Start": 2356.7200000000003,
      "Time_End": 2359.8,
      "Text": " So requiring MFA to provision, well, definitely wasn't true."
    },
    {
      "Time_Start": 2359.8,
      "Time_End": 2362.96,
      "Text": " I guess it's more or less true now."
    },
    {
      "Time_Start": 2362.96,
      "Time_End": 2368.28,
      "Text": " It was also not bound to a specific device, so basically you could use the keys that you"
    },
    {
      "Time_Start": 2368.28,
      "Time_End": 2369.6400000000003,
      "Text": " provisioned from one device."
    },
    {
      "Time_Start": 2369.6400000000003,
      "Time_End": 2374.6400000000003,
      "Text": " If you steal the keys, you can also use them with another device."
    },
    {
      "Time_Start": 2374.6400000000003,
      "Time_End": 2381.0800000000004,
      "Text": " The keys being protected by a TPM, that's more or less true."
    },
    {
      "Time_Start": 2381.0800000000004,
      "Time_End": 2386.2400000000002,
      "Text": " We saw some demos that you could basically, without stealing the key from the TPM, you"
    },
    {
      "Time_Start": 2386.2400000000002,
      "Time_End": 2388.0400000000004,
      "Text": " could still overwrite it."
    },
    {
      "Time_Start": 2388.0400000000004,
      "Time_End": 2390.48,
      "Text": " There are some more possibilities here."
    },
    {
      "Time_Start": 2390.48,
      "Time_End": 2394.96,
      "Text": " Those are not yet patched, so that's a story for another time, and there's some more interesting"
    },
    {
      "Time_Start": 2394.96,
      "Time_End": 2395.96,
      "Text": " things here."
    },
    {
      "Time_Start": 2395.96,
      "Time_End": 2401.1600000000003,
      "Text": " But still, overall, I would definitely say that this is more secure than password authentication"
    },
    {
      "Time_Start": 2401.1600000000003,
      "Time_End": 2404.76,
      "Text": " because passwords are just insecure in general."
    },
    {
      "Time_Start": 2404.76,
      "Time_End": 2408.7200000000003,
      "Text": " So it's definitely better than passwords, but I wouldn't call this the most secure form"
    },
    {
      "Time_Start": 2408.7200000000003,
      "Time_End": 2412.32,
      "Text": " of authentication that you could think of."
    },
    {
      "Time_Start": 2412.4,
      "Time_End": 2417.6400000000003,
      "Text": " Lastly, to end up, all the tools in the talks are based on the RoadTools framework."
    },
    {
      "Time_Start": 2417.6400000000003,
      "Time_End": 2418.6400000000003,
      "Text": " They're all open source."
    },
    {
      "Time_Start": 2418.6400000000003,
      "Time_End": 2424.7200000000003,
      "Text": " All the things that I have talked about, you can download them from GitHub."
    },
    {
      "Time_Start": 2424.7200000000003,
      "Time_End": 2426.84,
      "Text": " You can look at it yourself."
    },
    {
      "Time_Start": 2426.84,
      "Time_End": 2427.84,
      "Text": " You can do the flows."
    },
    {
      "Time_Start": 2427.84,
      "Time_End": 2429.56,
      "Text": " You can play with it."
    },
    {
      "Time_Start": 2429.56,
      "Time_End": 2432.0,
      "Text": " There's also the RoadTools hybrid library."
    },
    {
      "Time_Start": 2432.0,
      "Time_End": 2437.0800000000004,
      "Text": " That contains more or less the hybrid tools, basically, because they use some Kerberos"
    },
    {
      "Time_Start": 2437.0800000000004,
      "Time_End": 2441.6000000000004,
      "Text": " libraries that I didn't want to include in the main RoadTools repository."
    },
    {
      "Time_Start": 2441.6,
      "Time_End": 2446.2,
      "Text": " I also have some RoadTools stickers, so if you want some stickers, then hit me up after."
    },
    {
      "Time_Start": 2446.2,
      "Time_End": 2449.88,
      "Text": " And of course, I'd be happy to take some questions."
    },
    {
      "Time_Start": 2449.88,
      "Time_End": 2452.6,
      "Text": " If you don't have any questions here, you can find me later."
    },
    {
      "Time_Start": 2452.6,
      "Time_End": 2457.08,
      "Text": " You can message me on Twitter, send me an email, whatever works for you."
    },
    {
      "Time_Start": 2457.08,
      "Time_End": 2458.08,
      "Text": " So thanks."
    }
  ]
}