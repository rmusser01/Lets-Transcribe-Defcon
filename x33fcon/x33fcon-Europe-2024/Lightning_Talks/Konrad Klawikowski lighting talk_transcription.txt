{
  "webpage_url": "https://www.youtube.com/watch?v=zY5urkUbmOc",
  "title": "Konrad Klawikowski lighting talk",
  "description": "Konrad Klawikowski lighting talk, x33fcon 2024",
  "channel_url": "https://www.youtube.com/channel/UC8wesSvHdlNXVZgSy_UU_Ug",
  "duration": 1352,
  "channel": "x33fcon",
  "uploader": "x33fcon",
  "upload_date": "20240716"
}

This text was transcribed using whisper model: large-v2

 Hey, everyone, so we can start lightning talks, I guess, with a little bit of pink light,  because I think if there's the third guy in here who submitted the lightning talk, please  come.  So, yeah, we're getting started.  I actually have two quick talks.  The first one is going to take literally five minutes.  It's going to be about Nix.  I love Nix personally.  I find it's great for everyday use cases.  But like what is Nix exactly?  It consists of a few different parts.  The main part of Nix is being purely functional programming language.  Some also call it package manager, but that's not true.  The true name of that should be a build system.  And that's also the operating system.  So NixOS is based on Linux.  It's really great distro, which is using those configuration files in Nix language.  Basically why some people call it a package manager and why that's wrong, because in Nix  there's a thing called like Nix cache.  And basically you can use Nix to prebuild a package for your OS with Nix.  And you can use Nix cache to host that.  And basically you can get the packages of the web easily.  But actually under the hood, it's still a build system.  On the right side of the slide, you can see an example Nix flake.  A flake is more complex than Nix functionality.  Basically it allows you to turn any GitHub repo into a package, sort of.  As you can see, it's very simple to use.  It has a very simple and nice syntax.  And this screenshot also shows the idea of Nix.  So you define your inputs and you define your outputs.  And you can simplify everything to such a simple approach as if you use the same inputs,  the output should always be the same.  So if you build a package with Nix using the same input, let's say your colleague from  work is also building the package with Nix, you will have the same checks on the file  basically.  Which is also useful in security perspective.  Because we have a few public Nix caches.  So we can compare the checks of packages from them.  And if one is wrong, then possibly something is wrong with the build server on that.  So it's easy to verify your system, whether it was tampered with.  But yes.  Why is it cool as a package manager and a build system?  Because it allows for static compilation with basically everything.  Nix packages currently contain above 90,000 packages.  Which is the biggest repo in the world, basically.  The cool thing about Nix is also cross compilation.  Let me see if I can use terminal.  Okay.  So basically let's move to WSL.  I had this in here.  There's a thing in Nix.  I can show you how it works.  Basically cross compilation, you can check that with rep.  And basically those are all your options for cross compilation.  So that's quite easy to build software for even M1 based Macs, for Darwin based systems.  It's really great to do that with Nix.  And as you can see, Nix also works under WSL, which is also great.  Okay.  Back to the slides.  Also it's easy to set up the binary cache.  You can do it yourself at home.  You can also go further with a thing called any user repository.  And you are.  Which is also great.  And because it's a build system, you can apply such called overlays, which are basically  patches to a software.  And you can do that without forking the repo.  You can do that locally, which is also a nice easy to do approach so you don't mess with  the mainstream of the source code of the package.  And you can apply your own tweaks and share them further down the line.  On the side you can see also another feature of Nix, which is called a dev shell.  And that's one of the coolest things in Nix.  Because it's reproducible and you always have the same output of that.  It's also helpful for developers.  Because you can have the same development environment as your friends do.  You will ensure that all of you use the same version of library and so on.  Even if one of you works on Linux, the other one on Mac OS and the other one is using WSL,  you can ensure with Nix that everything's gonna be fine.  With such a simple example of a dev shell like this one.  This one is using a premade list of packages in Nix, basically.  So I can go to my own personal project.  I created Red Nix and Red Nix OS.  And it consists of basically four different parts.  So those are two repos on GitHub.  The one repo is the main repo and it contains a flake.  So you can import that into already existing Nix system.  And that provides a package set.  I can actually show you that.  Projects, Red Nix.  And let's go packages.  So basically that's the list of packages and everyone can import that to someone's project,  basically.  I premade lists of packages and also groups of packages.  Which is also a cool thing about Nix.  And I'll show you that in a moment.  Because it also has so-called dev shells, as I mentioned a minute ago.  And basically what a dev shell is.  So let's say Snow Crash.  Not found command.  Okay.  Great.  So I have Nix develop.hashrcl, because that's the name of the package group I'm using in  here.  Yes.  Git is dirty.  Okay.  Great.  And now I can go...  Bam.  I have Snow Crash.  And you can see that's inserted in the Nix store.  Which is basically where Nix stores everything.  So you don't have problems, like, with different Linux distros.  There's like Kymara Linux, which is reusing the user land from BSD systems.  And that can be problematic.  So Nix came out with this idea to use slash Nix slash store to store everything.  And the dev shells are temporary.  So I can exit that and boom, it's gone.  But the file is still in my file system.  It just changes the permissions.  So I can use it only as a temporary shell, basically.  In that project, I also have a Nix container, which is another useful approach.  But that's limited only to the Nix users.  Because on Nix OS, you can use system containers and heavily customize those with a configuration  file.  And such configuration looks like this, basically.  Okay.  So we can use the same modules as the main Nix OS in your Nix container.  Which is really nice.  You can set up everything in a single file.  You can import packages, lists, and so on.  Which is very useful for making containers under Nix OS, if you want to have a temporary  environment of a different user and so on.  And that's great.  And the other project I'm having, which was a derivative from all of this, is Red Nix  OS, which is basically reusing Red Nix, but also providing you with an option to build  an ISO.  So like yesterday or two days ago, there was an update to Nix, which messes up fetching  from a URL.  So it's not building properly as of right now.  But the hotfix should be there before the weekend, as they say.  And that should be done.  So basically that's the Nix.  And I really love it.  And I just wanted to show Nix to the world.  And if you want to check out a few things about Nix, here's the QR code to pastebin.  Because I have links to my projects there.  And also on this slide, you might have noticed that there's also a little link.  Because Affleck also offers one other thing, which is also cool.  And you don't have to have Nix installed.  You can use Nix portable.  There's a repo on GitHub.  Basically you can just download a single static binary to your system.  And then you can use something like Nix shell.  Actually let me check in history so I don't mess it up.  Nix.  Okay.  For example, that.  And as of right now, I've already downloaded all the inputs for the package.  So you won't show the process of downloading everything.  But basically it fetches the data from the Flake file from GitHub.  And basically once you place a Flake file in your GitHub project, you can turn it into  a package just like that.  And let's go with deject-help.  I can see it's working.  And also the shell in here is similar to the dev shell I've shown previously.  And now it's gone.  And the other cool thing about Flakes I also want to show you is when you can compare packages  and see their inputs without actually installing them.  So you can have something like that.  Which will basically fetch the information from the Flake from GitHub.  You can see the inputs from that plus modification information.  What that is actually.  The path to that if I have it locally.  The inputs I've added recently.  So like I have Nix packages, basic stuff.  But I can also go to the second project I have, which is derivative of the first one.  And you can see actually that I'm importing Redix.  So it's cool.  And that would be basically this about Nix.  Thanks for your attention.  I just wanted to promote Nix.  Because it's very cool and I think everyone should use Nix.  And I hope it happens one day.  How many time do we have?  Yeah.  Basically.  15 minutes?  Okay.  I also prepared a second talk.  Which is more interesting to the wider audience in here.  Basically WSL basics.  I know that some people lose...  Who in here does use WSL on a daily basis?  One, two, three, four.  Okay.  Great.  Five.  Okay.  Great.  Basically the WSL is Windows subsystem for Linux.  And basically it consists of a few main components.  There's a session manager executed in the user mode on the Windows side of things.  There are two new drivers introduced.  That's LXSS and also LXCore.  Which are basically Pico process providers.  I'll explain that in a moment.  And that's because processes are starting whenever you start a native Linux process.  And as of WSL 2, they're using virtualized customized Linux kernel running under Hyper-V.  And it was customized by Microsoft to ensure that the Cisco layer is working fine and improve  overall file system performance.  Because, you know, it's a Hyper-V VM, so it's heavier than just Pico process.  So what's Pico processes are?  Basically they're associated with Pico provider kernel driver.  That LXSS stuff.  And they have two layers of implementation in Windows.  So there's like minimal processes.  That's when there's empty user mode address space.  And also Pico processes.  So minimal processes.  But they're also associated now with the kernel mode driver, the Pico providers that launches  everything.  Back in the day, because Pico processes were widely used with WSL 1, as of right now, they're  not as widely used because of the architectural change in WSL.  But in WSL 1, the host OS didn't even try to manage user mode addresses space inside  the Pico process.  The Windows kernel was passing all systems and exceptions from user mode of Pico process  to a Pico provider to handle everything.  And Pico provider was starting at a good time with a Windows kernel and they were exchanging  interfaces.  So basically function pointers for kernel were exchanged to call when dispatching user  mode syscall in WSL.  And also as an example of that, another one, kernel provided pointers to a Pico provider  for actually creating Pico processes or threads.  As I mentioned, they're not actively used in WSL 2.  And interaction with the kernel is somewhat different.  They're rather used for file system interaction in WSL 2.  Because they've introduced that real Linux kernel under the hood.  And basically there's a little side note.  When a program is running, subsystem driver requests to a Windows kernel to run process  and it calls a function called ZV create user process.  That's from the Windows driver kit.  How the syscalls work basically.  So the flow is like there are marshaling parameters.  So they're moving parameters into the CPU registers.  Then there's a syscall, a trap to transition from a user mode to kernel mode to actually  make the syscall.  Then the return, there's a return from the system call with another special instruction  to return back to the user mode.  Because two kernels have to talk to each other.  And then the user mode from WSL checks the value returned.  And that's using LXSS driver.  Also as a side note, very interesting fact is that WSL is implementing pipes differently.  Because Linux pipes and T kernel pipes are working kind of different.  So it has somewhat a reimplementation of that.  But it still relies on very primitive NT functionalities.  So like data structures and synchronization.  And from Linux it's mapped basically one-to-one to ZW execution.  That's also from the Windows driver kit.  Also how the file systems work.  So in WSL they're using virtual file systems.  So you can have multiple file systems to coexist with each other.  So by default WSL will use ext4 and Windows obviously by default is NTFS.  And also that VHS implementation is implementing another set of system calls for file system  operations.  And they're using data structures and for example those are indexes.  So basically inodes.  You know, basic stuff.  Information about file system.  Objects like file type, permissions, size, last modified and so on.  And also directory entries.  Because they're using a directory entry cache to represent the file system namespace.  And there's the entry thing in memory.  So there's no physical store because that's a virtual hard drive.  And that entry contains a pointer to an inode for the file basically.  And also it also introduces the special file types like device files and so on.  Because it's different.  Also file systems, the WSL file system has to perform the following operations.  So it has to translate Linux file system operations into Windows kernel operations as I mentioned  that interchanging operation between the kernels.  It has to provide a special file system.  So that's process, FS, drive FS and so on.  They're explained at the bottom how they look like.  And they have to provide access to Windows volumes which is turned on by default in WSL  and they're out amounted by default in WSL.  And they also have to provide a place where Linux system files can operate normally allowing  for file permissions and so on.  And that's where the Alex core driver is used.  But what's next actually?  I have only five minutes.  Sorry.  For the people who are defending the Windows endpoints that might have WSL installed, there  are two places actually.  Okay.  It's refreshed.  There's basically this path.  So see users.  That's your user name update.  Let me just go there.  So I can show you that.  Okay.  Let's change my user name.  Okay.  Okay.  And basically that's where the exe file for the WSL is stored.  So whenever you launch that in a partial CMD, that's what it was called.  So they're mapped under WSL and distro name.  So when you go to your terminal, let's go WSL dollar Ubuntu.  As you can see, I just went into the Ubuntu file system from PowerShell and our details  are found under this registry key.  And basically it looks like let me just get a new one.  Get child item.  Here we go.  Okay.  So it looks like this in the registry.  So you have information where the VHDX file is stored.  That's very useful for forensic perspective because you can import that to autopsy, for  example.  You also have information whether that's WSL one or two.  Also the name of that.  And that's pretty cool.  But the exception for that is WSL system distro.  Which is quite complex because it looks like this.  And there's WSL system is stored under the program files WSL system VHD.  And what's interesting about it is it's the distro that's handling the X11 port forwarding  for your main WSL.  However there's also the other side of everything.  So basically you can go with WSL-root and without asking for password you just get the  root on the WSL, which is quite cool and it automates the Windows file system into that.  There's also that I think you can execute the binaries from Windows.  And the if you have WSL enabled, you also get bash enabled.  And both of those can be used basically for AWL bypassing.  And the WSL stuff can be also combined with dash root and dash D to change the distro  it's using for execution.  Because basically we have somewhere history.  Okay.  Let's go with this.  Because the bash on Windows is by default using the default WSL distro, which can be  found using this one.  So the one with asterisk is your default one.  And as you can see, the bash is using the Ubuntu one.  So it's pretty cool.  Okay.  Just what's next?  Stay tuned.  Because I'm still researching that and I hope I'll manage to write a blog post on it.  So thanks for your attention.