{
  "webpage_url": "https://www.youtube.com/watch?v=JTt0kXkw5s8",
  "title": "Kevin Tellier lighting talk",
  "description": "Kevin Tellier lighting talk, x33fcon 2024",
  "channel_url": "https://www.youtube.com/channel/UC8wesSvHdlNXVZgSy_UU_Ug",
  "duration": 513,
  "channel": "x33fcon",
  "uploader": "x33fcon",
  "upload_date": "20240722"
}

This text was transcribed using whisper model: large-v2

 So, yeah, I'm Kevin, I'm from SynActive in France.  We are doing pen testing and stuff like that, reverse too.  So I've been doing research recently on DCOM.  So it's an old technology, we'll see that.  And I wanted to check for DLL hijacking on COM classes.  So it's a tedious process.  You need to get the legit DLL, you  have to get the exported function from the DLL,  compile the MySUSE DLL, and then activate the remote class  to trigger the DLL hijacking.  And I had thousands of classes to check,  so I decided to make a tool.  It's called DLHell, but first we have to see what is DCOM.  And that's the developer from Microsoft  when you ask him, what is DCOM, you just see his face.  So, yeah, DCOM is quite complicated.  It's an old technology.  First, before seeing what is DCOM,  you have to understand what is COM.  COM stands for Component Object Model.  It was launched in 1993, so it's very old.  It's embedded in Windows, and it's a very important  technology inside Windows.  It's the successor of OLE, Object Linking and Embedding,  which was used in the Office application  to embed documents in spreadsheets and presentations  and stuff like that.  So you had Excel spreadsheets within your PowerPoint  presentation, and this was OLE.  It was the first use case for this technology.  So basically, it's a middleware between Windows processes,  if you want to simplify the thing.  And DCOM stands for Distributed COM.  It's the network implementation of COM.  So between computers, you can trigger instantiate classes  and access methods on remote hosts.  So the objects in COM are identified using the CLSID.  So it's a class identifier.  So within the server, you can have multiple objects.  And inside a container named AppID,  so it's basically a grid that embeds multiple objects.  And each of those objects have a CLSID, which identifies them,  and a ProgID, which is a friendly name for the class.  So objects define interfaces.  From those interfaces, you can call methods  on the remote process.  And there are two types of servers, in-process servers,  which are, as their name, inside the process.  They are implemented in a DLL file,  and out-of-process objects, which are implemented  in executable files, so exe files.  So basically, before calling any methods on the COM object,  you have to activate it, instantiate the object.  And to do that, the computer, Windows,  just looks at the registry and checks for two input,  two keys, in-proc server 32.  If this key is present, then it's an in-process server.  So the computer just loads the DLL  and instantiates the object, so you can call methods on it.  So it's not the most interesting type of server,  in the case of DLL hijacking.  Local server 32 is more interesting,  because it creates a process from an exe file,  defined in the registry.  So basically, you can, using DCOM,  you can trigger and create a process from a remote host.  So you need a local admin rights on the remote computer  to activate the class.  And it's using port 135 to connect on the remote host.  So it's the default rights, but some classes  may implement different rights.  So DLL hijacking, how it works, it's  the second part of the two.  If the reference DLL does not exist on the file system,  and the program calls it, you can just  place a malicious DLL file to execute arbitrary code.  So it's the simplest DLL hijacking that you can do.  And the second one is if the reference DLL exists,  but it's writable.  Imagine in OneDrive, for example,  you have DLLs that are user-writable.  You don't need admin rights.  And you can just rewrite the legit DLL  and execute malicious code.  But it breaks the application.  So in order to make it work, you just  proxy the function, the legit function.  So you call the malicious DLL that proxies to the legit DLL,  and then the application doesn't break.  So how to find resting classes?  It's pretty easy.  You just have to launch ProcMon from sysinternals  and look for name not found on DLL files.  Or you can just watch for which DLLs are called by the exe file.  And then you activate the com class.  And you just see the results and look for loaded DLLs  that you can hijack using the two previous methods.  So what DLL does, it does all those steps  that are pretty tedious.  So downloading the legit DLL from the victim using  SMB, using impacket in this case,  it extracts the function exports,  compiles the proxy DLL using mingwin,  because I didn't want to use Visual Studio,  and puts the DLL, the original, the malicious one,  on the victim computer and activates to the com class.  So here is the command.  Unfortunately, it's a spare laptop, not my laptop from work,  so I didn't have anything set up to show you a demo.  But you can just try it.  It's available on GitHub.  And the command is pretty simple.  You just need to specify the credentials, the remote DLL,  and the legit one, and the command  that you want to execute.  The template is just the DLL source file.  It's just a simple template that makes a create process  and calls the command calc.exe, the command that you specify.  Some tools that does that already exist,  but I didn't find any tool that makes the compilation using  mingwin and some of the stuff.  So nothing that does all of the work, so I just made one.