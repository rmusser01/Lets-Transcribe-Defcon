{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 20.7,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Welcome to the presentation Windows 10 TCPIP RCE, from the patch to the screen of death."
    },
    {
      "Time_Start": 20.7,
      "Time_End": 29.240000000000002,
      "Text": " Today I would like to speak a bit more about the bug which was classified as CVE-2020-16898,"
    },
    {
      "Time_Start": 29.240000000000002,
      "Time_End": 31.240000000000002,
      "Text": " also known as a bad neighbor."
    },
    {
      "Time_Start": 31.240000000000002,
      "Time_End": 38.68,
      "Text": " This is quite an interesting bug, which in the end, during my research, a result in generating"
    },
    {
      "Time_Start": 38.68,
      "Time_End": 48.92,
      "Text": " a proof-of-concept exploit which had an ability to crash every Windows 10 system, mostly updated"
    },
    {
      "Time_Start": 48.92,
      "Time_End": 54.480000000000004,
      "Text": " during this time, which you can see the picture of that problem and the results of the running"
    },
    {
      "Time_Start": 54.480000000000004,
      "Time_End": 58.160000000000004,
      "Text": " of the exploit here on this screenshot."
    },
    {
      "Time_Start": 58.160000000000004,
      "Time_End": 62.56,
      "Text": " At first I would like to apologize for the quality of this picture, because I made it"
    },
    {
      "Time_Start": 62.56,
      "Time_End": 67.24000000000001,
      "Text": " using a pretty not professional device, which was my phone."
    },
    {
      "Time_Start": 67.24000000000001,
      "Time_End": 68.24000000000001,
      "Text": " Sometimes I call it potato."
    },
    {
      "Time_Start": 68.24000000000001,
      "Time_End": 74.52000000000001,
      "Text": " However, as you can see, it kind of shows you what is the result of the exploit."
    },
    {
      "Time_Start": 74.52000000000001,
      "Time_End": 79.72,
      "Text": " Before I move forward, I just wanted to speak a bit about myself."
    },
    {
      "Time_Start": 79.72,
      "Time_End": 84.28,
      "Text": " So my name is Adam Zaborodski, among others, sometimes I use the nickname PA3."
    },
    {
      "Time_Start": 84.28,
      "Time_End": 88.92,
      "Text": " You can always contact with me using my private email, which you can see on the top right"
    },
    {
      "Time_Start": 88.92,
      "Time_End": 93.68,
      "Text": " corner of this screen, which is PA3 at PA3.com.pl."
    },
    {
      "Time_Start": 93.68,
      "Time_End": 99.4,
      "Text": " I also have a Twitter account, which you can always find me, and also I have my own personal"
    },
    {
      "Time_Start": 99.4,
      "Time_End": 106.24000000000001,
      "Text": " website PA3.com.pl, where you can always find some kind of update information, how to connect"
    },
    {
      "Time_Start": 106.24000000000001,
      "Time_End": 107.24000000000001,
      "Text": " with me."
    },
    {
      "Time_Start": 107.24000000000001,
      "Time_End": 113.84,
      "Text": " Currently, I'm working in NVIDIA as a Principal Offensive Security Software Engineer."
    },
    {
      "Time_Start": 113.84,
      "Time_End": 119.68,
      "Text": " Before, I used to work in Microsoft, in the Offensive Security Research team, also in"
    },
    {
      "Time_Start": 119.68,
      "Time_End": 125.64000000000001,
      "Text": " the European Organization for Nuclear Research, known as CERN, in the Hispasic system, as"
    },
    {
      "Time_Start": 125.64000000000001,
      "Time_End": 131.04000000000002,
      "Text": " mostly known from the VirusTotal project, also in the Wroc\u0142aw Center for Networking"
    },
    {
      "Time_Start": 131.04000000000002,
      "Time_End": 134.92000000000002,
      "Text": " and Supercomputing, in CIGITAL and a few more."
    },
    {
      "Time_Start": 134.92000000000002,
      "Time_End": 140.48000000000002,
      "Text": " In my spare time, I'm one of the main developers of Linux kernel RuntimeGuard, which I fully"
    },
    {
      "Time_Start": 140.48000000000002,
      "Time_End": 147.48000000000002,
      "Text": " designed and implemented, and currently is being published under OpenWorld umbrella."
    },
    {
      "Time_Start": 147.48000000000002,
      "Time_End": 152.64000000000001,
      "Text": " I also used to be one of the developers for RSE, Reverse Engineering Software Interface"
    },
    {
      "Time_Start": 152.64000000000001,
      "Time_End": 159.12,
      "Text": " Framework, which was one of the first reverse engineering frameworks with its own programming"
    },
    {
      "Time_Start": 159.12,
      "Time_End": 164.36,
      "Text": " language, which was quite innovative, and it was focusing on the Unix systems, especially"
    },
    {
      "Time_Start": 164.36,
      "Time_End": 171.68,
      "Text": " in the ELF binaries, where I was responsible, among others, with MIPS architecture."
    },
    {
      "Time_Start": 171.68,
      "Time_End": 176.28,
      "Text": " Also during my spare time, I do a lot of bug hunting, and I found among others bugs in"
    },
    {
      "Time_Start": 176.28,
      "Time_End": 181.96,
      "Text": " the Hyper-V hypervisor, in the virtual GPU implementation for Intel and NVIDIA products,"
    },
    {
      "Time_Start": 181.96,
      "Time_End": 187.32000000000002,
      "Text": " in Linux kernel, in OpenSSH, in the implementation of the stack Smashing Protector, known as"
    },
    {
      "Time_Start": 187.32000000000002,
      "Time_End": 192.48000000000002,
      "Text": " Propolis in the GCC, in the Apache server, in XPDF a few more, and I have CVN numbers"
    },
    {
      "Time_Start": 192.48000000000002,
      "Time_End": 193.48000000000002,
      "Text": " for that."
    },
    {
      "Time_Start": 193.60000000000002,
      "Time_End": 199.08,
      "Text": " But also I like to study various exploitation techniques, and some of the research which"
    },
    {
      "Time_Start": 199.08,
      "Time_End": 202.76000000000002,
      "Text": " I have been made, which I made, was published on the FRAC magazine."
    },
    {
      "Time_Start": 202.76000000000002,
      "Time_End": 207.52,
      "Text": " Okay, let's move forward to the topic of this presentation."
    },
    {
      "Time_Start": 207.52,
      "Time_End": 213.52,
      "Text": " So at first, why did I choose to look about, look and analyze this specific type of the"
    },
    {
      "Time_Start": 213.52,
      "Time_End": 214.52,
      "Text": " bug?"
    },
    {
      "Time_Start": 214.52,
      "Time_End": 217.08,
      "Text": " Why this bug, not any other bugs?"
    },
    {
      "Time_Start": 217.08,
      "Time_End": 223.20000000000002,
      "Text": " And the answer to this question is quite interesting, because one of the main reasons why I focus"
    },
    {
      "Time_Start": 223.20000000000002,
      "Time_End": 232.00000000000003,
      "Text": " on that bug, because this type of the vulnerability, we can easily call as the worst possible nightmare."
    },
    {
      "Time_Start": 232.00000000000003,
      "Time_End": 237.24,
      "Text": " The reason why, because this is a bug in the implementation, in the TCP IP stack, which"
    },
    {
      "Time_Start": 237.24,
      "Time_End": 241.36,
      "Text": " is very, very rare, so it doesn't require an authentication."
    },
    {
      "Time_Start": 241.36,
      "Time_End": 245.24,
      "Text": " So this like kind of pre-authentication type of the bug."
    },
    {
      "Time_Start": 245.24,
      "Time_End": 249.28000000000003,
      "Text": " And because of that, none of the firewalls can ever help, because the bug is during the"
    },
    {
      "Time_Start": 249.28,
      "Time_End": 253.36,
      "Text": " parsing of the packet which is incoming."
    },
    {
      "Time_Start": 253.36,
      "Time_End": 258.7,
      "Text": " So before we can apply any firewall rules, we still need to handle this packet first."
    },
    {
      "Time_Start": 258.7,
      "Time_End": 264.12,
      "Text": " So the bug is during the parsing of the code, so the firewalls will never help, it's just"
    },
    {
      "Time_Start": 264.12,
      "Time_End": 267.84,
      "Text": " in the too early stage where the bug exists."
    },
    {
      "Time_Start": 267.84,
      "Time_End": 274.68,
      "Text": " And also we kind of remotely exploit kernel, which is a ring zero in the x86 architecture,"
    },
    {
      "Time_Start": 274.68,
      "Time_End": 278.24,
      "Text": " which is the highest privilege mode for the operation system."
    },
    {
      "Time_Start": 278.24,
      "Time_End": 283.8,
      "Text": " So because of that, there is no possibility of any kind of sandbox of the vulnerable code,"
    },
    {
      "Time_Start": 283.8,
      "Time_End": 290.2,
      "Text": " neither any kind of mitigate of that, because we fully remotely exploit kernel experts,"
    },
    {
      "Time_Start": 290.2,
      "Time_End": 292.22,
      "Text": " which is kind of disaster."
    },
    {
      "Time_Start": 292.22,
      "Time_End": 297.84000000000003,
      "Text": " And this type of the bug that you still can find in the TCP IP, in the parsing code, is"
    },
    {
      "Time_Start": 297.84000000000003,
      "Time_End": 299.04,
      "Text": " very unusual."
    },
    {
      "Time_Start": 299.04,
      "Time_End": 305.08,
      "Text": " So this is kind of a dinosaur among vulnerabilities, which is very, very rare, and it's not very"
    },
    {
      "Time_Start": 305.08,
      "Time_End": 310.47999999999996,
      "Text": " popular nowadays, because this is kind of already old code, which have been audited"
    },
    {
      "Time_Start": 310.47999999999996,
      "Time_End": 317.59999999999997,
      "Text": " thousands of times, and the expectation is there isn't any kind of surprises like that."
    },
    {
      "Time_Start": 317.59999999999997,
      "Time_End": 323.96,
      "Text": " However, as we can see, still some of the bugs in the TCP IP can be found, which is"
    },
    {
      "Time_Start": 323.96,
      "Time_End": 325.96,
      "Text": " kind of crazy."
    },
    {
      "Time_Start": 325.96,
      "Time_End": 331.68,
      "Text": " That's the reason I call it kind of the worst possible nightmare, and it's kind of dinosaur"
    },
    {
      "Time_Start": 331.68,
      "Time_End": 333.2,
      "Text": " at the same time."
    },
    {
      "Time_Start": 333.2,
      "Time_End": 338.36,
      "Text": " But speaking about dinosaurs, as any other dinosaurs can be very dangerous, which means"
    },
    {
      "Time_Start": 338.36,
      "Time_End": 343.88,
      "Text": " that full and weaponized exploit could result in the catastrophic scenario."
    },
    {
      "Time_Start": 343.88,
      "Time_End": 348.71999999999997,
      "Text": " And this scenario could be a fatal consequences malware, that type of the malware which we"
    },
    {
      "Time_Start": 348.71999999999997,
      "Time_End": 357.03999999999996,
      "Text": " cannot defend from, because it's in the pre-authentication phase of the parsing of the package, TCP IP,"
    },
    {
      "Time_Start": 357.03999999999996,
      "Time_End": 360.06,
      "Text": " which doesn't rely on any user interaction."
    },
    {
      "Time_Start": 360.06,
      "Time_End": 365.14,
      "Text": " So you could imagine creating a malware who will just automatically starting to compromise"
    },
    {
      "Time_Start": 365.14,
      "Time_End": 371.86,
      "Text": " any vulnerable system connected to the internet, which is kind of crazy, because everybody"
    },
    {
      "Time_Start": 371.86,
      "Time_End": 378.46,
      "Text": " told that this type of the bugs doesn't exist anymore, especially not in that level, as"
    },
    {
      "Time_Start": 378.46,
      "Time_End": 381.34000000000003,
      "Text": " a TCP IP stack parsing bugs."
    },
    {
      "Time_Start": 381.34000000000003,
      "Time_End": 386.1,
      "Text": " And in the worst, in the, at least we would be able to generate something called spink"
    },
    {
      "Time_Start": 386.1,
      "Time_End": 391.18,
      "Text": " of death 2.0, let's say, because pink of death is a type of the attack which existed in the"
    },
    {
      "Time_Start": 391.18,
      "Time_End": 395.66,
      "Text": " early stages of the Windows, like Windows 95, that you can send just a packet and kill"
    },
    {
      "Time_Start": 395.66,
      "Time_End": 396.90000000000003,
      "Text": " the machine."
    },
    {
      "Time_Start": 396.90000000000003,
      "Time_End": 402.38,
      "Text": " So this type of the bug, like bad neighbor, allows you to exactly generate at least kind"
    },
    {
      "Time_Start": 402.38,
      "Time_End": 406.1,
      "Text": " of pink of death attack to the modern Windows 10 system."
    },
    {
      "Time_Start": 406.1,
      "Time_End": 413.1,
      "Text": " So which is pretty bad, so if you take everything together, this is kind of what can burn now."
    },
    {
      "Time_Start": 413.1,
      "Time_End": 417.34000000000003,
      "Text": " We have pre-authenticated bug in the TCP IP stack and you cannot really defend from"
    },
    {
      "Time_Start": 417.34000000000003,
      "Time_End": 423.70000000000005,
      "Text": " them and you can crush any updated Windows 10 systems, which is kind of crazy."
    },
    {
      "Time_Start": 423.70000000000005,
      "Time_End": 429.58000000000004,
      "Text": " Speaking about the time I'm about this bug, so on the 13th of October 2020, Microsoft"
    },
    {
      "Time_Start": 429.58000000000004,
      "Time_End": 435.62,
      "Text": " released the fix for the bad neighbor bug as a part of just regular patch Tuesday."
    },
    {
      "Time_Start": 435.62,
      "Time_End": 440.74,
      "Text": " And at the same time, there was the first detection signature created exactly on the"
    },
    {
      "Time_Start": 440.74,
      "Time_End": 447.5,
      "Text": " same day by various companies, including, among others, Sophos, McAfee and a few others."
    },
    {
      "Time_Start": 447.5,
      "Time_End": 453.06,
      "Text": " And the same company who created the detection signature claimed that exploitation of this"
    },
    {
      "Time_Start": 453.06,
      "Time_End": 455.66,
      "Text": " bug is pretty trivial."
    },
    {
      "Time_Start": 455.66,
      "Time_End": 462.22,
      "Text": " And if you know about the implication of the bug and how unusual this type of the bug is"
    },
    {
      "Time_Start": 462.22,
      "Time_End": 469.7,
      "Text": " and what the crazy implication might happen, it's kind of crazy claiming that this kind"
    },
    {
      "Time_Start": 469.7,
      "Time_End": 474.97999999999996,
      "Text": " of exploitation is trivial because the bug doesn't look trivial at first place and is"
    },
    {
      "Time_Start": 474.97999999999996,
      "Time_End": 476.5,
      "Text": " very critical."
    },
    {
      "Time_Start": 476.5,
      "Time_End": 484.34,
      "Text": " However, if you dig in more about their statement, it turns out they just forgot to add one very"
    },
    {
      "Time_Start": 484.34,
      "Time_End": 489.34,
      "Text": " important piece that they got proof of concept from Microsoft for free."
    },
    {
      "Time_Start": 489.34,
      "Time_End": 494.86,
      "Text": " So essentially claiming that something is trivial in exploitation, if you get the exploit"
    },
    {
      "Time_Start": 494.86,
      "Time_End": 502.14,
      "Text": " for free, it doesn't really judge the particular difficulties of how really difficult is to"
    },
    {
      "Time_Start": 502.14,
      "Time_End": 503.82,
      "Text": " exploit this bug."
    },
    {
      "Time_Start": 503.82,
      "Time_End": 509.82,
      "Text": " And it can be written in one of these, for example, screenshot statements that the proof"
    },
    {
      "Time_Start": 509.82,
      "Time_End": 515.94,
      "Text": " of concept shared with the map partners is both extremely simple and perfectly reliable."
    },
    {
      "Time_Start": 515.94,
      "Time_End": 522.5,
      "Text": " So this is kind of unusual that if someone got proof of concept for free saying it's"
    },
    {
      "Time_Start": 522.5,
      "Time_End": 523.94,
      "Text": " easy to create it."
    },
    {
      "Time_Start": 523.94,
      "Time_End": 529.42,
      "Text": " And in the security researcher industry, let's say, security researchers somehow realized"
    },
    {
      "Time_Start": 529.42,
      "Time_End": 540.98,
      "Text": " that this is not pretty, not a good statement and they're starting to be very criticizing"
    },
    {
      "Time_Start": 540.98,
      "Time_End": 541.98,
      "Text": " this kind of statement."
    },
    {
      "Time_Start": 541.98,
      "Time_End": 546.3,
      "Text": " And so one of the most popular comments on the Twitter was exactly this one."
    },
    {
      "Time_Start": 546.3,
      "Time_End": 550.14,
      "Text": " It's easy to say that creating proof of concept is easy when Microsoft hands you one as a"
    },
    {
      "Time_Start": 550.14,
      "Time_End": 552.2,
      "Text": " part of the map program."
    },
    {
      "Time_Start": 552.2,
      "Time_End": 560.1600000000001,
      "Text": " So I find it kind of funny and kind of reply went viral."
    },
    {
      "Time_Start": 560.1600000000001,
      "Time_End": 567.24,
      "Text": " However, the story about this bug was pretty crazy that everybody's starting to put more"
    },
    {
      "Time_Start": 567.24,
      "Time_End": 570.5200000000001,
      "Text": " and more eyes on this direction."
    },
    {
      "Time_Start": 570.5200000000001,
      "Time_End": 576.84,
      "Text": " And that's why it was just a matter of the time when the first known proof of concept"
    },
    {
      "Time_Start": 576.84,
      "Time_End": 578.4000000000001,
      "Text": " will be popping up."
    },
    {
      "Time_Start": 578.4,
      "Time_End": 585.68,
      "Text": " So speaking about that, the first known but not public exploit for bad neighbor was created"
    },
    {
      "Time_Start": 585.68,
      "Time_End": 589.12,
      "Text": " around 14th of October."
    },
    {
      "Time_Start": 589.12,
      "Time_End": 593.56,
      "Text": " And exactly on the same day, I thought, you have to check it by yourself."
    },
    {
      "Time_Start": 593.56,
      "Time_End": 596.18,
      "Text": " How difficult is it to create this proof of concept?"
    },
    {
      "Time_Start": 596.18,
      "Time_End": 600.84,
      "Text": " Because the detection signatures company claim it's trivial, but researchers were not able"
    },
    {
      "Time_Start": 600.84,
      "Time_End": 603.4,
      "Text": " really to create proof of concept."
    },
    {
      "Time_Start": 603.4,
      "Time_End": 607.1999999999999,
      "Text": " At least none of the public proof of concept existed."
    },
    {
      "Time_Start": 607.2,
      "Time_End": 613.5200000000001,
      "Text": " And the bug seems like the most critical possible bug ever at that specific time, because"
    },
    {
      "Time_Start": 613.5200000000001,
      "Time_End": 616.9200000000001,
      "Text": " it's just a remote TCP IP bug in the kernel."
    },
    {
      "Time_Start": 616.9200000000001,
      "Time_End": 619.8000000000001,
      "Text": " So I decided, yeah, you have to check it yourself."
    },
    {
      "Time_Start": 619.8000000000001,
      "Time_End": 623.0,
      "Text": " There is too many legends around this bug."
    },
    {
      "Time_Start": 623.0,
      "Time_End": 628.96,
      "Text": " And I created Working POC one day later on the 15th of October."
    },
    {
      "Time_Start": 628.96,
      "Time_End": 635.2800000000001,
      "Text": " And here is a screenshot from the WinDBG that one day later, I was able to generate a stack"
    },
    {
      "Time_Start": 635.28,
      "Time_End": 641.6,
      "Text": " smashing on the kernel stack proof of concept for this bug."
    },
    {
      "Time_Start": 641.6,
      "Time_End": 648.56,
      "Text": " And the day after that, on the 16th of October, I decided that it's a YOLO day."
    },
    {
      "Time_Start": 648.56,
      "Time_End": 649.56,
      "Text": " You only live once."
    },
    {
      "Time_Start": 649.56,
      "Time_End": 657.76,
      "Text": " So I decided to publish every detail about how to exploit this bug, what really is behind"
    },
    {
      "Time_Start": 657.76,
      "Time_End": 663.0799999999999,
      "Text": " the scene behind this bug, and kind of remove all the legends around it."
    },
    {
      "Time_Start": 663.08,
      "Time_End": 668.08,
      "Text": " So I decided to publish a very detailed write-up about this, including the exploit itself with"
    },
    {
      "Time_Start": 668.08,
      "Time_End": 671.2800000000001,
      "Text": " all the technical details."
    },
    {
      "Time_Start": 671.2800000000001,
      "Time_End": 673.2,
      "Text": " So where is the bug?"
    },
    {
      "Time_Start": 673.2,
      "Time_End": 676.5600000000001,
      "Text": " So from the Microsoft description, we will not learn much."
    },
    {
      "Time_Start": 676.5600000000001,
      "Time_End": 679.8000000000001,
      "Text": " However, there is still some kind of interesting information."
    },
    {
      "Time_Start": 679.8000000000001,
      "Time_End": 684.7800000000001,
      "Text": " So this is kind of a quote from the official statements about the bad neighbor from Microsoft."
    },
    {
      "Time_Start": 684.7800000000001,
      "Time_End": 689.6400000000001,
      "Text": " So what we know that there is this type of the bug is a remote code execution bug, which"
    },
    {
      "Time_Start": 689.64,
      "Time_End": 698.0,
      "Text": " exists in Windows TCP IP stack, which incorrectly handles ECMP v6 router advertisement packets."
    },
    {
      "Time_Start": 698.0,
      "Time_End": 705.26,
      "Text": " And this ECMP v6 router advertisement statement, like name, is being referenced a few times"
    },
    {
      "Time_Start": 705.26,
      "Time_End": 708.88,
      "Text": " in this Microsoft description."
    },
    {
      "Time_Start": 708.88,
      "Time_End": 711.16,
      "Text": " So what do we really know?"
    },
    {
      "Time_Start": 711.16,
      "Time_End": 712.16,
      "Text": " Not much."
    },
    {
      "Time_Start": 712.16,
      "Time_End": 718.1,
      "Text": " We only know that the bug exists in the ECMP v6 in the RA parsing logic, but nothing more."
    },
    {
      "Time_Start": 718.1,
      "Time_End": 721.74,
      "Text": " So this is not a very detailed description and doesn't tell you a lot."
    },
    {
      "Time_Start": 721.74,
      "Time_End": 724.58,
      "Text": " However, can we do something with this?"
    },
    {
      "Time_Start": 724.58,
      "Time_End": 733.74,
      "Text": " In fact, yes, we could try to run IDA and reverse engineering the patch, or we can try"
    },
    {
      "Time_Start": 733.74,
      "Time_End": 737.4200000000001,
      "Text": " to reverse engineering the detection signature."
    },
    {
      "Time_Start": 737.4200000000001,
      "Time_End": 744.1800000000001,
      "Text": " And if doing so, we would be able to find out more information about the bug, because"
    },
    {
      "Time_Start": 744.1800000000001,
      "Time_End": 746.44,
      "Text": " at least we know where to look at."
    },
    {
      "Time_Start": 746.44,
      "Time_End": 753.2,
      "Text": " We know we need to look at something around ECMP v6 RA logic, and maybe we can find more"
    },
    {
      "Time_Start": 753.2,
      "Time_End": 754.5200000000001,
      "Text": " information."
    },
    {
      "Time_Start": 754.5200000000001,
      "Time_End": 759.2800000000001,
      "Text": " So because we have two options, which one to go?"
    },
    {
      "Time_Start": 759.2800000000001,
      "Time_End": 763.9200000000001,
      "Text": " I choose to go of analyzing detection logic instead of analyzing the patch."
    },
    {
      "Time_Start": 763.9200000000001,
      "Time_End": 765.36,
      "Text": " And the reason why?"
    },
    {
      "Time_Start": 765.36,
      "Time_End": 770.84,
      "Text": " Because the patch itself, published by Microsoft, includes more than 40 other patches for other"
    },
    {
      "Time_Start": 770.84,
      "Time_End": 772.4200000000001,
      "Text": " bugs, 40 other bugs."
    },
    {
      "Time_Start": 772.4200000000001,
      "Time_End": 780.5000000000001,
      "Text": " So analyzing this specific bad neighbor among 40 other fixed bugs will be not as easy, not"
    },
    {
      "Time_Start": 780.5000000000001,
      "Time_End": 781.5000000000001,
      "Text": " as trivial."
    },
    {
      "Time_Start": 781.5000000000001,
      "Time_End": 787.5400000000001,
      "Text": " Because at first you would need to filter them out, which fixes are exactly targeting"
    },
    {
      "Time_Start": 787.5400000000001,
      "Time_End": 790.9000000000001,
      "Text": " bad neighbor vulnerability, not other one."
    },
    {
      "Time_Start": 790.9000000000001,
      "Time_End": 797.1400000000001,
      "Text": " And then you can just start doing analyzing the bug bad neighbor itself, which could take"
    },
    {
      "Time_Start": 797.1400000000001,
      "Time_End": 798.1400000000001,
      "Text": " you some time."
    },
    {
      "Time_Start": 798.14,
      "Time_End": 804.14,
      "Text": " However, and the counterpart, if you just go starting to analyze the detection logic"
    },
    {
      "Time_Start": 804.14,
      "Time_End": 810.34,
      "Text": " for the bad neighbor, you already have this job done for free, because you just are getting"
    },
    {
      "Time_Start": 810.34,
      "Time_End": 813.6999999999999,
      "Text": " exactly that specific bug, which is much easier."
    },
    {
      "Time_Start": 813.6999999999999,
      "Time_End": 817.62,
      "Text": " Because you don't need to filter out any other fixes or any other detection."
    },
    {
      "Time_Start": 817.62,
      "Time_End": 820.3199999999999,
      "Text": " You just need to focus on the bad neighbor directly."
    },
    {
      "Time_Start": 820.3199999999999,
      "Time_End": 826.5,
      "Text": " So that's why I decided to go to this direction, because I thought it will be much easier."
    },
    {
      "Time_Start": 826.5,
      "Time_End": 831.86,
      "Text": " So speaking about that, I started to look on the internet about any possible description"
    },
    {
      "Time_Start": 831.86,
      "Time_End": 834.76,
      "Text": " of the bad neighbor from the detection logic perspective."
    },
    {
      "Time_Start": 834.76,
      "Time_End": 840.2,
      "Text": " And interesting description I found in the McAfee's website, and they quote it here."
    },
    {
      "Time_Start": 840.2,
      "Time_End": 848.74,
      "Text": " So essentially what we know from this statement, that the bug is in the APV6 array logic, but"
    },
    {
      "Time_Start": 848.74,
      "Time_End": 851.74,
      "Text": " with the option related to the RDNSS."
    },
    {
      "Time_Start": 851.98,
      "Time_End": 856.98,
      "Text": " RDNSS is an option type with the number 25."
    },
    {
      "Time_Start": 856.98,
      "Time_End": 866.78,
      "Text": " And if APV6 array RDNSS, which is option 25, using the length field, which is a second"
    },
    {
      "Time_Start": 866.78,
      "Time_End": 872.1800000000001,
      "Text": " byte of the option, which is an even number, there is something wrong with the package."
    },
    {
      "Time_Start": 872.1800000000001,
      "Time_End": 878.1,
      "Text": " And if that happens, then we flag the packet, otherwise the detection logic jumps to the"
    },
    {
      "Time_Start": 878.1,
      "Time_End": 882.98,
      "Text": " next 8 bytes of the packet and doing exactly the same verification."
    },
    {
      "Time_Start": 882.98,
      "Time_End": 888.62,
      "Text": " And they also wrote a detection signature in the Lua script, which was quite long."
    },
    {
      "Time_Start": 888.62,
      "Time_End": 894.98,
      "Text": " But the essence of this detection, I screenshot here on the slide, which is these two lines"
    },
    {
      "Time_Start": 894.98,
      "Time_End": 895.98,
      "Text": " of Lua script."
    },
    {
      "Time_Start": 895.98,
      "Time_End": 905.26,
      "Text": " Essentially, if the option type is 25 for the ECPV6 array, which will represent RDNSS,"
    },
    {
      "Time_Start": 905.26,
      "Time_End": 911.1,
      "Text": " the option packet, and the length is more than 3 in numbers, but at the same time it's"
    },
    {
      "Time_Start": 911.1,
      "Time_End": 914.62,
      "Text": " also an even number, we flag this package."
    },
    {
      "Time_Start": 914.62,
      "Time_End": 917.74,
      "Text": " So it gives us much more information than before."
    },
    {
      "Time_Start": 917.74,
      "Time_End": 923.3,
      "Text": " So at first, we know that we need to send RDNSS packet."
    },
    {
      "Time_Start": 923.3,
      "Time_End": 927.42,
      "Text": " So it's much more concrete than just ECPV6 array."
    },
    {
      "Time_Start": 927.42,
      "Time_End": 932.1,
      "Text": " We know it's array, and also we know it must be RDNSS package."
    },
    {
      "Time_Start": 932.1,
      "Time_End": 937.94,
      "Text": " Additionally, we also learned that the problem is with an even number in the header length"
    },
    {
      "Time_Start": 937.94,
      "Time_End": 942.66,
      "Text": " field, which gives us a lot of interesting information already, because it's related"
    },
    {
      "Time_Start": 942.66,
      "Time_End": 944.5,
      "Text": " to the length itself."
    },
    {
      "Time_Start": 944.5,
      "Time_End": 950.0600000000001,
      "Text": " And additionally, we know that RDNSS parcel will read the last 8 bytes as the next packet's"
    },
    {
      "Time_Start": 950.0600000000001,
      "Time_End": 953.4200000000001,
      "Text": " header, because it jumps every 8 bytes."
    },
    {
      "Time_Start": 953.4200000000001,
      "Time_End": 957.02,
      "Text": " So that's kind of a lot of information to start poking around."
    },
    {
      "Time_Start": 957.22,
      "Time_End": 963.9,
      "Text": " However, before we go there, I'm starting to read the description about RDNSS itself,"
    },
    {
      "Time_Start": 963.9,
      "Time_End": 971.6999999999999,
      "Text": " and we learned that this is one of the ECPV6 array headers options, which looks like that."
    },
    {
      "Time_Start": 971.6999999999999,
      "Time_End": 975.14,
      "Text": " That's the screenshot from the RFC."
    },
    {
      "Time_Start": 975.14,
      "Time_End": 979.66,
      "Text": " So we know there's various different fields in this packet, however, we also know that"
    },
    {
      "Time_Start": 979.66,
      "Time_End": 982.9,
      "Text": " we are interested in that field, which is length."
    },
    {
      "Time_Start": 982.9,
      "Time_End": 988.06,
      "Text": " And if you look closer on the description of the length for the RDNSS in the RFC, we"
    },
    {
      "Time_Start": 988.06,
      "Time_End": 992.02,
      "Text": " end up in that description."
    },
    {
      "Time_Start": 992.02,
      "Time_End": 993.62,
      "Text": " And briefly, what does it say?"
    },
    {
      "Time_Start": 993.62,
      "Time_End": 997.02,
      "Text": " It says that it's an 8-bit unsigned integer."
    },
    {
      "Time_Start": 997.02,
      "Time_End": 1006.0,
      "Text": " And this field length, it includes also the length of the type and the left field itself."
    },
    {
      "Time_Start": 1006.0,
      "Time_End": 1011.1,
      "Text": " So if you have length set to any kind of value, it already must be non-zero, because it already"
    },
    {
      "Time_Start": 1011.1,
      "Time_End": 1015.58,
      "Text": " needs to carry the information about the length of itself plus the length of the type"
    },
    {
      "Time_Start": 1015.58,
      "Time_End": 1016.98,
      "Text": " field."
    },
    {
      "Time_Start": 1016.98,
      "Time_End": 1024.3,
      "Text": " Additionally, it's being carried information count as a unit of 8 octets, and the dominion"
    },
    {
      "Time_Start": 1024.3,
      "Time_End": 1026.3,
      "Text": " value of that is 3."
    },
    {
      "Time_Start": 1026.3,
      "Time_End": 1032.58,
      "Text": " Which means that if you have RDNSS option send as a part of the array package, it means"
    },
    {
      "Time_Start": 1032.58,
      "Time_End": 1036.14,
      "Text": " that we need to send at least one IPv6 packet."
    },
    {
      "Time_Start": 1036.14,
      "Time_End": 1039.3,
      "Text": " And if that happens, that we know that the value must be 3."
    },
    {
      "Time_Start": 1039.3,
      "Time_End": 1045.82,
      "Text": " However, if you want to carry more than one IPv6 packet, we need to add to the length"
    },
    {
      "Time_Start": 1045.82,
      "Time_End": 1047.1,
      "Text": " number 2."
    },
    {
      "Time_Start": 1047.1,
      "Time_End": 1053.58,
      "Text": " So if you want to carry two IPv6 addresses, then the length will have the value 5."
    },
    {
      "Time_Start": 1053.58,
      "Time_End": 1057.3799999999999,
      "Text": " If you want three IPv6 packets, the length will have value 7."
    },
    {
      "Time_Start": 1057.3799999999999,
      "Time_End": 1063.78,
      "Text": " So what it tells us at first, that the bug is in the even number, but the description"
    },
    {
      "Time_Start": 1063.78,
      "Time_End": 1069.46,
      "Text": " says that there should never be an even number as a length value in the length field."
    },
    {
      "Time_Start": 1069.46,
      "Time_End": 1072.94,
      "Text": " So this is kind of interesting, we know what to look for."
    },
    {
      "Time_Start": 1072.94,
      "Time_End": 1079.22,
      "Text": " And also we know that we always, when we add the new IPv6 address to the RDNSS packets,"
    },
    {
      "Time_Start": 1079.22,
      "Time_End": 1082.72,
      "Text": " we also need to increment the length value by 2."
    },
    {
      "Time_Start": 1082.72,
      "Time_End": 1089.3799999999999,
      "Text": " The reason is why it's by 2, because the units are being counted by 8, and IPv6 has the length,"
    },
    {
      "Time_Start": 1089.3799999999999,
      "Time_End": 1092.78,
      "Text": " the address of the IPv6 has length of 16 bytes."
    },
    {
      "Time_Start": 1092.78,
      "Time_End": 1098.18,
      "Text": " So that's why if we have a full IPv6 address, we need to have 2 octets, that's why we increase"
    },
    {
      "Time_Start": 1098.18,
      "Time_End": 1099.62,
      "Text": " them by 2."
    },
    {
      "Time_Start": 1099.62,
      "Time_End": 1104.34,
      "Text": " And because we start with the non-even number, that's why we will never be able to generate"
    },
    {
      "Time_Start": 1104.34,
      "Time_End": 1108.3799999999999,
      "Text": " non-even number with the correct RDNSS packets."
    },
    {
      "Time_Start": 1108.3799999999999,
      "Time_End": 1111.7,
      "Text": " And that's like tons of information for us."
    },
    {
      "Time_Start": 1111.7,
      "Time_End": 1117.1399999999999,
      "Text": " So I wanted to start a test and find out what's really going on."
    },
    {
      "Time_Start": 1117.1399999999999,
      "Time_End": 1121.78,
      "Text": " But to be able to do that, I need to know what to monitor to be able to run any kind"
    },
    {
      "Time_Start": 1121.78,
      "Time_End": 1125.06,
      "Text": " of the tests on the Windows kernel itself."
    },
    {
      "Time_Start": 1125.06,
      "Time_End": 1131.06,
      "Text": " So I started to look about all of the symbols related to the TCPIP driver in the kernel,"
    },
    {
      "Time_Start": 1131.06,
      "Time_End": 1135.1399999999999,
      "Text": " which is related to the router advertisement and RDNSS."
    },
    {
      "Time_Start": 1135.1399999999999,
      "Time_End": 1139.1399999999999,
      "Text": " And I found these two pretty functions."
    },
    {
      "Time_Start": 1139.1399999999999,
      "Time_End": 1147.54,
      "Text": " First of all, it's IPv6pHandleRouterAdvertisement, and another one, IPv6pUpdateRDNSS."
    },
    {
      "Time_Start": 1147.54,
      "Time_End": 1152.34,
      "Text": " And both of these functions should be related to the RDNSS, so related to the bug, which"
    },
    {
      "Time_Start": 1152.34,
      "Time_End": 1154.3,
      "Text": " we'll try to exploit."
    },
    {
      "Time_Start": 1154.3,
      "Time_End": 1160.02,
      "Text": " So I put the breakpoint on them, and then I started to think how to quickly send an"
    },
    {
      "Time_Start": 1160.02,
      "Time_End": 1164.46,
      "Text": " ICMPv6 array packet with the RDNSS option."
    },
    {
      "Time_Start": 1164.46,
      "Time_End": 1171.46,
      "Text": " And I wanted to do it fast, because I want to test at first if I'm poking in the correct"
    },
    {
      "Time_Start": 1171.46,
      "Time_End": 1172.8999999999999,
      "Text": " code."
    },
    {
      "Time_Start": 1172.8999999999999,
      "Time_End": 1176.54,
      "Text": " And the best option to do that is to use SCAPI."
    },
    {
      "Time_Start": 1176.54,
      "Time_End": 1182.78,
      "Text": " And SCAPI could be carried as a self-contained program, or could be also carried as a model"
    },
    {
      "Time_Start": 1182.78,
      "Time_End": 1184.18,
      "Text": " for Python."
    },
    {
      "Time_Start": 1184.18,
      "Time_End": 1189.98,
      "Text": " So I wrote this very simple SCAPI script, which sends the RDNSSS packets."
    },
    {
      "Time_Start": 1189.98,
      "Time_End": 1195.26,
      "Text": " In short, at the top of the script, I declare the destination address and source address."
    },
    {
      "Time_Start": 1195.26,
      "Time_End": 1200.22,
      "Text": " Then I create the RDNSSS option header, which I fill."
    },
    {
      "Time_Start": 1200.22,
      "Time_End": 1207.02,
      "Text": " I set the length to 7, because I want to send three IPv6 packets, which will have value"
    },
    {
      "Time_Start": 1207.02,
      "Time_End": 1208.8600000000001,
      "Text": " 8 bytes."
    },
    {
      "Time_Start": 1208.8600000000001,
      "Time_End": 1211.54,
      "Text": " And then I just, on the bottom, just send that."
    },
    {
      "Time_Start": 1211.54,
      "Time_End": 1213.6200000000001,
      "Text": " It's pretty simple and quick."
    },
    {
      "Time_Start": 1213.6200000000001,
      "Time_End": 1221.66,
      "Text": " But when I did that, when the packet was sent, I realized that the first function, IPv6pHandleRotorAdvertisement,"
    },
    {
      "Time_Start": 1221.66,
      "Time_End": 1223.1000000000001,
      "Text": " the breakpoint was hit."
    },
    {
      "Time_Start": 1223.1000000000001,
      "Time_End": 1230.18,
      "Text": " However, the second function, which is UpdateRDNSSS function, was not hit, which is kind of weird."
    },
    {
      "Time_Start": 1230.18,
      "Time_End": 1234.18,
      "Text": " Because the packet is correct, the SCAPI generated correct packets."
    },
    {
      "Time_Start": 1234.18,
      "Time_End": 1238.0600000000002,
      "Text": " However, for some reasons, the UpdateRDNSSS was never executed."
    },
    {
      "Time_Start": 1238.0600000000002,
      "Time_End": 1241.3,
      "Text": " And I was wondering why, like what's going on?"
    },
    {
      "Time_Start": 1241.3,
      "Time_End": 1246.5,
      "Text": " So I run the debugger, and I run the single step."
    },
    {
      "Time_Start": 1246.5,
      "Time_End": 1253.42,
      "Text": " And in the end, end up executing this piece of assembly code, which you can see here on the slide."
    },
    {
      "Time_Start": 1253.42,
      "Time_End": 1254.8200000000002,
      "Text": " So what's there?"
    },
    {
      "Time_Start": 1255.46,
      "Time_End": 1261.54,
      "Text": " What does this specific function, this specific instruction do?"
    },
    {
      "Time_Start": 1261.54,
      "Time_End": 1270.26,
      "Text": " Essentially, the register R10, it's pointing to this piece of the memory, which keeps exactly"
    },
    {
      "Time_Start": 1270.26,
      "Time_End": 1271.7,
      "Text": " the packet which we sent."
    },
    {
      "Time_Start": 1271.7,
      "Time_End": 1278.26,
      "Text": " So under R10, pointer for R10 points to the memory with the entire packet which we sent."
    },
    {
      "Time_Start": 1278.26,
      "Time_End": 1285.26,
      "Text": " And then, I realized that I never pass the check, which I mark here on the red."
    },
    {
      "Time_Start": 1285.26,
      "Time_End": 1290.74,
      "Text": " So compare of register R8 with the byte 0xFE."
    },
    {
      "Time_Start": 1290.74,
      "Time_End": 1293.46,
      "Text": " I always was failing that specific check."
    },
    {
      "Time_Start": 1293.46,
      "Time_End": 1298.66,
      "Text": " And I was starting to wonder, like, why, like, what's the story behind it?"
    },
    {
      "Time_Start": 1298.66,
      "Time_End": 1304.78,
      "Text": " Why at first in the parsing logic, there is some kind of hard-coded value, which is 0xFE,"
    },
    {
      "Time_Start": 1304.78,
      "Time_End": 1307.34,
      "Text": " which is related to the packet which I sent."
    },
    {
      "Time_Start": 1307.34,
      "Time_End": 1313.9399999999998,
      "Text": " So then I started to look what is the first bytes in the packets under R10, because the"
    },
    {
      "Time_Start": 1313.9399999999998,
      "Time_End": 1321.06,
      "Text": " first instruction, it copies the first byte from the R10, pointer of the R10, to the R8"
    },
    {
      "Time_Start": 1321.06,
      "Time_End": 1324.1799999999998,
      "Text": " register, which is later compared to the 0xFE."
    },
    {
      "Time_Start": 1324.1799999999998,
      "Time_End": 1330.1799999999998,
      "Text": " And then I realized that the first bytes in the packets is, in fact, keeping the source"
    },
    {
      "Time_Start": 1330.1799999999998,
      "Time_End": 1336.4599999999998,
      "Text": " address of the IPv6, which I sent from my test's copy script."
    },
    {
      "Time_Start": 1336.58,
      "Time_End": 1339.3,
      "Text": " And it was correlated to the specific address."
    },
    {
      "Time_Start": 1339.3,
      "Time_End": 1347.98,
      "Text": " And the first byte from this address is FD, which was hard-coded and compared to the 0xFE."
    },
    {
      "Time_Start": 1347.98,
      "Time_End": 1354.3400000000001,
      "Text": " So why there is a logic who compares and hard-coded the value of the IPv6 address?"
    },
    {
      "Time_Start": 1354.3400000000001,
      "Time_End": 1355.94,
      "Text": " And I was very surprised."
    },
    {
      "Time_Start": 1355.94,
      "Time_End": 1361.02,
      "Text": " But then I started to poke around and on the internet, and I end up reading some kind of"
    },
    {
      "Time_Start": 1361.02,
      "Time_End": 1364.14,
      "Text": " documentation about IPv6."
    },
    {
      "Time_Start": 1364.14,
      "Time_End": 1368.5,
      "Text": " And I realized that 0xFE is a byte."
    },
    {
      "Time_Start": 1368.5,
      "Time_End": 1373.18,
      "Text": " So any address who starts with the FE byte, it means this is an address of the link local"
    },
    {
      "Time_Start": 1373.18,
      "Time_End": 1380.66,
      "Text": " prefix, which means that if I want to pass this check, I need to create a source address,"
    },
    {
      "Time_Start": 1380.66,
      "Time_End": 1386.26,
      "Text": " this kind of address, which will pass the definition of link local prefix address."
    },
    {
      "Time_Start": 1386.26,
      "Time_End": 1391.22,
      "Text": " In the IPv6 world, it more or less means that you are in the local network."
    },
    {
      "Time_Start": 1391.22,
      "Time_End": 1400.58,
      "Text": " So in IPv4 world, it will be some kind of equivalence of address 192.168, etc., etc."
    },
    {
      "Time_Start": 1400.58,
      "Time_End": 1405.74,
      "Text": " So you're coming to packets from the intranet, not from the internet, essentially."
    },
    {
      "Time_Start": 1405.74,
      "Time_End": 1407.94,
      "Text": " And this is kind of interesting."
    },
    {
      "Time_Start": 1407.94,
      "Time_End": 1411.58,
      "Text": " The reason why, because this is the first limitation of this bug, that if you really"
    },
    {
      "Time_Start": 1411.58,
      "Time_End": 1417.46,
      "Text": " want to trigger this bug, we must be able to send the local link address as a source"
    },
    {
      "Time_Start": 1417.46,
      "Time_End": 1418.46,
      "Text": " address."
    },
    {
      "Time_Start": 1418.46,
      "Time_End": 1421.14,
      "Text": " Otherwise, we won't be able to trigger this bug."
    },
    {
      "Time_Start": 1421.14,
      "Time_End": 1426.7800000000002,
      "Text": " And originally, when Microsoft published the bulletin regarding this bug, they were"
    },
    {
      "Time_Start": 1426.7800000000002,
      "Time_End": 1433.5400000000002,
      "Text": " assigning the CVSS score a 9.8, which is, I think, one of the highest possible."
    },
    {
      "Time_Start": 1433.5400000000002,
      "Time_End": 1437.5,
      "Text": " And they were claiming that you are able to exploit this bug from the internet itself."
    },
    {
      "Time_Start": 1437.5,
      "Time_End": 1443.14,
      "Text": " However, when I published my write-up in the blog post, they changed the CVSS to the 8.5,"
    },
    {
      "Time_Start": 1443.14,
      "Time_End": 1444.6200000000001,
      "Text": " I believe."
    },
    {
      "Time_Start": 1444.6200000000001,
      "Time_End": 1446.18,
      "Text": " So they reduced the CVSS score."
    },
    {
      "Time_Start": 1446.18,
      "Time_End": 1450.5,
      "Text": " I don't know if it's related to my publication, or if they just realized by themselves that"
    },
    {
      "Time_Start": 1450.58,
      "Time_End": 1454.7,
      "Text": " you physically cannot exploit this bug if you are not in the local link network."
    },
    {
      "Time_Start": 1454.7,
      "Time_End": 1459.66,
      "Text": " However, that's what I found to be able to exploit this bug, that the source address"
    },
    {
      "Time_Start": 1459.66,
      "Time_End": 1464.74,
      "Text": " must be sent from the link local prefix address from the APB6, which must include the first"
    },
    {
      "Time_Start": 1464.74,
      "Time_End": 1466.74,
      "Text": " byte as 0xfe."
    },
    {
      "Time_Start": 1466.74,
      "Time_End": 1469.38,
      "Text": " So I quickly fixed that."
    },
    {
      "Time_Start": 1469.38,
      "Time_End": 1472.66,
      "Text": " And I wanted to trigger the bug."
    },
    {
      "Time_Start": 1472.66,
      "Time_End": 1477.3,
      "Text": " So I sent the packet from the correct local link prefix address."
    },
    {
      "Time_Start": 1477.3,
      "Time_End": 1484.02,
      "Text": " However, to be able to trigger the bug, we need to set the length option in the RDNSSS,"
    },
    {
      "Time_Start": 1484.02,
      "Time_End": 1487.4199999999998,
      "Text": " which is a second byte, to be an even number."
    },
    {
      "Time_Start": 1487.4199999999998,
      "Time_End": 1492.94,
      "Text": " And then, when I did that, I ended up in the handler for the RDNSSS, which were ending"
    },
    {
      "Time_Start": 1492.94,
      "Time_End": 1496.1399999999999,
      "Text": " up executing this specific piece of code."
    },
    {
      "Time_Start": 1496.1399999999999,
      "Time_End": 1497.98,
      "Text": " So what do we see from this instruction?"
    },
    {
      "Time_Start": 1497.98,
      "Time_End": 1505.58,
      "Text": " So at first, there is a red len field from the packets, which is pointing to the pointer"
    },
    {
      "Time_Start": 1505.62,
      "Time_End": 1507.1,
      "Text": " rbx plus one."
    },
    {
      "Time_Start": 1507.1,
      "Time_End": 1513.1399999999999,
      "Text": " And then, from the value of the length, there is a subtraction of number one."
    },
    {
      "Time_Start": 1513.1399999999999,
      "Time_End": 1517.8999999999999,
      "Text": " And the result of that, len minus one, is being divided by two."
    },
    {
      "Time_Start": 1517.8999999999999,
      "Time_End": 1523.74,
      "Text": " So essentially, in the pseudo logic, we could somehow generate this kind of pseudo code."
    },
    {
      "Time_Start": 1523.74,
      "Time_End": 1528.02,
      "Text": " Like, we read the length, we subtract one, and then we divide by two."
    },
    {
      "Time_Start": 1528.02,
      "Time_End": 1533.26,
      "Text": " And this is the result of the parsing of the length field for the RDNSSS."
    },
    {
      "Time_Start": 1533.78,
      "Time_End": 1536.94,
      "Text": " However, as we can see, there is a problem with the even number."
    },
    {
      "Time_Start": 1536.94,
      "Time_End": 1541.7,
      "Text": " Because if you have even number and non-even number, there could be two values generating"
    },
    {
      "Time_Start": 1541.7,
      "Time_End": 1542.98,
      "Text": " exactly the same value."
    },
    {
      "Time_Start": 1542.98,
      "Time_End": 1549.22,
      "Text": " So for example, if you've assigned the length as a value eight, and we subtract one and"
    },
    {
      "Time_Start": 1549.22,
      "Time_End": 1555.1,
      "Text": " divide by two, we will have as a result for this operation as three, if we're speaking"
    },
    {
      "Time_Start": 1555.1,
      "Time_End": 1556.78,
      "Text": " about the integers."
    },
    {
      "Time_Start": 1556.78,
      "Time_End": 1562.7,
      "Text": " And the same will have exactly the same output value for the length number seven."
    },
    {
      "Time_Start": 1562.7,
      "Time_End": 1567.38,
      "Text": " Because seven minus one divided by two, and eight minus one divided by two, both of them"
    },
    {
      "Time_Start": 1567.38,
      "Time_End": 1571.18,
      "Text": " generate you the result as three."
    },
    {
      "Time_Start": 1571.18,
      "Time_End": 1574.22,
      "Text": " And obviously, one of them is correct, and one of them is not."
    },
    {
      "Time_Start": 1574.22,
      "Time_End": 1577.8600000000001,
      "Text": " So that's kind of interesting."
    },
    {
      "Time_Start": 1577.8600000000001,
      "Time_End": 1581.66,
      "Text": " And then I'm starting to trigger this back again, under the sniffer."
    },
    {
      "Time_Start": 1581.66,
      "Time_End": 1584.6200000000001,
      "Text": " And I run one of the sniffer and do a screenshot here."
    },
    {
      "Time_Start": 1584.6200000000001,
      "Time_End": 1585.9,
      "Text": " And this is what I saw."
    },
    {
      "Time_Start": 1585.9,
      "Time_End": 1590.78,
      "Text": " So essentially, when I send this packet with an even number, the sniffer, which was Wireshark"
    },
    {
      "Time_Start": 1590.78,
      "Time_End": 1595.7,
      "Text": " at the time, starting to generate kind of interesting output."
    },
    {
      "Time_Start": 1595.7,
      "Time_End": 1601.3,
      "Text": " So I just sent a DNSSS packet, however, as an option to the array."
    },
    {
      "Time_Start": 1601.3,
      "Time_End": 1607.46,
      "Text": " However, in the sniffer, they told me some kind of additional header, which I never sent."
    },
    {
      "Time_Start": 1607.46,
      "Time_End": 1609.1399999999999,
      "Text": " And it's kind of interesting."
    },
    {
      "Time_Start": 1609.1399999999999,
      "Time_End": 1616.3,
      "Text": " And then I realized that the new header, which the stack thinks it's there, the type is unknown,"
    },
    {
      "Time_Start": 1616.3,
      "Time_End": 1619.18,
      "Text": " with the length kind of big, like 187."
    },
    {
      "Time_Start": 1619.18,
      "Time_End": 1627.26,
      "Text": " However, I mark here on the yellow and red box that the value of the type of the next"
    },
    {
      "Time_Start": 1627.26,
      "Time_End": 1633.22,
      "Text": " header and the length of the type of the next header is representing exactly that bytes,"
    },
    {
      "Time_Start": 1633.22,
      "Time_End": 1640.14,
      "Text": " which are part of the IPv6 address carried in the RDSSS option."
    },
    {
      "Time_Start": 1640.14,
      "Time_End": 1647.78,
      "Text": " What physically happened, then the last octet of the last IPv6 carried by the RDSSS has"
    },
    {
      "Time_Start": 1647.78,
      "Time_End": 1653.82,
      "Text": " been treated as the next header when you send the length as an even number."
    },
    {
      "Time_Start": 1653.82,
      "Time_End": 1660.82,
      "Text": " So essentially, it means that if you send an even number, the stack of parser of TCP"
    },
    {
      "Time_Start": 1660.82,
      "Time_End": 1667.42,
      "Text": " IPv6 is starting to badly calculate where is the next header after RDSSS."
    },
    {
      "Time_Start": 1667.42,
      "Time_End": 1674.18,
      "Text": " And they're starting to use the IPv6 value address of the IPv6 as a value of the next"
    },
    {
      "Time_Start": 1674.18,
      "Time_End": 1675.18,
      "Text": " header."
    },
    {
      "Time_Start": 1675.18,
      "Time_End": 1682.02,
      "Text": " Therefore, they should start doing this after the last IPv6, not as the middle of them."
    },
    {
      "Time_Start": 1682.02,
      "Time_End": 1692.3,
      "Text": " So essentially, what happens is that you are able to smuggle one hidden packet there, one"
    },
    {
      "Time_Start": 1692.3,
      "Time_End": 1694.94,
      "Text": " hidden header here."
    },
    {
      "Time_Start": 1694.94,
      "Time_End": 1702.38,
      "Text": " However, what packet could we smuggle as a hidden one to generate something bad?"
    },
    {
      "Time_Start": 1702.38,
      "Time_End": 1707.1000000000001,
      "Text": " And this is kind of interesting question, because we have a lot of options."
    },
    {
      "Time_Start": 1707.1000000000001,
      "Time_End": 1711.74,
      "Text": " When we were sent just a random value, we didn't generate any kind of busking of that"
    },
    {
      "Time_Start": 1711.74,
      "Time_End": 1713.2600000000002,
      "Text": " or nothing like that."
    },
    {
      "Time_Start": 1713.2600000000002,
      "Time_End": 1718.5,
      "Text": " Just we realized that the packet was correctly parsed, but then in the end, they're starting"
    },
    {
      "Time_Start": 1718.5,
      "Time_End": 1721.5800000000002,
      "Text": " to badly parse IPv6 as the next header."
    },
    {
      "Time_Start": 1721.5800000000002,
      "Time_End": 1727.8600000000001,
      "Text": " So what could we smuggle in the IPv6 to emulate some kind of another header, which will generate"
    },
    {
      "Time_Start": 1727.8600000000001,
      "Time_End": 1730.5,
      "Text": " something badly on the Windows side?"
    },
    {
      "Time_Start": 1730.5,
      "Time_End": 1734.62,
      "Text": " And essentially, there is a lot of options, and I listed them here."
    },
    {
      "Time_Start": 1734.62,
      "Time_End": 1739.82,
      "Text": " And in fact, I didn't know and I don't know which one is supposed to be that one who can"
    },
    {
      "Time_Start": 1739.82,
      "Time_End": 1743.38,
      "Text": " generate kind of problematic situation for Windows."
    },
    {
      "Time_Start": 1743.38,
      "Time_End": 1745.46,
      "Text": " So how can we tackle this problem?"
    },
    {
      "Time_Start": 1745.46,
      "Time_End": 1746.66,
      "Text": " Which option should we use?"
    },
    {
      "Time_Start": 1746.66,
      "Time_End": 1751.86,
      "Text": " We can in fact analyze one by one in the details, but it will take us a lot of time."
    },
    {
      "Time_Start": 1751.86,
      "Time_End": 1755.22,
      "Text": " And they wanted to generate proof of concept as fast as possible."
    },
    {
      "Time_Start": 1755.22,
      "Time_End": 1758.5,
      "Text": " So I started to think that the best option is to brute force them."
    },
    {
      "Time_Start": 1758.5,
      "Time_End": 1760.46,
      "Text": " However, how do you brute force it?"
    },
    {
      "Time_Start": 1760.46,
      "Time_End": 1763.3400000000001,
      "Text": " Is it even possible to brute force that?"
    },
    {
      "Time_Start": 1763.3400000000001,
      "Time_End": 1769.3400000000001,
      "Text": " And it turns out it's possible because all of the available options must follow exactly"
    },
    {
      "Time_Start": 1769.3400000000001,
      "Time_End": 1773.94,
      "Text": " the same header layout before carrying the own information."
    },
    {
      "Time_Start": 1773.94,
      "Time_End": 1778.22,
      "Text": " So the beginning of the header must always follow the same bytes layout."
    },
    {
      "Time_Start": 1778.22,
      "Time_End": 1786.02,
      "Text": " So if you want to change the option for the array, we must always generate this kind of"
    },
    {
      "Time_Start": 1786.02,
      "Time_End": 1787.02,
      "Text": " layout."
    },
    {
      "Time_Start": 1787.02,
      "Time_End": 1789.56,
      "Text": " And as a type, we just create a special number."
    },
    {
      "Time_Start": 1789.6599999999999,
      "Time_End": 1795.76,
      "Text": " So the type 22, sorry, 24, we'll have, this is like a map option."
    },
    {
      "Time_Start": 1795.76,
      "Time_End": 1798.8,
      "Text": " Type 138, we'll say it's a cart request option."
    },
    {
      "Time_Start": 1798.8,
      "Time_End": 1803.0,
      "Text": " So essentially, if we're starting to brute force the first byte, it will be represented"
    },
    {
      "Time_Start": 1803.0,
      "Time_End": 1807.0,
      "Text": " as a type of the array option header."
    },
    {
      "Time_Start": 1807.0,
      "Time_End": 1812.48,
      "Text": " So I'm starting to think about doing this."
    },
    {
      "Time_Start": 1812.48,
      "Time_End": 1818.36,
      "Text": " However, before doing that, I'm starting to test one more interesting scenario."
    },
    {
      "Time_Start": 1818.3600000000001,
      "Time_End": 1823.2800000000002,
      "Text": " Like what will happen if I'm starting to smuggle exactly the same buggy header in the"
    },
    {
      "Time_Start": 1823.2800000000002,
      "Time_End": 1825.0800000000002,
      "Text": " header?"
    },
    {
      "Time_Start": 1825.0800000000002,
      "Time_End": 1832.4,
      "Text": " So if in the rdnsss option, I will smuggle as a hidden header exactly rdnsss with exactly"
    },
    {
      "Time_Start": 1832.4,
      "Time_End": 1838.3600000000001,
      "Text": " the same buggy situation carrying even number as a length field."
    },
    {
      "Time_Start": 1838.3600000000001,
      "Time_End": 1842.1200000000001,
      "Text": " And then I realized that I could trigger exactly the same bug recursively."
    },
    {
      "Time_Start": 1842.1200000000001,
      "Time_End": 1846.44,
      "Text": " So essentially, by smuggling various rdnsss headers, I could trigger a recursively bug"
    },
    {
      "Time_Start": 1846.44,
      "Time_End": 1848.3200000000002,
      "Text": " as long as I could."
    },
    {
      "Time_Start": 1848.32,
      "Time_End": 1851.2,
      "Text": " It's kind of funny, but not very practical."
    },
    {
      "Time_Start": 1851.2,
      "Time_End": 1854.96,
      "Text": " But it's possible to smuggle the bug with the buggy header, with the buggy header, with"
    },
    {
      "Time_Start": 1854.96,
      "Time_End": 1858.96,
      "Text": " the buggy header, so on."
    },
    {
      "Time_Start": 1858.96,
      "Time_End": 1865.8799999999999,
      "Text": " So however, by doing this test, I found interesting that when I send this recursive headers in"
    },
    {
      "Time_Start": 1865.8799999999999,
      "Time_End": 1870.76,
      "Text": " the headers with the buggy headers, that not all of the breakpoints were hit in the same"
    },
    {
      "Time_Start": 1870.76,
      "Time_End": 1871.76,
      "Text": " time."
    },
    {
      "Time_Start": 1871.76,
      "Time_End": 1878.8,
      "Text": " So ePVC's pHandlerRotorAdvertisement function was hit as a function only once when I set"
    },
    {
      "Time_Start": 1878.8,
      "Time_End": 1879.8,
      "Text": " the breakpoints."
    },
    {
      "Time_Start": 1879.8,
      "Time_End": 1885.96,
      "Text": " However, the UpdateRdnsss hit as many times as I smuggled the recursively fake headers."
    },
    {
      "Time_Start": 1885.96,
      "Time_End": 1890.72,
      "Text": " And I'm starting to think, like, this is kind of interesting, like, how is it even working"
    },
    {
      "Time_Start": 1890.72,
      "Time_End": 1898.44,
      "Text": " that RotorAdvertisement is only hit once, but UpdateRdnsss are hit so many times?"
    },
    {
      "Time_Start": 1898.44,
      "Time_End": 1901.8,
      "Text": " And to be able to do that, of course, we need to reverse engineer that."
    },
    {
      "Time_Start": 1901.8,
      "Time_End": 1908.28,
      "Text": " So I run IDA, and I'm starting to analyze the HandlerRotorAdvertisement function."
    },
    {
      "Time_Start": 1908.28,
      "Time_End": 1913.4,
      "Text": " And what I found out, it was pretty interesting, because I realized that this function has"
    },
    {
      "Time_Start": 1913.4,
      "Time_End": 1914.8,
      "Text": " two loops."
    },
    {
      "Time_Start": 1914.8,
      "Time_End": 1921.56,
      "Text": " First, in the first loop, all of the data from all of the headers are validated, of"
    },
    {
      "Time_Start": 1921.56,
      "Time_End": 1928.36,
      "Text": " course, except the fake header, which arrives through the bug in the UpdateRdnsss option."
    },
    {
      "Time_Start": 1928.36,
      "Time_End": 1930.3999999999999,
      "Text": " However, that's what they do."
    },
    {
      "Time_Start": 1930.3999999999999,
      "Time_End": 1934.32,
      "Text": " So at the beginning, they're trying to find out all of the necessary information from"
    },
    {
      "Time_Start": 1934.32,
      "Time_End": 1940.2,
      "Text": " all of the headers in the ePVC, and trying to validate them exactly there at that point"
    },
    {
      "Time_Start": 1940.2,
      "Time_End": 1941.2,
      "Text": " of time."
    },
    {
      "Time_Start": 1941.2,
      "Time_End": 1945.3999999999999,
      "Text": " Then they execute a few other code, and in the end, there is a second loop, who have"
    },
    {
      "Time_Start": 1945.3999999999999,
      "Time_End": 1951.0,
      "Text": " assumption that all of the data is already validated, and they don't do many checks at"
    },
    {
      "Time_Start": 1951.0,
      "Time_End": 1952.0,
      "Text": " all."
    },
    {
      "Time_Start": 1952.0,
      "Time_End": 1956.0,
      "Text": " They just skip them, because they trust exactly the data, because they just validated them"
    },
    {
      "Time_Start": 1956.0,
      "Time_End": 1958.2,
      "Text": " in the first loop before."
    },
    {
      "Time_Start": 1958.2,
      "Time_End": 1963.44,
      "Text": " And this is kind of interesting, that gives us pretty interesting primitives, in case"
    },
    {
      "Time_Start": 1963.44,
      "Time_End": 1968.26,
      "Text": " we would be able to smuggle interesting packet headers."
    },
    {
      "Time_Start": 1968.26,
      "Time_End": 1974.44,
      "Text": " So such logic gives us a huge potential, but what are the options, and what are the headers"
    },
    {
      "Time_Start": 1974.44,
      "Time_End": 1977.68,
      "Text": " which could be reacting in the second loop?"
    },
    {
      "Time_Start": 1977.68,
      "Time_End": 1984.2,
      "Text": " And then I started to brute force, and they realized that only four different types of"
    },
    {
      "Time_Start": 1984.2,
      "Time_End": 1989.88,
      "Text": " the options are being handled by the second loop, and the second loop only reacts on these"
    },
    {
      "Time_Start": 1989.88,
      "Time_End": 1994.0800000000002,
      "Text": " four different types of the options for the array."
    },
    {
      "Time_Start": 1994.0800000000002,
      "Time_End": 1999.0800000000002,
      "Text": " And it's not many, so I started to analyze all of them, each one by one."
    },
    {
      "Time_Start": 1999.0800000000002,
      "Time_End": 2004.72,
      "Text": " So the type 25, we already know, this is exactly the bug who calls the bug, and we know that"
    },
    {
      "Time_Start": 2004.72,
      "Time_End": 2011.8,
      "Text": " we can recursively call the RDNSSS with the buggy header smuggling another buggy header."
    },
    {
      "Time_Start": 2011.8,
      "Time_End": 2017.68,
      "Text": " However, it doesn't give us much, excluding that we can recursively hit the bug, but it"
    },
    {
      "Time_Start": 2017.68,
      "Time_End": 2019.84,
      "Text": " doesn't crash the machine, nothing like that."
    },
    {
      "Time_Start": 2019.84,
      "Time_End": 2025.1200000000001,
      "Text": " So I essentially went forward and I put this type as out of scope for now, because I couldn't"
    },
    {
      "Time_Start": 2025.1200000000001,
      "Time_End": 2028.24,
      "Text": " find anything interesting what I could do with it."
    },
    {
      "Time_Start": 2028.24,
      "Time_End": 2034.2,
      "Text": " Then I started to analyze the next type, which is 31, DNS search list option, and I realized"
    },
    {
      "Time_Start": 2034.2,
      "Time_End": 2036.04,
      "Text": " there's also nothing interesting."
    },
    {
      "Time_Start": 2036.04,
      "Time_End": 2041.44,
      "Text": " When you enable this option, there is only a few bits set in the packets, and that's"
    },
    {
      "Time_Start": 2041.44,
      "Time_End": 2042.44,
      "Text": " all."
    },
    {
      "Time_Start": 2042.44,
      "Time_End": 2046.8,
      "Text": " The function returns, and there is also no kind of bugs, nothing is triggered."
    },
    {
      "Time_Start": 2046.8,
      "Time_End": 2051.96,
      "Text": " So yeah, we're only left with the two types of the headers, and I'm starting to analyze"
    },
    {
      "Time_Start": 2051.96,
      "Time_End": 2057.84,
      "Text": " them, and what I realized is that both of them, like type 3 prefix information and type"
    },
    {
      "Time_Start": 2057.84,
      "Time_End": 2064.84,
      "Text": " 24 route information, they copy data to the stack via function and this getDataBuffer."
    },
    {
      "Time_Start": 2064.84,
      "Time_End": 2070.2000000000003,
      "Text": " And if you connect this information with the previously described, that the second loop"
    },
    {
      "Time_Start": 2070.2000000000003,
      "Time_End": 2075.6800000000003,
      "Text": " assumes that the data is already validated, and they do not check many things, including"
    },
    {
      "Time_Start": 2075.6800000000003,
      "Time_End": 2081.08,
      "Text": " the header itself, you already know what to do, and you know where to focus."
    },
    {
      "Time_Start": 2081.08,
      "Time_End": 2084.6400000000003,
      "Text": " You know which types you need to smuggle."
    },
    {
      "Time_Start": 2084.6400000000003,
      "Time_End": 2086.6400000000003,
      "Text": " So this is what I'm exactly starting to do."
    },
    {
      "Time_Start": 2086.64,
      "Time_End": 2092.6,
      "Text": " I'm starting, I choose just type 24, there is no reason why I shouldn't choose type 3."
    },
    {
      "Time_Start": 2092.6,
      "Time_End": 2097.3199999999997,
      "Text": " Both of them will work, I just choose randomly type 24 as a route information."
    },
    {
      "Time_Start": 2097.3199999999997,
      "Time_End": 2105.0,
      "Text": " And I put as a fake header exactly type 24, and as a size I put the maximum possible size"
    },
    {
      "Time_Start": 2105.0,
      "Time_End": 2110.44,
      "Text": " which I could set for that header, which was 0xff, because it's 8 bytes long, so the maximum"
    },
    {
      "Time_Start": 2110.44,
      "Time_End": 2112.68,
      "Text": " value is 0xff."
    },
    {
      "Time_Start": 2112.68,
      "Time_End": 2115.52,
      "Text": " So I set as a fake header exactly that."
    },
    {
      "Time_Start": 2115.52,
      "Time_End": 2117.8,
      "Text": " Then I resend the packet."
    },
    {
      "Time_Start": 2117.8,
      "Time_End": 2119.32,
      "Text": " And what happened?"
    },
    {
      "Time_Start": 2119.32,
      "Time_End": 2123.48,
      "Text": " That updateRdnSSS function breakpoint was never hit, which completely shocked me."
    },
    {
      "Time_Start": 2123.48,
      "Time_End": 2124.48,
      "Text": " It's like, why?"
    },
    {
      "Time_Start": 2124.48,
      "Time_End": 2131.64,
      "Text": " Because I was able to smuggle recursively the RdnSSS, however, when I changed the fake"
    },
    {
      "Time_Start": 2131.64,
      "Time_End": 2137.0,
      "Text": " header to type route information, even the first time updateRdnSSS was never hit."
    },
    {
      "Time_Start": 2137.0,
      "Time_End": 2142.6,
      "Text": " And I was like, surprised, like, I didn't really change anything, like, why doesn't it work anymore?"
    },
    {
      "Time_Start": 2142.6,
      "Time_End": 2148.12,
      "Text": " So I'm starting to analyze the route investment handler again, and I realized that I always"
    },
    {
      "Time_Start": 2148.12,
      "Time_End": 2153.2799999999997,
      "Text": " fail these checks, which are represented by this free assembly instruction."
    },
    {
      "Time_Start": 2153.2799999999997,
      "Time_End": 2161.64,
      "Text": " So essentially what is here, the register RUX or AX has a number 0x48, however, the"
    },
    {
      "Time_Start": 2161.64,
      "Time_End": 2167.24,
      "Text": " pointer, sorry, the R15 register has the value 0x40."
    },
    {
      "Time_Start": 2167.2400000000002,
      "Time_End": 2173.2000000000003,
      "Text": " So if you see, the difference between both of these registers are exactly 0x8, which"
    },
    {
      "Time_Start": 2173.2000000000003,
      "Time_End": 2179.5200000000004,
      "Text": " is the value of the truncated packet size when we are using an even number in the RdnSSS"
    },
    {
      "Time_Start": 2179.5200000000004,
      "Time_End": 2181.0800000000004,
      "Text": " for triggering the bug."
    },
    {
      "Time_Start": 2181.0800000000004,
      "Time_End": 2186.84,
      "Text": " So essentially, because we send the packet with the even number, we're starting to say"
    },
    {
      "Time_Start": 2186.84,
      "Time_End": 2190.6000000000004,
      "Text": " how many data we expect to have in the buffers."
    },
    {
      "Time_Start": 2190.6000000000004,
      "Time_End": 2195.36,
      "Text": " But essentially, we send slightly more data, and there is exactly 8 bytes long differences."
    },
    {
      "Time_Start": 2195.36,
      "Time_End": 2201.2400000000002,
      "Text": " So how to bypass this check, and how to be able to still make it work?"
    },
    {
      "Time_Start": 2201.2400000000002,
      "Time_End": 2204.88,
      "Text": " And in fact, it's not as trivial as it sounds."
    },
    {
      "Time_Start": 2204.88,
      "Time_End": 2210.56,
      "Text": " However, the workaround requires adding more headers after the magic RdnSSS, some kind"
    },
    {
      "Time_Start": 2210.56,
      "Time_End": 2211.92,
      "Text": " of dummy headers."
    },
    {
      "Time_Start": 2211.92,
      "Time_End": 2216.6400000000003,
      "Text": " However, it's not as trivial to pass this validation, and it took me some time to create"
    },
    {
      "Time_Start": 2216.6400000000003,
      "Time_End": 2220.76,
      "Text": " the right packet layout, because if you add the extra headers, you also change the size"
    },
    {
      "Time_Start": 2220.76,
      "Time_End": 2222.1200000000003,
      "Text": " of the packet."
    },
    {
      "Time_Start": 2222.12,
      "Time_End": 2227.0,
      "Text": " And then the header length information, each of the extra headers must also match how many"
    },
    {
      "Time_Start": 2227.0,
      "Time_End": 2229.7999999999997,
      "Text": " packets are being read by NDIS."
    },
    {
      "Time_Start": 2229.7999999999997,
      "Time_End": 2234.6,
      "Text": " And you need to align them correctly to exactly not fall into the trap of this free instruction"
    },
    {
      "Time_Start": 2234.6,
      "Time_End": 2239.3199999999997,
      "Text": " of the check, when they when they validate how many headers' length has been decorated"
    },
    {
      "Time_Start": 2239.3199999999997,
      "Time_End": 2240.7999999999997,
      "Text": " and how many of them have been read."
    },
    {
      "Time_Start": 2240.7999999999997,
      "Time_End": 2241.96,
      "Text": " However, it's possible to be done."
    },
    {
      "Time_Start": 2241.96,
      "Time_End": 2247.2799999999997,
      "Text": " It took me some time, and in the end, I was able to pass this check and move forward."
    },
    {
      "Time_Start": 2247.2799999999997,
      "Time_End": 2250.2799999999997,
      "Text": " And I finally succeeded."
    },
    {
      "Time_Start": 2250.44,
      "Time_End": 2256.4,
      "Text": " But after returning from the RdnSSS function, the handler for the route information, which"
    },
    {
      "Time_Start": 2256.4,
      "Time_End": 2261.2400000000002,
      "Text": " is the fake header which I hide, was never executed."
    },
    {
      "Time_Start": 2261.2400000000002,
      "Time_End": 2265.2000000000003,
      "Text": " And I was still like, OK, I think I did everything right."
    },
    {
      "Time_Start": 2265.2000000000003,
      "Time_End": 2266.28,
      "Text": " So what's going on?"
    },
    {
      "Time_Start": 2266.28,
      "Time_End": 2269.0800000000004,
      "Text": " So obviously, I'm starting to debug."
    },
    {
      "Time_Start": 2269.0800000000004,
      "Time_End": 2274.76,
      "Text": " And in the end, I'd end up exactly executing these instructions here, listed."
    },
    {
      "Time_Start": 2274.76,
      "Time_End": 2276.92,
      "Text": " So what really happens here?"
    },
    {
      "Time_Start": 2276.92,
      "Time_End": 2286.2400000000002,
      "Text": " So essentially, in the function update RdnSSS, it reads the length from the fake header,"
    },
    {
      "Time_Start": 2286.2400000000002,
      "Time_End": 2289.04,
      "Text": " which is being read in the register ECX."
    },
    {
      "Time_Start": 2289.04,
      "Time_End": 2292.16,
      "Text": " Then ECX register is being multiplied by 8."
    },
    {
      "Time_Start": 2292.16,
      "Time_End": 2298.12,
      "Text": " This is exactly matching the standard of the RFC, because the length field is being represented"
    },
    {
      "Time_Start": 2298.12,
      "Time_End": 2299.56,
      "Text": " as an octet."
    },
    {
      "Time_Start": 2299.56,
      "Time_End": 2306.2400000000002,
      "Text": " So the length which has been read has been multiplied by 8."
    },
    {
      "Time_Start": 2306.28,
      "Time_End": 2313.96,
      "Text": " And the result of this multiplication was 0x7f8."
    },
    {
      "Time_Start": 2313.96,
      "Time_End": 2316.4,
      "Text": " So that's the value of the ECX register."
    },
    {
      "Time_Start": 2316.4,
      "Time_End": 2320.96,
      "Text": " And the reason why it happens like that, because I set the value of length of the fake header"
    },
    {
      "Time_Start": 2320.96,
      "Time_End": 2323.5200000000004,
      "Text": " as 0xff, the maximum possible."
    },
    {
      "Time_Start": 2323.5200000000004,
      "Time_End": 2328.0400000000004,
      "Text": " So 0xff multiplied by 8 gives us exactly 0x7f8."
    },
    {
      "Time_Start": 2328.0400000000004,
      "Time_End": 2332.8,
      "Text": " So this is expected, and this is exactly what we end up having here."
    },
    {
      "Time_Start": 2332.8,
      "Time_End": 2334.28,
      "Text": " And that's good."
    },
    {
      "Time_Start": 2334.28,
      "Time_End": 2341.7200000000003,
      "Text": " However, this value is being compared with the value 0xb8, which is coming from the pointer"
    },
    {
      "Time_Start": 2341.7200000000003,
      "Time_End": 2346.44,
      "Text": " R14 plus offset 18."
    },
    {
      "Time_Start": 2346.44,
      "Time_End": 2349.6400000000003,
      "Text": " So I started to think what it really means."
    },
    {
      "Time_Start": 2349.6400000000003,
      "Time_End": 2354.84,
      "Text": " And I realized that this specific pointer and structure under that specific offset,"
    },
    {
      "Time_Start": 2354.84,
      "Time_End": 2361.32,
      "Text": " it represents and indicates how much data is transferred from the packet, are still"
    },
    {
      "Time_Start": 2361.32,
      "Time_End": 2364.0400000000004,
      "Text": " left in the buffers, internal buffers."
    },
    {
      "Time_Start": 2364.04,
      "Time_End": 2371.44,
      "Text": " So essentially, they verify how much data the next header needs, and how much data have"
    },
    {
      "Time_Start": 2371.44,
      "Time_End": 2375.68,
      "Text": " been read by the TCP IP driver from the packet."
    },
    {
      "Time_Start": 2375.68,
      "Time_End": 2382.1,
      "Text": " So obviously, in this check, the ECX is much higher than the read data."
    },
    {
      "Time_Start": 2382.1,
      "Time_End": 2387.8,
      "Text": " So we expect that from the next header to read much more data that has been read from"
    },
    {
      "Time_Start": 2387.8,
      "Time_End": 2388.92,
      "Text": " the packet."
    },
    {
      "Time_Start": 2388.92,
      "Time_End": 2390.84,
      "Text": " And that's why we file this check."
    },
    {
      "Time_Start": 2390.84,
      "Time_End": 2393.52,
      "Text": " So we have, in fact, two options here to bypass it."
    },
    {
      "Time_Start": 2393.52,
      "Time_End": 2399.28,
      "Text": " We can reduce the size of the fake header, or we can add more dummy headers."
    },
    {
      "Time_Start": 2399.28,
      "Time_End": 2401.72,
      "Text": " And I essentially did two of them."
    },
    {
      "Time_Start": 2401.72,
      "Time_End": 2407.4,
      "Text": " So I reduced the fake header size to not be 0xf8, but smaller one, and I add a few more"
    },
    {
      "Time_Start": 2407.4,
      "Time_End": 2416.84,
      "Text": " dummy headers in the packets, which I increase exactly the value of R14 plus 18 in the structure."
    },
    {
      "Time_Start": 2416.84,
      "Time_End": 2421.5,
      "Text": " And I finally landed in the parser of fraud information header, yay."
    },
    {
      "Time_Start": 2421.5,
      "Time_End": 2423.44,
      "Text": " So this is exactly what I wanted to do."
    },
    {
      "Time_Start": 2423.48,
      "Time_End": 2427.96,
      "Text": " And now I expect exactly to generate some kind of a bug, because they copied the data"
    },
    {
      "Time_Start": 2427.96,
      "Time_End": 2429.28,
      "Text": " to the stack."
    },
    {
      "Time_Start": 2429.28,
      "Time_End": 2432.76,
      "Text": " So I expect to have some kind of overflow."
    },
    {
      "Time_Start": 2432.76,
      "Time_End": 2438.34,
      "Text": " And then I end up in this specific piece of code in assembly."
    },
    {
      "Time_Start": 2438.34,
      "Time_End": 2439.64,
      "Text": " And what does it do?"
    },
    {
      "Time_Start": 2439.64,
      "Time_End": 2446.6,
      "Text": " So it briefly reads the length from the fake header, which I set to that kind of value"
    },
    {
      "Time_Start": 2446.6,
      "Time_End": 2453.4,
      "Text": " that after multiplying by 8, and this multiplication is done by shifting register buff 3, it"
    },
    {
      "Time_Start": 2453.4,
      "Time_End": 2456.52,
      "Text": " generated me the value 0x100."
    },
    {
      "Time_Start": 2456.52,
      "Time_End": 2459.64,
      "Text": " So the value was 0x100 divided by 8."
    },
    {
      "Time_Start": 2459.64,
      "Time_End": 2465.26,
      "Text": " And then, next, the length is not validated, because the validation were made in the previous"
    },
    {
      "Time_Start": 2465.26,
      "Time_End": 2467.44,
      "Text": " loops in these functions."
    },
    {
      "Time_Start": 2467.44,
      "Time_End": 2471.6800000000003,
      "Text": " At least this was the assumption that the handler of fraud and information advertisement"
    },
    {
      "Time_Start": 2471.6800000000003,
      "Time_End": 2478.08,
      "Text": " will validate all of the headers and all of the sizes in the first loop, and then it doesn't"
    },
    {
      "Time_Start": 2478.08,
      "Time_End": 2479.76,
      "Text": " do any verification."
    },
    {
      "Time_Start": 2479.76,
      "Time_End": 2481.28,
      "Text": " And this is exactly what happened here."
    },
    {
      "Time_Start": 2481.28,
      "Time_End": 2486.8,
      "Text": " They just read that value, and they pass it to the function and this getDataBuffer,"
    },
    {
      "Time_Start": 2486.8,
      "Time_End": 2490.6800000000003,
      "Text": " which has been called here in the mark as yellow."
    },
    {
      "Time_Start": 2490.6800000000003,
      "Time_End": 2496.0,
      "Text": " So essentially, when this function is being executed and this getDataBuffer, it's supposed"
    },
    {
      "Time_Start": 2496.0,
      "Time_End": 2503.2000000000003,
      "Text": " to copy the length size data to the very small stack buffer, which is sized of the route"
    },
    {
      "Time_Start": 2503.2000000000003,
      "Time_End": 2505.0,
      "Text": " information header."
    },
    {
      "Time_Start": 2505.0,
      "Time_End": 2509.96,
      "Text": " So in theory, we're supposed to have a classic buffer overflow on the stack."
    },
    {
      "Time_Start": 2510.28,
      "Time_End": 2515.12,
      "Text": " However, even if you should have a classic buffer overflow on the stack, the overflow"
    },
    {
      "Time_Start": 2515.12,
      "Time_End": 2516.52,
      "Text": " didn't happen."
    },
    {
      "Time_Start": 2516.52,
      "Time_End": 2519.68,
      "Text": " And that was, again, like, why I did everything correctly."
    },
    {
      "Time_Start": 2519.68,
      "Time_End": 2523.32,
      "Text": " Why and this getDataBuffer didn't overflow it?"
    },
    {
      "Time_Start": 2523.32,
      "Time_End": 2526.08,
      "Text": " And I couldn't find the reason why."
    },
    {
      "Time_Start": 2526.08,
      "Time_End": 2533.96,
      "Text": " And moreover, the and this getDataBuffer function should return the address of that buffer where"
    },
    {
      "Time_Start": 2533.96,
      "Time_End": 2536.38,
      "Text": " it copies the data."
    },
    {
      "Time_Start": 2536.38,
      "Time_End": 2544.46,
      "Text": " So if we provide a local stack buffer as a buffer where to copy the data, exactly the"
    },
    {
      "Time_Start": 2544.46,
      "Time_End": 2548.06,
      "Text": " address of that buffer is supposed to be returned from this function."
    },
    {
      "Time_Start": 2548.06,
      "Time_End": 2552.7400000000002,
      "Text": " However, the return to address from this function was completely different from the local buffer"
    },
    {
      "Time_Start": 2552.7400000000002,
      "Time_End": 2553.7400000000002,
      "Text": " on the stack."
    },
    {
      "Time_Start": 2553.7400000000002,
      "Time_End": 2556.26,
      "Text": " Like, completely different volume, nothing related to the stack."
    },
    {
      "Time_Start": 2556.26,
      "Time_End": 2558.34,
      "Text": " And I have no idea what's really going on."
    },
    {
      "Time_Start": 2558.34,
      "Time_End": 2563.02,
      "Text": " So obviously, I need to start reverse engineer this function, analyze it, doing single step"
    },
    {
      "Time_Start": 2563.06,
      "Time_End": 2566.94,
      "Text": " and as much as possible, and analyze which is possible."
    },
    {
      "Time_Start": 2566.94,
      "Time_End": 2568.54,
      "Text": " So I started doing that."
    },
    {
      "Time_Start": 2568.54,
      "Time_End": 2573.42,
      "Text": " And then I realized that in the function and this getDataBuffer, I always return executing"
    },
    {
      "Time_Start": 2573.42,
      "Time_End": 2575.46,
      "Text": " this piece of code."
    },
    {
      "Time_Start": 2575.46,
      "Time_End": 2579.1,
      "Text": " What really happens here, I was failing this specific compare."
    },
    {
      "Time_Start": 2579.1,
      "Time_End": 2584.94,
      "Text": " And I would like to jump to the instruction after read, but I was always failing it and"
    },
    {
      "Time_Start": 2584.94,
      "Time_End": 2586.9,
      "Text": " I was returning here."
    },
    {
      "Time_Start": 2586.9,
      "Time_End": 2589.5,
      "Text": " And I didn't really know why."
    },
    {
      "Time_Start": 2589.5,
      "Time_End": 2596.86,
      "Text": " So I started to analyze that rcx register has the size of the local buffer on the stack."
    },
    {
      "Time_Start": 2596.86,
      "Time_End": 2605.78,
      "Text": " However, the rax register has some very large value associated with the packet, which comes"
    },
    {
      "Time_Start": 2605.78,
      "Time_End": 2608.82,
      "Text": " from some kind of internal and this allocator."
    },
    {
      "Time_Start": 2608.82,
      "Time_End": 2613.94,
      "Text": " So to be able to bypass that, I would need to create a packet very, very small, as small"
    },
    {
      "Time_Start": 2613.94,
      "Time_End": 2617.02,
      "Text": " to be able to be small as rcx value."
    },
    {
      "Time_Start": 2617.14,
      "Time_End": 2622.06,
      "Text": " However, if I make it so small, I won't be able to send another extra header."
    },
    {
      "Time_Start": 2622.06,
      "Time_End": 2625.22,
      "Text": " But if I don't send extra header, I won't be able to bypass the previous checks, which"
    },
    {
      "Time_Start": 2625.22,
      "Time_End": 2628.9,
      "Text": " we have been describing in this presentation."
    },
    {
      "Time_Start": 2628.9,
      "Time_End": 2631.14,
      "Text": " So how is it possible to even pass this check?"
    },
    {
      "Time_Start": 2631.14,
      "Time_End": 2636.2599999999998,
      "Text": " Because if I put the check so small, I won't be able to even generate the bug."
    },
    {
      "Time_Start": 2636.2599999999998,
      "Time_End": 2638.7,
      "Text": " And this is kind of crazy."
    },
    {
      "Time_Start": 2638.7,
      "Time_End": 2643.98,
      "Text": " So I decided, okay, I would probably need to very carefully reverse engineer this function"
    },
    {
      "Time_Start": 2643.98,
      "Time_End": 2648.78,
      "Text": " and this getData buffer and analyze what does it really do and why I'm having this"
    },
    {
      "Time_Start": 2648.78,
      "Time_End": 2650.52,
      "Text": " weird situation."
    },
    {
      "Time_Start": 2650.52,
      "Time_End": 2655.54,
      "Text": " But before doing that, I decided to carefully analyze and read the documentation of this"
    },
    {
      "Time_Start": 2655.54,
      "Time_End": 2657.82,
      "Text": " function in the MSDN."
    },
    {
      "Time_Start": 2657.82,
      "Time_End": 2663.94,
      "Text": " And by doing that, I ended up finding this pretty interesting piece of information, which"
    },
    {
      "Time_Start": 2663.94,
      "Time_End": 2666.04,
      "Text": " I exactly mark here in red."
    },
    {
      "Time_Start": 2666.04,
      "Time_End": 2670.46,
      "Text": " So essentially, this function is supposed to copy the data."
    },
    {
      "Time_Start": 2670.46,
      "Time_End": 2676.3,
      "Text": " However, if the requested data in the buffer is contiguous, the return value is a pointer"
    },
    {
      "Time_Start": 2676.3,
      "Time_End": 2682.14,
      "Text": " to the location to some kind of internal and these buffers, instead of copying any kind"
    },
    {
      "Time_Start": 2682.14,
      "Time_End": 2683.46,
      "Text": " of the data."
    },
    {
      "Time_Start": 2683.46,
      "Time_End": 2689.1,
      "Text": " So aha, this would somehow explain why I was not seeing the pointer for the local stack"
    },
    {
      "Time_Start": 2689.1,
      "Time_End": 2691.94,
      "Text": " buffer returning from this function."
    },
    {
      "Time_Start": 2691.94,
      "Time_End": 2698.94,
      "Text": " However, if this function cannot find the contiguous data which has been requested,"
    },
    {
      "Time_Start": 2698.94,
      "Time_End": 2703.94,
      "Text": " and the storage parameter is not null, then they will do exactly the copy."
    },
    {
      "Time_Start": 2703.94,
      "Time_End": 2710.26,
      "Text": " Otherwise, instead of copy the data, they will just return the pointer to the internal"
    },
    {
      "Time_Start": 2710.26,
      "Time_End": 2715.66,
      "Text": " and these buffers where the specific requested data resides."
    },
    {
      "Time_Start": 2715.66,
      "Time_End": 2720.9,
      "Text": " So to be able to do that, I would need to find somehow a way that the data which I sent"
    },
    {
      "Time_Start": 2720.9,
      "Time_End": 2723.42,
      "Text": " and later are requested are not contiguous."
    },
    {
      "Time_Start": 2723.42,
      "Time_End": 2725.9,
      "Text": " They are somehow not contiguous."
    },
    {
      "Time_Start": 2725.9,
      "Time_End": 2726.9,
      "Text": " And how to do that?"
    },
    {
      "Time_Start": 2726.9,
      "Time_End": 2728.86,
      "Text": " How is it even possible to do that?"
    },
    {
      "Time_Start": 2728.86,
      "Time_End": 2731.06,
      "Text": " And in fact, there is a trick to do it."
    },
    {
      "Time_Start": 2731.06,
      "Time_End": 2735.34,
      "Text": " If you use fragmentation, all of our data will never be contiguous because they will"
    },
    {
      "Time_Start": 2735.34,
      "Time_End": 2736.6600000000003,
      "Text": " be fragmented."
    },
    {
      "Time_Start": 2736.6600000000003,
      "Time_End": 2741.9,
      "Text": " So I change the logic of the packets which I sent to always fragment any kind of the"
    },
    {
      "Time_Start": 2741.9,
      "Time_End": 2743.06,
      "Text": " data."
    },
    {
      "Time_Start": 2743.06,
      "Time_End": 2744.46,
      "Text": " And then what happens?"
    },
    {
      "Time_Start": 2744.46,
      "Time_End": 2745.46,
      "Text": " Boom."
    },
    {
      "Time_Start": 2745.46,
      "Time_End": 2747.82,
      "Text": " I finally crash the Windows."
    },
    {
      "Time_Start": 2747.82,
      "Time_End": 2750.82,
      "Text": " Every puzzle which I put together starting finally to work."
    },
    {
      "Time_Start": 2750.82,
      "Time_End": 2757.1800000000003,
      "Text": " So in the end, to be able to generate the crash, I would also need to use fragmentation."
    },
    {
      "Time_Start": 2757.18,
      "Time_End": 2761.18,
      "Text": " And under WinDbgDebugger, it looks like that."
    },
    {
      "Time_Start": 2761.18,
      "Time_End": 2767.02,
      "Text": " So as you can see, the stack was smashed with the bytes 0xaa."
    },
    {
      "Time_Start": 2767.02,
      "Time_End": 2774.18,
      "Text": " And because I put a pretty long length in the fake header, I smashed the stack in the..."
    },
    {
      "Time_Start": 2774.18,
      "Time_End": 2775.54,
      "Text": " Many bytes in the stack was smashed."
    },
    {
      "Time_Start": 2775.54,
      "Time_End": 2776.54,
      "Text": " So here we go."
    },
    {
      "Time_Start": 2776.54,
      "Time_End": 2781.66,
      "Text": " I was able to finally generate the crash."
    },
    {
      "Time_Start": 2781.66,
      "Time_End": 2784.72,
      "Text": " And machine, of course, brusking of that."
    },
    {
      "Time_Start": 2784.7200000000003,
      "Time_End": 2790.4,
      "Text": " So that's the picture of this, of the laptop created by Potato."
    },
    {
      "Time_Start": 2790.4,
      "Time_End": 2791.4,
      "Text": " That's all."
    },
    {
      "Time_Start": 2791.4,
      "Time_End": 2793.5600000000004,
      "Text": " Do you have any questions to this presentation?"
    },
    {
      "Time_Start": 2793.5600000000004,
      "Time_End": 2799.5200000000004,
      "Text": " Also, the exploit is available on the bottom of this slide in my website."
    },
    {
      "Time_Start": 2799.5200000000004,
      "Time_End": 2804.2400000000002,
      "Text": " So you can download the Python script which is in Scapi to exactly..."
    },
    {
      "Time_Start": 2804.2400000000002,
      "Time_End": 2808.4800000000005,
      "Text": " Which exactly exploits bad neighbor bug and generate the plus screen of that."
    },
    {
      "Time_Start": 2808.4800000000005,
      "Time_End": 2814.28,
      "Text": " And the very detailed write-up which I created and you can find on my blog."
    },
    {
      "Time_Start": 2814.28,
      "Time_End": 2817.0800000000004,
      "Text": " Link on the top left corner in this slide."
    },
    {
      "Time_Start": 2817.0800000000004,
      "Time_End": 2817.5800000000004,
      "Text": " Thank you."
    }
  ]
}