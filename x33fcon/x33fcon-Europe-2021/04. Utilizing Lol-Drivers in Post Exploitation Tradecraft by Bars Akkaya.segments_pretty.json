{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 19.56,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Hello all, welcome to Utilizing Low Drivers in Post-Exploitation Tradecraft talk."
    },
    {
      "Time_Start": 19.56,
      "Time_End": 24.72,
      "Text": " My name is Baris Akkaya, I work as a Red Team Engineer at PQ Security."
    },
    {
      "Time_Start": 24.72,
      "Time_End": 30.24,
      "Text": " You can find and message me on Twitter for any questions or just a chat."
    },
    {
      "Time_Start": 30.24,
      "Time_End": 32.44,
      "Text": " Let's see our agenda."
    },
    {
      "Time_Start": 32.44,
      "Time_End": 37.04,
      "Text": " We are going to take a look at some of the motivations and challenges of kernel node"
    },
    {
      "Time_Start": 37.04,
      "Time_End": 39.92,
      "Text": " attacks from the perspective of a Red Teamer."
    },
    {
      "Time_Start": 39.92,
      "Time_End": 45.04,
      "Text": " We will analyze several capabilities of a driver which can be functional for Red Teamers"
    },
    {
      "Time_Start": 45.04,
      "Time_End": 47.879999999999995,
      "Text": " in post-exploitation phase."
    },
    {
      "Time_Start": 47.879999999999995,
      "Time_End": 51.34,
      "Text": " We will try to implement a couple of TTPs with this driver."
    },
    {
      "Time_Start": 51.34,
      "Time_End": 57.46,
      "Text": " We will also look at protected processes and ways of interacting with them."
    },
    {
      "Time_Start": 57.46,
      "Time_End": 63.900000000000006,
      "Text": " We will create a simple Meta-Architecture Loader which uses a protected process to evade"
    },
    {
      "Time_Start": 63.900000000000006,
      "Time_End": 68.42,
      "Text": " defensive measures with the help of that driver."
    },
    {
      "Time_Start": 68.42,
      "Time_End": 73.38,
      "Text": " And in the end, I will introduce a new tool that can be used to simulate the techniques"
    },
    {
      "Time_Start": 73.38,
      "Time_End": 74.78,
      "Text": " in this talk."
    },
    {
      "Time_Start": 74.78,
      "Time_End": 75.78,
      "Text": " So let's begin."
    },
    {
      "Time_Start": 76.78,
      "Time_End": 81.78,
      "Text": " Current offensive security practices mainly focus on user-mode threats."
    },
    {
      "Time_Start": 81.78,
      "Time_End": 87.18,
      "Text": " When we think the variety and importance of user-mode threats, it seems only natural."
    },
    {
      "Time_Start": 87.18,
      "Time_End": 93.46000000000001,
      "Text": " However, threat actors continue to use kernel-mode attacks for different purposes."
    },
    {
      "Time_Start": 93.46000000000001,
      "Time_End": 98.5,
      "Text": " Defensive products are also aligned with this trend since it is usually harder to detect"
    },
    {
      "Time_Start": 98.5,
      "Time_End": 101.14,
      "Text": " and prevent a kernel-mode attack."
    },
    {
      "Time_Start": 101.14,
      "Time_End": 106.34,
      "Text": " We can ask why an attacker prefers to use a technique including something like installing"
    },
    {
      "Time_Start": 106.34,
      "Time_End": 107.34,
      "Text": " the driver."
    },
    {
      "Time_Start": 107.34,
      "Time_End": 113.34,
      "Text": " Well, as we said, evading defensive measures is one of the main reasons."
    },
    {
      "Time_Start": 113.34,
      "Time_End": 121.02,
      "Text": " Also, executing code in kernel gives an attacker the ability to bypass user-mode controls like"
    },
    {
      "Time_Start": 121.02,
      "Time_End": 123.5,
      "Text": " access control lists."
    },
    {
      "Time_Start": 123.5,
      "Time_End": 129.74,
      "Text": " Another reason could be manipulating operating system or AV components itself."
    },
    {
      "Time_Start": 129.74,
      "Time_End": 135.38,
      "Text": " Since this part have general restrictions in user-mode."
    },
    {
      "Time_Start": 135.38,
      "Time_End": 140.26000000000002,
      "Text": " Since we are talking about motivations of using kernel-mode, let's see an important"
    },
    {
      "Time_Start": 140.26000000000002,
      "Time_End": 145.70000000000002,
      "Text": " defensive mechanism frequently used to detect user-mode attacks."
    },
    {
      "Time_Start": 145.70000000000002,
      "Time_End": 152.46,
      "Text": " API hooking and its bypasses were well-studied subjects both by attackers and defenders in"
    },
    {
      "Time_Start": 152.46,
      "Time_End": 153.46,
      "Text": " last years."
    },
    {
      "Time_Start": 154.02,
      "Time_End": 160.54000000000002,
      "Text": " API hooking can be simply defined as changing the behavior of API calls."
    },
    {
      "Time_Start": 160.54000000000002,
      "Time_End": 167.46,
      "Text": " Windows has a compartmentalized architecture which depends on lots of calls between separate"
    },
    {
      "Time_Start": 167.46,
      "Time_End": 168.46,
      "Text": " layers."
    },
    {
      "Time_Start": 168.46,
      "Time_End": 175.38,
      "Text": " So, a hooking function would act as a man-in-the-middle between these layers, like an API call from"
    },
    {
      "Time_Start": 175.38,
      "Time_End": 181.94,
      "Text": " NTDL app, and can read or change parameters of that hooked API call."
    },
    {
      "Time_Start": 181.94,
      "Time_End": 188.02,
      "Text": " This technique is used by defensive products to monitor the behavior of a process and detect"
    },
    {
      "Time_Start": 188.02,
      "Time_End": 190.06,
      "Text": " malicious patterns."
    },
    {
      "Time_Start": 190.06,
      "Time_End": 194.5,
      "Text": " Currently, attackers have several options for dealing with that."
    },
    {
      "Time_Start": 194.5,
      "Time_End": 201.26,
      "Text": " One of them is unhooking by using a fresh copy of a DLL."
    },
    {
      "Time_Start": 201.26,
      "Time_End": 206.74,
      "Text": " Attackers also change API calls with their direct syscalls when compiling a tool in order"
    },
    {
      "Time_Start": 206.74,
      "Time_End": 209.82,
      "Text": " to evade hooking."
    },
    {
      "Time_Start": 209.82,
      "Time_End": 215.78,
      "Text": " There are also lots of techniques, depends on Windows security flags, which could be"
    },
    {
      "Time_Start": 215.78,
      "Time_End": 224.66,
      "Text": " used by an attacker to defend this process against hooking engines."
    },
    {
      "Time_Start": 224.66,
      "Time_End": 237.06,
      "Text": " So, what prevents attackers just using kernel-mode to execute malicious code on their target systems?"
    },
    {
      "Time_Start": 237.3,
      "Time_End": 244.5,
      "Text": " First of all, it's difficult to create a stable rootkit because new OS versions may have different"
    },
    {
      "Time_Start": 244.5,
      "Time_End": 250.94,
      "Text": " undocumented objects and mechanisms which affect the stability of a malicious driver."
    },
    {
      "Time_Start": 250.94,
      "Time_End": 256.86,
      "Text": " Secondly, you need to have administrative privileges on a system to deploy a driver."
    },
    {
      "Time_Start": 256.86,
      "Time_End": 262.46,
      "Text": " And although you have it, you still may choose not to deploy drivers since it can alert various"
    },
    {
      "Time_Start": 262.46,
      "Time_End": 264.26,
      "Text": " monitoring tools."
    },
    {
      "Time_Start": 264.26,
      "Time_End": 271.74,
      "Text": " Lastly, Microsoft tries hard to defend kernel space against malicious code with restrictions"
    },
    {
      "Time_Start": 271.74,
      "Time_End": 277.82,
      "Text": " like driver signature enforcement and patch guard."
    },
    {
      "Time_Start": 277.82,
      "Time_End": 285.58,
      "Text": " Driver signature enforcement is one of the restrictions for newly developed drivers."
    },
    {
      "Time_Start": 285.58,
      "Time_End": 291.38,
      "Text": " Newly developed drivers have to be signed by Microsoft itself."
    },
    {
      "Time_Start": 291.38,
      "Time_End": 297.62,
      "Text": " This procedure requires an EV code signing certificate and a couple of other steps."
    },
    {
      "Time_Start": 297.62,
      "Time_End": 303.18,
      "Text": " Windows patch guard is the feature that prevents the patching of the kernel code."
    },
    {
      "Time_Start": 303.18,
      "Time_End": 309.58,
      "Text": " According to Microsoft, the quality of the code cannot be measured on a dynamically patched"
    },
    {
      "Time_Start": 309.58,
      "Time_End": 313.58,
      "Text": " code in kernel, which affects the whole system."
    },
    {
      "Time_Start": 313.58,
      "Time_End": 321.14,
      "Text": " This feature has actually affected both rootkits and antivirus applications operating in kernel"
    },
    {
      "Time_Start": 321.14,
      "Time_End": 322.14,
      "Text": " level."
    },
    {
      "Time_Start": 322.14,
      "Time_End": 329.06,
      "Text": " That's been said, there are still bypasses for DSE and patch guard."
    },
    {
      "Time_Start": 329.06,
      "Time_End": 336.38,
      "Text": " Using vulnerable drivers which can provide kernel read-write or code execution capabilities"
    },
    {
      "Time_Start": 336.38,
      "Time_End": 341.26,
      "Text": " to bypass DSE is fairly studied subject."
    },
    {
      "Time_Start": 341.26,
      "Time_End": 346.14,
      "Text": " You can find great research and articles on this subject."
    },
    {
      "Time_Start": 346.14,
      "Time_End": 353.18,
      "Text": " Okay, we can ask, are there any other drivers that we can use for offensive purposes?"
    },
    {
      "Time_Start": 353.18,
      "Time_End": 359.97999999999996,
      "Text": " If there is, we may not need to develop rootkits from scratch and we may not bother to bypass"
    },
    {
      "Time_Start": 359.97999999999996,
      "Time_End": 368.18,
      "Text": " driver signature enforcement or patch guard, which may cause blue screens on new Windows"
    },
    {
      "Time_Start": 368.18,
      "Time_End": 369.18,
      "Text": " versions."
    },
    {
      "Time_Start": 369.18,
      "Time_End": 374.14,
      "Text": " While I'm looking for a driver like that, I checked Process Hacker, which is one of"
    },
    {
      "Time_Start": 374.14,
      "Time_End": 376.58,
      "Text": " my favorite tools in Windows."
    },
    {
      "Time_Start": 376.58,
      "Time_End": 384.09999999999997,
      "Text": " I always thought about using it in terminal, but I could not find a decent port of it."
    },
    {
      "Time_Start": 384.09999999999997,
      "Time_End": 389.9,
      "Text": " To whom knows nothing about Process Hacker, it is a Windows monitoring tool with very"
    },
    {
      "Time_Start": 389.9,
      "Time_End": 392.86,
      "Text": " nice features like reading memory of selected processes."
    },
    {
      "Time_Start": 392.86,
      "Time_End": 399.38,
      "Text": " It can make your life very easier when you try to reverse something or understand the"
    },
    {
      "Time_Start": 399.38,
      "Time_End": 401.46,
      "Text": " behavior of a process."
    },
    {
      "Time_Start": 401.46000000000004,
      "Time_End": 408.38000000000005,
      "Text": " In order to extract data from the system, Process Hacker deploys its own driver and"
    },
    {
      "Time_Start": 408.38000000000005,
      "Time_End": 411.66,
      "Text": " uses it for interacting processes."
    },
    {
      "Time_Start": 411.66,
      "Time_End": 418.86,
      "Text": " It has abilities like killing protected processes, reading system handles, which makes it a powerful"
    },
    {
      "Time_Start": 418.86,
      "Time_End": 419.86,
      "Text": " tool."
    },
    {
      "Time_Start": 419.86,
      "Time_End": 429.90000000000003,
      "Text": " It has also been used by malware families like Redex in a simpler way to kill AV processes"
    },
    {
      "Time_Start": 429.90000000000003,
      "Time_End": 430.90000000000003,
      "Text": " in past years."
    },
    {
      "Time_Start": 430.90000000000003,
      "Time_End": 439.3,
      "Text": " So, with that in mind, I began to read the source code of Process Hacker to understand"
    },
    {
      "Time_Start": 439.3,
      "Time_End": 442.78000000000003,
      "Text": " how it communicates with its driver."
    },
    {
      "Time_Start": 442.78000000000003,
      "Time_End": 448.90000000000003,
      "Text": " Process Hacker uses IoCTL calls to execute some of its tasks using the driver."
    },
    {
      "Time_Start": 448.90000000000003,
      "Time_End": 455.50000000000006,
      "Text": " IoCTL or Input Output Control calls are a way of communicating with the device drivers"
    },
    {
      "Time_Start": 455.50000000000006,
      "Time_End": 457.54,
      "Text": " from the user mode code."
    },
    {
      "Time_Start": 457.54,
      "Time_End": 465.78000000000003,
      "Text": " A process can send IoCTLs to a driver with control codes, usually specific to that driver."
    },
    {
      "Time_Start": 465.78000000000003,
      "Time_End": 473.58000000000004,
      "Text": " According to the control codes, driver executes the specific tasks and may return an information."
    },
    {
      "Time_Start": 473.58000000000004,
      "Time_End": 479.42,
      "Text": " Windows gives an interface for IoCTLs with deviceIocontrol function, which also uses"
    },
    {
      "Time_Start": 479.42,
      "Time_End": 487.86,
      "Text": " an empty deviceIocontrol file function in empty DLL."
    },
    {
      "Time_Start": 487.86,
      "Time_End": 494.38,
      "Text": " Here we can see the Process Hacker's code which sends an IoCTL to its driver."
    },
    {
      "Time_Start": 494.38,
      "Time_End": 507.18,
      "Text": " Functions starting with KPH are wrappers for IoCTL to driver with specific codes."
    },
    {
      "Time_Start": 507.18,
      "Time_End": 520.0600000000001,
      "Text": " We can see this function sends the code which is assigned to KPHQueryInformation object."
    },
    {
      "Time_Start": 520.0600000000001,
      "Time_End": 526.78,
      "Text": " While looking at Process Hacker driver source code, we can find the IoCTL codes mapped to"
    },
    {
      "Time_Start": 526.78,
      "Time_End": 532.0600000000001,
      "Text": " these names, which can make the driver execute its regarding tasks."
    },
    {
      "Time_Start": 532.5400000000001,
      "Time_End": 540.3000000000001,
      "Text": " We can see the IoCTL code for KPHQueryInformation object is 151 for example."
    },
    {
      "Time_Start": 540.3000000000001,
      "Time_End": 547.0600000000001,
      "Text": " So when we send IoCTL with the 151 to Process Hacker driver, it executes the task mapped"
    },
    {
      "Time_Start": 547.0600000000001,
      "Time_End": 550.1800000000001,
      "Text": " to that IoCTL code in the driver."
    },
    {
      "Time_Start": 550.1800000000001,
      "Time_End": 556.46,
      "Text": " The source code has lots of IoCTLs that can be useful for an attacker to execute in an engagement."
    },
    {
      "Time_Start": 556.46,
      "Time_End": 564.74,
      "Text": " However, after reading the code in detail from the driver part, we can understand using"
    },
    {
      "Time_Start": 564.74,
      "Time_End": 570.9000000000001,
      "Text": " some of IoCTLs is actually limited to just Process Hacker process."
    },
    {
      "Time_Start": 570.9000000000001,
      "Time_End": 578.5,
      "Text": " You cannot send, in other words, you cannot send these IoCTLs from another process."
    },
    {
      "Time_Start": 587.46,
      "Time_End": 588.46,
      "Text": " Let's see."
    },
    {
      "Time_Start": 592.14,
      "Time_End": 598.4200000000001,
      "Text": " Process Hacker driver has a client verification mechanism for the functions that can be used"
    },
    {
      "Time_Start": 598.4200000000001,
      "Time_End": 601.5400000000001,
      "Text": " maliciously by attackers."
    },
    {
      "Time_Start": 601.5400000000001,
      "Time_End": 608.6600000000001,
      "Text": " A key is generated in the verification process when the driver is installed to the system."
    },
    {
      "Time_Start": 608.6600000000001,
      "Time_End": 616.14,
      "Text": " To generate such a key, driver checks the signature and the image of the process, calling"
    },
    {
      "Time_Start": 616.14,
      "Time_End": 619.34,
      "Text": " the IoCTL first time, with its own key."
    },
    {
      "Time_Start": 619.34,
      "Time_End": 626.66,
      "Text": " If the client process is verified, a new key is generated, and it is used in IoCTLs like"
    },
    {
      "Time_Start": 626.66,
      "Time_End": 629.74,
      "Text": " KPHOpenProcess call."
    },
    {
      "Time_Start": 629.74,
      "Time_End": 640.1,
      "Text": " Finding out the client verification mechanism explains why we cannot find a good terminal"
    },
    {
      "Time_Start": 640.1,
      "Time_End": 642.18,
      "Text": " usage of Process Hacker."
    },
    {
      "Time_Start": 642.74,
      "Time_End": 648.34,
      "Text": " I don't want to deploy entire application to the target system in an engagement."
    },
    {
      "Time_Start": 648.34,
      "Time_End": 655.0600000000001,
      "Text": " I checked when the verification mechanism was implemented."
    },
    {
      "Time_Start": 655.0600000000001,
      "Time_End": 661.9000000000001,
      "Text": " We can see from the commit message that it was implemented in 2016, actually."
    },
    {
      "Time_Start": 661.9000000000001,
      "Time_End": 670.1400000000001,
      "Text": " To check if I can send IoCTLs without verification, I downloaded an old version of Process Hacker."
    },
    {
      "Time_Start": 670.14,
      "Time_End": 677.8199999999999,
      "Text": " I saw that I can send IoCTLs to old driver without using Process Hacker binary at all."
    },
    {
      "Time_Start": 677.8199999999999,
      "Time_End": 681.34,
      "Text": " I also want to check the code from the old version."
    },
    {
      "Time_Start": 681.34,
      "Time_End": 689.38,
      "Text": " After reverting the repo to old commit, I can find the same header file with IoCTL codes"
    },
    {
      "Time_Start": 689.38,
      "Time_End": 696.7,
      "Text": " which are shown as reserved in the current version, like KPHWriteProcessMemory."
    },
    {
      "Time_Start": 696.7,
      "Time_End": 702.1800000000001,
      "Text": " We can see these functionalities are removed from the current version of the driver, possibly"
    },
    {
      "Time_Start": 702.1800000000001,
      "Time_End": 705.5400000000001,
      "Text": " because they could be abused easily."
    },
    {
      "Time_Start": 705.5400000000001,
      "Time_End": 717.1,
      "Text": " After finding this header file, I began to test simple functions using the driver."
    },
    {
      "Time_Start": 717.1,
      "Time_End": 723.0200000000001,
      "Text": " For the first implementation, we will see how we can read process environment block"
    },
    {
      "Time_Start": 723.02,
      "Time_End": 726.78,
      "Text": " of a remote process by using Process Hacker driver."
    },
    {
      "Time_Start": 726.78,
      "Time_End": 731.26,
      "Text": " Normally, reading PEB consists of three steps."
    },
    {
      "Time_Start": 731.26,
      "Time_End": 737.9399999999999,
      "Text": " Opening process handle using empty open process, querying PEB address with empty query information"
    },
    {
      "Time_Start": 737.9399999999999,
      "Time_End": 745.1,
      "Text": " process, and reading the memory using empty read virtual memory."
    },
    {
      "Time_Start": 745.1,
      "Time_End": 752.66,
      "Text": " These API calls are dispatched in the system service dispatcher in kernel, and after execution,"
    },
    {
      "Time_Start": 752.66,
      "Time_End": 761.98,
      "Text": " it returns proper information to user mode processes."
    },
    {
      "Time_Start": 761.98,
      "Time_End": 768.06,
      "Text": " In order to use Process Hacker driver for some of the API calls, we can change empty"
    },
    {
      "Time_Start": 768.06,
      "Time_End": 781.26,
      "Text": " open process to empty device IoCTL calls with open process CTR code of 50."
    },
    {
      "Time_Start": 781.26,
      "Time_End": 787.98,
      "Text": " We can also change empty read virtual memory to empty device IoCTL file, since the driver"
    },
    {
      "Time_Start": 787.98,
      "Time_End": 790.9399999999999,
      "Text": " exposes the same capability."
    },
    {
      "Time_Start": 790.9399999999999,
      "Time_End": 797.8199999999999,
      "Text": " These API calls cause IO request packets to be sent to Process Hacker driver, which will"
    },
    {
      "Time_Start": 797.8199999999999,
      "Time_End": 806.78,
      "Text": " end up executing the function defined in the header file according to its IoCTL code."
    },
    {
      "Time_Start": 806.78,
      "Time_End": 813.18,
      "Text": " This is the code implementing the reading PEB using Process Hacker driver."
    },
    {
      "Time_Start": 813.18,
      "Time_End": 820.14,
      "Text": " KPH connect is the function used for getting a handle for the driver device objects in"
    },
    {
      "Time_Start": 820.14,
      "Time_End": 824.06,
      "Text": " order to send IoCTLs to driver."
    },
    {
      "Time_Start": 824.06,
      "Time_End": 829.38,
      "Text": " As we know, KPH functions are wrappers for sending IoCTLs."
    },
    {
      "Time_Start": 829.38,
      "Time_End": 836.66,
      "Text": " By using KPH open process and KPH read virtual memory, we can see we open handle of a remote"
    },
    {
      "Time_Start": 836.66,
      "Time_End": 841.38,
      "Text": " process and reads its memory using the driver."
    },
    {
      "Time_Start": 841.38,
      "Time_End": 848.42,
      "Text": " Actually, it is the Process Hacker driver executes this task and returns the information"
    },
    {
      "Time_Start": 848.42,
      "Time_End": 851.18,
      "Text": " to the client process."
    },
    {
      "Time_Start": 851.18,
      "Time_End": 860.3399999999999,
      "Text": " Okay, let's see the execution of our implementation on a virtual machine."
    },
    {
      "Time_Start": 860.34,
      "Time_End": 868.22,
      "Text": " This is the old Process Hacker driver we downloaded for using without client verification."
    },
    {
      "Time_Start": 868.22,
      "Time_End": 872.26,
      "Text": " We can see it is signed under the name of the developer."
    },
    {
      "Time_Start": 872.26,
      "Time_End": 880.34,
      "Text": " We install this driver using service control manager configuration tool sc.exe."
    },
    {
      "Time_Start": 880.34,
      "Time_End": 900.02,
      "Text": " First, we are starting the driver right now, driver service."
    },
    {
      "Time_Start": 900.02,
      "Time_End": 906.22,
      "Text": " We can see it is started using sc.exe tool."
    },
    {
      "Time_Start": 907.22,
      "Time_End": 917.22,
      "Text": " First, we see the execution of the binary compiled with our standard API calls."
    },
    {
      "Time_Start": 917.22,
      "Time_End": 924.22,
      "Text": " We can see PEB of a process is read from the address in the command output."
    },
    {
      "Time_Start": 924.22,
      "Time_End": 943.22,
      "Text": " Secondly, we execute binary compiled with KPH functions and we can see it is executed too."
    },
    {
      "Time_Start": 943.22,
      "Time_End": 950.22,
      "Text": " We can see the difference of execution flow using a tool like API monitor."
    },
    {
      "Time_Start": 951.22,
      "Time_End": 957.22,
      "Text": " API monitor is a tool that you can use to hook API calls of a process and display the"
    },
    {
      "Time_Start": 957.22,
      "Time_End": 959.22,
      "Text": " function parameters in real time."
    },
    {
      "Time_Start": 959.22,
      "Time_End": 968.22,
      "Text": " You can check the APIs that you want to hook from here and select the target processes"
    },
    {
      "Time_Start": 968.22,
      "Time_End": 970.22,
      "Text": " to monitor."
    },
    {
      "Time_Start": 970.22,
      "Time_End": 973.22,
      "Text": " You can also start new processes for monitoring."
    },
    {
      "Time_Start": 973.22,
      "Time_End": 977.22,
      "Text": " So, let's select our API calls."
    },
    {
      "Time_Start": 977.22,
      "Time_End": 980.22,
      "Text": " We check empty open process."
    },
    {
      "Time_Start": 993.22,
      "Time_End": 1004.22,
      "Text": " We also check empty read virtual memory used for reading PEB."
    },
    {
      "Time_Start": 1007.22,
      "Time_End": 1013.22,
      "Text": " We also check empty query information process API call for monitoring."
    },
    {
      "Time_Start": 1019.22,
      "Time_End": 1032.22,
      "Text": " Lastly, we will check empty device IO control file API call for monitoring."
    },
    {
      "Time_Start": 1033.22,
      "Time_End": 1042.22,
      "Text": " Then, we execute our first binary which is the standard API call."
    },
    {
      "Time_Start": 1047.22,
      "Time_End": 1056.22,
      "Text": " When we execute, we can see it executes empty open process, empty query information process"
    },
    {
      "Time_Start": 1056.22,
      "Time_End": 1058.22,
      "Text": " and empty read virtual memory."
    },
    {
      "Time_Start": 1059.22,
      "Time_End": 1069.22,
      "Text": " We can check the parameters here which is the process handle and the client ID."
    },
    {
      "Time_Start": 1074.22,
      "Time_End": 1079.22,
      "Text": " We can also check the buffer read by empty read virtual memory."
    },
    {
      "Time_Start": 1080.22,
      "Time_End": 1092.22,
      "Text": " Now, to compare with this, we start our KPH version of the executable."
    },
    {
      "Time_Start": 1095.22,
      "Time_End": 1103.22,
      "Text": " Now, as we can see, two of the API calls are changing to empty device IO control file call."
    },
    {
      "Time_Start": 1104.22,
      "Time_End": 1112.22,
      "Text": " Doing that, we have tested that we can alter the execution flow of a simple program by"
    },
    {
      "Time_Start": 1112.22,
      "Time_End": 1116.22,
      "Text": " using IoCTLs instead of minAPIs."
    },
    {
      "Time_Start": 1116.22,
      "Time_End": 1128.22,
      "Text": " We can also display the buffer sent to process hacker driver by using API monitor like here."
    },
    {
      "Time_Start": 1134.22,
      "Time_End": 1148.22,
      "Text": " What are the advantages of using IoCTLs instead of standard minAPI calls?"
    },
    {
      "Time_Start": 1148.22,
      "Time_End": 1155.22,
      "Text": " I think this creates an execution path which is harder to analyze just using API hooks."
    },
    {
      "Time_Start": 1155.22,
      "Time_End": 1161.22,
      "Text": " Since defensive products tend to hook API calls like virtual allocates, write process memory"
    },
    {
      "Time_Start": 1161.22,
      "Time_End": 1168.22,
      "Text": " and create remote threads, let's say, that are frequently used by malware families and offensive tools,"
    },
    {
      "Time_Start": 1168.22,
      "Time_End": 1174.22,
      "Text": " switching these functions with IoCTLs would create a non-standard behavior."
    },
    {
      "Time_Start": 1174.22,
      "Time_End": 1179.22,
      "Text": " Also, the IoCTL calls are usually specific to the driver."
    },
    {
      "Time_Start": 1179.22,
      "Time_End": 1187.22,
      "Text": " So, an automatic analysis just looking at the IoCTL parameters would be harder for EDRs and sandboxes."
    },
    {
      "Time_Start": 1187.22,
      "Time_End": 1197.22,
      "Text": " Secondly, process hacker driver uses kernel mode when it opens a process so that it bypasses user mode access checks."
    },
    {
      "Time_Start": 1197.22,
      "Time_End": 1205.22,
      "Text": " This is the main reason that process hacker can display so much data normally a process wouldn't be able to display."
    },
    {
      "Time_Start": 1206.22,
      "Time_End": 1211.22,
      "Text": " By using IoCTLs, we can utilize the same capability with any tool."
    },
    {
      "Time_Start": 1211.22,
      "Time_End": 1226.22,
      "Text": " One more thing is that modern day altruist programs use minifilters to register in the kernel notifications like process or thread creation."
    },
    {
      "Time_Start": 1226.22,
      "Time_End": 1236.22,
      "Text": " However, they can be more reluctant to analyze notifications coming from kernel node operations."
    },
    {
      "Time_Start": 1236.22,
      "Time_End": 1249.22,
      "Text": " Therefore, it is possible that some of the tasks executed by process hacker driver can execute without any notification of antivirus applications."
    },
    {
      "Time_Start": 1250.22,
      "Time_End": 1263.22,
      "Text": " The main reason behind this capability, which can be abused by attackers, is that it deliberately ignores some security checks on behalf of functionality."
    },
    {
      "Time_Start": 1263.22,
      "Time_End": 1272.22,
      "Text": " Microsoft has a documentation for driver developers mentioning this type of issues when managing handles in kernel node."
    },
    {
      "Time_Start": 1272.22,
      "Time_End": 1283.22,
      "Text": " Disregarding proper handle management could be an indicator that a driver could be used as a leverage for bypassing user mode access controls."
    },
    {
      "Time_Start": 1283.22,
      "Time_End": 1289.22,
      "Text": " We can also identify them as low drivers."
    },
    {
      "Time_Start": 1290.22,
      "Time_End": 1306.22,
      "Text": " Although changing standard API calls to IoCTLs seems easy to implement for simple usages, rewriting offensive tools which have various capabilities could be problematic for a red teamer."
    },
    {
      "Time_Start": 1306.22,
      "Time_End": 1312.22,
      "Text": " Also, you may not have access to the source code of every offensive tool."
    },
    {
      "Time_Start": 1313.22,
      "Time_End": 1320.22,
      "Text": " So, it is necessary to modify the tools to use IoCTL dynamically."
    },
    {
      "Time_Start": 1320.22,
      "Time_End": 1328.22,
      "Text": " For this purpose, we can use API hooking, this time for changing the execution of our own tools or processes."
    },
    {
      "Time_Start": 1328.22,
      "Time_End": 1346.22,
      "Text": " By using a hooking library of your choosing, like dtor, minhook, ezhook, or just you can write your own, we can redirect the API calls of the process to IoCTLs to process hacker driver."
    },
    {
      "Time_Start": 1347.22,
      "Time_End": 1364.22,
      "Text": " Here we can see an example of using Microsoft D3 library to hook open process and read memory API calls to redirect them into KPH open process and KPH read virtual memory."
    },
    {
      "Time_Start": 1364.22,
      "Time_End": 1372.22,
      "Text": " This code creates a DLL which can be injected into your attacker process to hook the API calls."
    },
    {
      "Time_Start": 1372.22,
      "Time_End": 1375.22,
      "Text": " So, let's try this method on a well known tool."
    },
    {
      "Time_Start": 1377.22,
      "Time_End": 1388.22,
      "Text": " In this demo, I will try to hook Mimikatz to make it use KPH functions when it dumps the credentials."
    },
    {
      "Time_Start": 1388.22,
      "Time_End": 1396.22,
      "Text": " Normally, it uses open process and read virtual memory calls to open lsas.exe and read its memory content."
    },
    {
      "Time_Start": 1396.22,
      "Time_End": 1400.22,
      "Text": " We start monitoring Mimikatz process in API monitor."
    },
    {
      "Time_Start": 1400.22,
      "Time_End": 1416.22,
      "Text": " When we dump the lsas process, we can see that the NT calls are made."
    },
    {
      "Time_Start": 1416.22,
      "Time_End": 1428.22,
      "Text": " We can also see NT read virtual memory has returned the contents of lsas memory in its parameter."
    },
    {
      "Time_Start": 1428.22,
      "Time_End": 1436.22,
      "Text": " As we can see, this is our lsas process memory."
    },
    {
      "Time_Start": 1436.22,
      "Time_End": 1447.22,
      "Text": " This time, we start Mimikatz again for this time hooking."
    },
    {
      "Time_Start": 1447.22,
      "Time_End": 1470.22,
      "Text": " I will use process hackers on inject DLL feature to inject our D3 DLL into Mimikatz.exe."
    },
    {
      "Time_Start": 1470.22,
      "Time_End": 1479.22,
      "Text": " We can see that our DLL is executed and it is now successfully connected to the KPH driver."
    },
    {
      "Time_Start": 1479.22,
      "Time_End": 1485.22,
      "Text": " We start monitoring it again."
    },
    {
      "Time_Start": 1486.22,
      "Time_End": 1499.22,
      "Text": " We also choose NT device IO control file from API monitor to see if there is any calls to IOCTL."
    },
    {
      "Time_Start": 1499.22,
      "Time_End": 1518.22,
      "Text": " When we dump credentials from lsas, we see that API calls of NT open process and NT read virtual memory is not shown in monitored calls."
    },
    {
      "Time_Start": 1519.22,
      "Time_End": 1529.22,
      "Text": " This is because DLL we have injected redirects Mimikatz code to use KPH equivalent instead of WinAPX."
    },
    {
      "Time_Start": 1529.22,
      "Time_End": 1545.22,
      "Text": " To see IOCTL code, we start monitoring it again."
    },
    {
      "Time_Start": 1548.22,
      "Time_End": 1558.22,
      "Text": " Now we can see all the IOCTLs that is used by Mimikatz process for opening lsas and reading its memory."
    },
    {
      "Time_Start": 1558.22,
      "Time_End": 1569.22,
      "Text": " This way, we can modify tools without actually recompiling them."
    },
    {
      "Time_Start": 1569.22,
      "Time_End": 1596.22,
      "Text": " Here we can see the IOCTL buffers returned by KPH driver."
    },
    {
      "Time_Start": 1596.22,
      "Time_End": 1601.22,
      "Text": " Let's look at another implementation of our Lull driver."
    },
    {
      "Time_Start": 1601.22,
      "Time_End": 1605.22,
      "Text": " In summary, process injection consists of three steps."
    },
    {
      "Time_Start": 1605.22,
      "Time_End": 1613.22,
      "Text": " Allocating memory for our payload, writing payload to the allocated memory and executing the payload."
    },
    {
      "Time_Start": 1613.22,
      "Time_End": 1623.22,
      "Text": " To inject the process using the Lull driver, we can utilize some of IOCTLs to do these steps."
    },
    {
      "Time_Start": 1623.22,
      "Time_End": 1633.22,
      "Text": " This is a simple code that hijacks the main thread of a process to execute a shellcode."
    },
    {
      "Time_Start": 1633.22,
      "Time_End": 1645.22,
      "Text": " To do that, you need to suspend the thread you want to hijack after you wrote the payload into the address space of the remote process."
    },
    {
      "Time_Start": 1645.22,
      "Time_End": 1650.22,
      "Text": " Then you get context of the thread which includes registry values."
    },
    {
      "Time_Start": 1650.22,
      "Time_End": 1660.22,
      "Text": " Since it's suspended, we change the RIPRegistry to beginning of our shellcode by using setContextThread."
    },
    {
      "Time_Start": 1660.22,
      "Time_End": 1670.22,
      "Text": " After resuming the thread, we expect that our shellcode is executed."
    },
    {
      "Time_Start": 1670.22,
      "Time_End": 1676.22,
      "Text": " We can implement the same behavior using the process hacker IOCTL functions."
    },
    {
      "Time_Start": 1676.22,
      "Time_End": 1682.22,
      "Text": " These are IOCTL functions that are used for the same functionality."
    },
    {
      "Time_Start": 1682.22,
      "Time_End": 1697.22,
      "Text": " Since there is no anti-suspend thread equivalent for KPH, I used KPHSuspendProcess and ResumeProcess functions instead of anti-suspend thread."
    },
    {
      "Time_Start": 1698.22,
      "Time_End": 1708.22,
      "Text": " After switching API calls with their equivalent KPH functions, the injection code becomes like this."
    },
    {
      "Time_Start": 1708.22,
      "Time_End": 1715.22,
      "Text": " Let's see how it works in the demo."
    },
    {
      "Time_Start": 1716.22,
      "Time_End": 1727.22,
      "Text": " In this demo, we will inject a shellcode into ExploreRexec by using ThreadExecutionHijacking method."
    },
    {
      "Time_Start": 1727.22,
      "Time_End": 1736.22,
      "Text": " Here are the functions checked for monitoring."
    },
    {
      "Time_Start": 1737.22,
      "Time_End": 1747.22,
      "Text": " We have checked AntiReadVirtualMemory and AntiDeviceHireControl file."
    },
    {
      "Time_Start": 1747.22,
      "Time_End": 1752.22,
      "Text": " Let's start our first program which uses standard thread hijacking code."
    },
    {
      "Time_Start": 1752.22,
      "Time_End": 1764.22,
      "Text": " After execution, we see the call case response."
    },
    {
      "Time_Start": 1764.22,
      "Time_End": 1769.22,
      "Text": " We can see the anti-DLL APIs called by our program."
    },
    {
      "Time_Start": 1769.22,
      "Time_End": 1774.22,
      "Text": " Most of the defensive products would identify this as thread hijacking."
    },
    {
      "Time_Start": 1774.22,
      "Time_End": 1788.22,
      "Text": " Now, we can check the functions as well."
    },
    {
      "Time_Start": 1788.22,
      "Time_End": 1803.22,
      "Text": " Now, let's check our implementation using the load driver."
    },
    {
      "Time_Start": 1803.22,
      "Time_End": 1809.22,
      "Text": " After a couple seconds, we can see that our shellcode is executed and call case response."
    },
    {
      "Time_Start": 1809.22,
      "Time_End": 1820.22,
      "Text": " When we look at the API monitor output, we can see AntiDeviceHireControl file calls in place of the old API functions."
    },
    {
      "Time_Start": 1820.22,
      "Time_End": 1828.22,
      "Text": " Our load driver does not have an equivalent for VirtualAlloc, so we can still see it in the output."
    },
    {
      "Time_Start": 1829.22,
      "Time_End": 1839.22,
      "Text": " We can check the old API calls kind of normalized from the Perspective4Fan analysis."
    },
    {
      "Time_Start": 1839.22,
      "Time_End": 1851.22,
      "Text": " We can say that this version is harder to detect as a ThreadExecutionHijacking than the standard one."
    },
    {
      "Time_Start": 1852.22,
      "Time_End": 1857.22,
      "Text": " Let's move on to protected processes."
    },
    {
      "Time_Start": 1857.22,
      "Time_End": 1867.22,
      "Text": " ProtectedProcessLite is a Windows feature introduced with Windows 8.0.1."
    },
    {
      "Time_Start": 1867.22,
      "Time_End": 1876.22,
      "Text": " PPL is a feature of a process defined in one of the fields in EprocessKernel object."
    },
    {
      "Time_Start": 1876.22,
      "Time_End": 1882.22,
      "Text": " Windows provides it as a boundary between OS components and user applications."
    },
    {
      "Time_Start": 1882.22,
      "Time_End": 1896.22,
      "Text": " One of the well-known usage is running lsexec as PPL by configuring it with a registry key."
    },
    {
      "Time_Start": 1896.22,
      "Time_End": 1904.22,
      "Text": " If a process is started as PPL, opening handles with full access is not permitted"
    },
    {
      "Time_Start": 1904.22,
      "Time_End": 1911.22,
      "Text": " and access rights will be masked to a lover according to its PPL level."
    },
    {
      "Time_Start": 1911.22,
      "Time_End": 1917.22,
      "Text": " PPLs also have a hierarchical level system between each other."
    },
    {
      "Time_Start": 1917.22,
      "Time_End": 1926.22,
      "Text": " As it is shown in the graph, a PPL process with Windows TCB level can open full access all other PPL processes,"
    },
    {
      "Time_Start": 1926.22,
      "Time_End": 1941.22,
      "Text": " while a process with Anti-Malware level can only access fully two processes with the same level or below."
    },
    {
      "Time_Start": 1941.22,
      "Time_End": 1950.22,
      "Text": " As we said, PPLs are usually used as a mitigation for credential dumping attacks."
    },
    {
      "Time_Start": 1950.22,
      "Time_End": 1960.22,
      "Text": " There are studies on turning off PPL bit by exploiting vulnerable drivers to overwrite the field in the Eprocess."
    },
    {
      "Time_Start": 1960.22,
      "Time_End": 1967.22,
      "Text": " Although this is an effective method, it can also create an indicator for defenders as well."
    },
    {
      "Time_Start": 1967.22,
      "Time_End": 1974.22,
      "Text": " Moreover, the driver exploit may need to patch some objects in the kernel,"
    },
    {
      "Time_Start": 1974.22,
      "Time_End": 1980.22,
      "Text": " which can be also problematic for patch guard in different Windows versions."
    },
    {
      "Time_Start": 1980.22,
      "Time_End": 1984.22,
      "Text": " There may be different ways to interact with PPL processes,"
    },
    {
      "Time_Start": 1984.22,
      "Time_End": 1990.22,
      "Text": " and since we can open handles using our load driver without any restrictions,"
    },
    {
      "Time_Start": 1990.22,
      "Time_End": 1997.22,
      "Text": " it may be possible to use PPL as a protection for our offensive payloads."
    },
    {
      "Time_Start": 1998.22,
      "Time_End": 2007.22,
      "Text": " Creating a process with PPL is possible only if you are using a PPL-assigned executable."
    },
    {
      "Time_Start": 2007.22,
      "Time_End": 2015.22,
      "Text": " These executables also be third-party programs like Antigroup executables,"
    },
    {
      "Time_Start": 2015.22,
      "Time_End": 2024.22,
      "Text": " but third-party executables can be signed as Anti-Malware PPL at the higher level."
    },
    {
      "Time_Start": 2024.22,
      "Time_End": 2032.22,
      "Text": " I wanted to create a host process for my malicious payload at Windows-TCP level,"
    },
    {
      "Time_Start": 2032.22,
      "Time_End": 2035.22,
      "Text": " because it's higher than any Anti-Malware level."
    },
    {
      "Time_Start": 2035.22,
      "Time_End": 2044.22,
      "Text": " To do that, I checked the Windows-TCP PPL-assigned executables in Windows 10,"
    },
    {
      "Time_Start": 2044.22,
      "Time_End": 2049.2200000000003,
      "Text": " and I decided to use services.exe as the host process."
    },
    {
      "Time_Start": 2055.2200000000003,
      "Time_End": 2063.2200000000003,
      "Text": " After that, I designed a simple loader using early-bird injection technique"
    },
    {
      "Time_Start": 2063.2200000000003,
      "Time_End": 2069.2200000000003,
      "Text": " to create a new services.exe instance in suspended states,"
    },
    {
      "Time_Start": 2069.2200000000003,
      "Time_End": 2074.2200000000003,
      "Text": " and inject it with the payload."
    },
    {
      "Time_Start": 2074.2200000000003,
      "Time_End": 2078.2200000000003,
      "Text": " Since we have the driver of ProcessSeeker,"
    },
    {
      "Time_Start": 2078.2200000000003,
      "Time_End": 2083.2200000000003,
      "Text": " we use it to open full-access handle to newly created services.exe instance,"
    },
    {
      "Time_Start": 2083.2200000000003,
      "Time_End": 2094.2200000000003,
      "Text": " and write our in-memory payload to services.exe with KPH write process memory."
    },
    {
      "Time_Start": 2094.2200000000003,
      "Time_End": 2099.2200000000003,
      "Text": " After sending an APC to execute our shellcode,"
    },
    {
      "Time_Start": 2099.2200000000003,
      "Time_End": 2106.2200000000003,
      "Text": " we call KPH resume process to start our execution."
    },
    {
      "Time_Start": 2107.2200000000003,
      "Time_End": 2114.2200000000003,
      "Text": " This is the actual source code of the loader that we designed."
    },
    {
      "Time_Start": 2114.2200000000003,
      "Time_End": 2124.2200000000003,
      "Text": " As you can see, it utilizes KPH wrapper functions to get handle and write payload to PPL process."
    },
    {
      "Time_Start": 2124.2200000000003,
      "Time_End": 2134.2200000000003,
      "Text": " It also uses, as we said, the KPH resume process to begin our execution."
    },
    {
      "Time_Start": 2134.2200000000003,
      "Time_End": 2139.2200000000003,
      "Text": " So, let's see how it works in the demo environment."
    },
    {
      "Time_Start": 2142.2200000000003,
      "Time_End": 2146.2200000000003,
      "Text": " This is our demo environment for the loader."
    },
    {
      "Time_Start": 2146.2200000000003,
      "Time_End": 2148.2200000000003,
      "Text": " As you can see,"
    },
    {
      "Time_Start": 2156.2200000000003,
      "Time_End": 2160.2200000000003,
      "Text": " let's check if the demo has actually started."
    },
    {
      "Time_Start": 2160.2200000000003,
      "Time_End": 2162.2200000000003,
      "Text": " Okay, now it's started."
    },
    {
      "Time_Start": 2162.2200000000003,
      "Time_End": 2164.2200000000003,
      "Text": " This is our demo environment for the loader."
    },
    {
      "Time_Start": 2168.2200000000003,
      "Time_End": 2170.2200000000003,
      "Text": " As you can see,"
    },
    {
      "Time_Start": 2172.2200000000003,
      "Time_End": 2179.2200000000003,
      "Text": " real-time protection and cloud protection is actually on,"
    },
    {
      "Time_Start": 2182.2200000000003,
      "Time_End": 2185.2200000000003,
      "Text": " and also Defender is updated."
    },
    {
      "Time_Start": 2186.2200000000003,
      "Time_End": 2192.2200000000003,
      "Text": " We can check also the Lsus configuration."
    },
    {
      "Time_Start": 2192.2200000000003,
      "Time_End": 2197.2200000000003,
      "Text": " Lsus process is configured to run as PPL also."
    },
    {
      "Time_Start": 2201.2200000000003,
      "Time_End": 2210.2200000000003,
      "Text": " Let's try our first POC, which reads the PAP of a remote process."
    },
    {
      "Time_Start": 2210.2200000000003,
      "Time_End": 2216.2200000000003,
      "Text": " This time it fails because of the PPL bit of the Lsus."
    },
    {
      "Time_Start": 2216.2200000000003,
      "Time_End": 2219.2200000000003,
      "Text": " So, this is the attacker kernel machine."
    },
    {
      "Time_Start": 2219.2200000000003,
      "Time_End": 2228.2200000000003,
      "Text": " We create reverse HTTPS metaproperty payload using msfvenom command."
    },
    {
      "Time_Start": 2228.2200000000003,
      "Time_End": 2233.2200000000003,
      "Text": " We also start our metaproperty handler."
    },
    {
      "Time_Start": 2234.2200000000003,
      "Time_End": 2236.2200000000003,
      "Text": " Since I intend to..."
    },
    {
      "Time_Start": 2240.2200000000003,
      "Time_End": 2243.2200000000003,
      "Text": " Actually, the payload is generated."
    },
    {
      "Time_Start": 2243.2200000000003,
      "Time_End": 2248.2200000000003,
      "Text": " Since I intend to serve the first payload on a simple HTTP server,"
    },
    {
      "Time_Start": 2248.2200000000003,
      "Time_End": 2254.2200000000003,
      "Text": " I encrypted the shellcode using a simple AES encrypt."
    },
    {
      "Time_Start": 2256.2200000000003,
      "Time_End": 2259.2200000000003,
      "Text": " We started the HTTP server on the attacker."
    },
    {
      "Time_Start": 2260.2200000000003,
      "Time_End": 2262.2200000000003,
      "Text": " On the target machine..."
    },
    {
      "Time_Start": 2269.2200000000003,
      "Time_End": 2273.2200000000003,
      "Text": " On the target machine, we execute our loader"
    },
    {
      "Time_Start": 2274.2200000000003,
      "Time_End": 2278.2200000000003,
      "Text": " with the URL parameter for downloading the shellcode."
    },
    {
      "Time_Start": 2284.2200000000003,
      "Time_End": 2287.2200000000003,
      "Text": " As we can see in process hacker window,"
    },
    {
      "Time_Start": 2287.2200000000003,
      "Time_End": 2292.2200000000003,
      "Text": " a new service.exe instance is created with system token."
    },
    {
      "Time_Start": 2295.2200000000003,
      "Time_End": 2301.2200000000003,
      "Text": " We can check the PPL level of it, and it is shown as WinTCB."
    },
    {
      "Time_Start": 2307.2200000000003,
      "Time_End": 2310.2200000000003,
      "Text": " Now, turning back to attacker machine,"
    },
    {
      "Time_Start": 2310.2200000000003,
      "Time_End": 2317.2200000000003,
      "Text": " we can see that a new metaproperty session is started."
    },
    {
      "Time_Start": 2318.2200000000003,
      "Time_End": 2322.2200000000003,
      "Text": " We can check the current user and PID."
    },
    {
      "Time_Start": 2330.2200000000003,
      "Time_End": 2331.2200000000003,
      "Text": " Okay."
    },
    {
      "Time_Start": 2333.2200000000003,
      "Time_End": 2335.2200000000003,
      "Text": " Now, let's try a different thing."
    },
    {
      "Time_Start": 2335.2200000000003,
      "Time_End": 2340.2200000000003,
      "Text": " We said anti-malware processes have lower PPL level."
    },
    {
      "Time_Start": 2340.2200000000003,
      "Time_End": 2344.2200000000003,
      "Text": " So in theory, we should have enough privilege"
    },
    {
      "Time_Start": 2344.2200000000003,
      "Time_End": 2351.2200000000003,
      "Text": " to inject into anti-malware processes from the services.exe."
    },
    {
      "Time_Start": 2351.2200000000003,
      "Time_End": 2354.2200000000003,
      "Text": " As we can see, this is the defenders process."
    },
    {
      "Time_Start": 2357.2200000000003,
      "Time_End": 2360.2200000000003,
      "Text": " We can use migrate command of metasploit"
    },
    {
      "Time_Start": 2360.2200000000003,
      "Time_End": 2364.2200000000003,
      "Text": " to inject into defender process like this."
    },
    {
      "Time_Start": 2366.2200000000003,
      "Time_End": 2367.2200000000003,
      "Text": " Okay."
    },
    {
      "Time_Start": 2371.2200000000003,
      "Time_End": 2377.2200000000003,
      "Text": " When we check the PID, it is the same as the defenders process now."
    },
    {
      "Time_Start": 2380.2200000000003,
      "Time_End": 2384.2200000000003,
      "Text": " And also, we can use well-known malicious tools like Kiwi"
    },
    {
      "Time_Start": 2384.2200000000003,
      "Time_End": 2390.2200000000003,
      "Text": " inside the process of the defender without facing any obstacles."
    },
    {
      "Time_Start": 2390.2200000000003,
      "Time_End": 2396.2200000000003,
      "Text": " Let's dump the credentials from Asus,"
    },
    {
      "Time_Start": 2396.2200000000003,
      "Time_End": 2400.2200000000003,
      "Text": " which is also configured to run as PPL."
    },
    {
      "Time_Start": 2402.2200000000003,
      "Time_End": 2408.2200000000003,
      "Text": " When we execute the command, we can see that our hashes are dumped,"
    },
    {
      "Time_Start": 2408.2200000000003,
      "Time_End": 2414.2200000000003,
      "Text": " and we didn't also try to turn off the PPL bit of the Asus."
    },
    {
      "Time_Start": 2418.2200000000003,
      "Time_End": 2419.2200000000003,
      "Text": " Okay."
    },
    {
      "Time_Start": 2421.2200000000003,
      "Time_End": 2427.2200000000003,
      "Text": " I decided to gather these techniques in a tool called Offensive Process Hacker."
    },
    {
      "Time_Start": 2431.2200000000003,
      "Time_End": 2436.2200000000003,
      "Text": " If you want to check, you can find it on GitHub."
    },
    {
      "Time_Start": 2437.2200000000003,
      "Time_End": 2440.2200000000003,
      "Text": " We will appreciate PRs."
    },
    {
      "Time_Start": 2442.2200000000003,
      "Time_End": 2446.2200000000003,
      "Text": " For future work, I plan to search for drivers,"
    },
    {
      "Time_Start": 2446.2200000000003,
      "Time_End": 2449.2200000000003,
      "Text": " which can be utilized similar ways."
    },
    {
      "Time_Start": 2450.2200000000003,
      "Time_End": 2455.2200000000003,
      "Text": " I intend to implement new techniques also to Offensive Process Hacker as well."
    },
    {
      "Time_Start": 2455.2200000000003,
      "Time_End": 2460.2200000000003,
      "Text": " Also, finding less noisy ways of installing drivers"
    },
    {
      "Time_Start": 2460.2200000000003,
      "Time_End": 2463.2200000000003,
      "Text": " would increase the impact of this project."
    },
    {
      "Time_Start": 2466.2200000000003,
      "Time_End": 2468.2200000000003,
      "Text": " That's all for this talk."
    },
    {
      "Time_Start": 2468.2200000000003,
      "Time_End": 2471.2200000000003,
      "Text": " Thank you for listening and see you."
    }
  ]
}