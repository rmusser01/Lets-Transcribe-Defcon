{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 5.0,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Hello hackers. This is a talk about a bug in the microchip. And uh, I'm Ninny Chen, a"
    },
    {
      "Time_Start": 9.28,
      "Time_End": 15.44,
      "Text": " security researcher at DevCore. We are from Taiwan. And I'm also a member of Belson's"
    },
    {
      "Time_Start": 15.44,
      "Time_End": 20.46,
      "Text": " CTF team and a member of Undefined. Okay, why? Why the router OS? Because we want to"
    },
    {
      "Time_Start": 20.46,
      "Time_End": 25.46,
      "Text": " participate in the Ponzu on Toronto in 2022. As one of the targets, the router board of"
    },
    {
      "Time_Start": 32.54,
      "Time_End": 37.540000000000006,
      "Text": " microchip hasn't been exploited in the previous event. More correctly, no one tried to demo"
    },
    {
      "Time_Start": 39.74,
      "Time_End": 44.74,
      "Text": " exploit against this target in the context. You may already know the rules of the event."
    },
    {
      "Time_Start": 45.54,
      "Time_End": 50.54,
      "Text": " Participants must find a pre-auth RCE with no user interaction to acquire the points of the"
    },
    {
      "Time_Start": 54.980000000000004,
      "Time_End": 59.980000000000004,
      "Text": " target. And a sole host mesh up. A special category was introduced in 2022. Participants"
    },
    {
      "Time_Start": 62.760000000000005,
      "Time_End": 67.76,
      "Text": " have to chain a router when site is blocked and another device is exploited to earn the points"
    },
    {
      "Time_Start": 67.98,
      "Time_End": 72.98,
      "Text": " and bounty. The bounty and point in this category are relatively high. So it's a good target"
    },
    {
      "Time_Start": 76.16000000000001,
      "Time_End": 81.16000000000001,
      "Text": " for us to earn more to win the contest. Let's recap some basic things quickly. The router,"
    },
    {
      "Time_Start": 84.64,
      "Time_End": 90.64,
      "Text": " the router board of microchip is quite popular. And the router OS is the operating system of"
    },
    {
      "Time_Start": 90.64,
      "Time_End": 95.08000000000001,
      "Text": " router board hardware. By scanning the microchip we can observe about 3 million devices"
    },
    {
      "Time_Start": 95.1,
      "Time_End": 101.24,
      "Text": " online. Router OS is a standalone operating system based on the Linux kernel. And the"
    },
    {
      "Time_Start": 101.24,
      "Time_End": 106.24,
      "Text": " microchip also offers ISO images so we can run it as a VM. It's closed source and also a closed"
    },
    {
      "Time_Start": 109.08,
      "Time_End": 114.08,
      "Text": " ecosystem. According to the download terms on microchip's website, you pay 45 bucks to get a"
    },
    {
      "Time_Start": 117.36,
      "Time_End": 122.36,
      "Text": " GPL source code. What a bargain. And currently there are 2 versions of router OS. The V7 and"
    },
    {
      "Time_Start": 125.1,
      "Time_End": 130.84,
      "Text": " the V6. They should be considered 2 branches because their implementation are slightly"
    },
    {
      "Time_Start": 130.84,
      "Time_End": 135.84,
      "Text": " different. And the cloud host router is the router OS image for for for VM. But only the AMD"
    },
    {
      "Time_Start": 139.07999999999998,
      "Time_End": 144.07999999999998,
      "Text": " 64 version is available. Most of the service on router OS are implemented by microchip"
    },
    {
      "Time_Start": 147.02,
      "Time_End": 152.02,
      "Text": " themselves. And they share a similar architecture so we name them Nova Binary afterward. And"
    },
    {
      "Time_Start": 152.84,
      "Time_End": 157.84,
      "Text": " they use Nova message to talk to each other. Though the router OS is based on Linux kernel,"
    },
    {
      "Time_Start": 159.48000000000002,
      "Time_End": 166.02,
      "Text": " users are trapped inside a customized CLI. And there's no official method to access the"
    },
    {
      "Time_Start": 166.02,
      "Time_End": 172.02,
      "Text": " underlying Linux system. Only developers can install a backdoor package to access the"
    },
    {
      "Time_Start": 172.02,
      "Time_End": 178.86,
      "Text": " Linux system for debugging purpose. An administrator can manage their routers via the web"
    },
    {
      "Time_Start": 178.94000000000003,
      "Time_End": 183.94000000000003,
      "Text": " panel or Winbox which is a Windows UI application. It's also a popular attack service. Because"
    },
    {
      "Time_Start": 186.44000000000003,
      "Time_End": 193.08,
      "Text": " the Winbox interface on the router can be used to talk to other Nova Binary. Some of them can"
    },
    {
      "Time_Start": 193.08,
      "Time_End": 198.08,
      "Text": " be accessed without authentication. To understand how people research the router OS, let's have a"
    },
    {
      "Time_Start": 200.82000000000002,
      "Time_End": 205.82000000000002,
      "Text": " look at past CVEs of the router OS. There are a total of 80 CVEs. And each CVE has a"
    },
    {
      "Time_Start": 209.5,
      "Time_End": 214.5,
      "Text": " vulnerability. And the 28 of them are pre-auth exploitable and the victim is the router itself. 16"
    },
    {
      "Time_Start": 218.38000000000002,
      "Time_End": 223.38000000000002,
      "Text": " out of the 28 are those in various components. 8 out of 28 are DNS poisoning, allowing"
    },
    {
      "Time_Start": 226.12,
      "Time_End": 231.12,
      "Text": " attacker to MITM, or uh firewall evasion. Only 4 pre-auth vulnerabilities in history can lead"
    },
    {
      "Time_Start": 232.12,
      "Time_End": 237.12,
      "Text": " to a shell or locking us admin directly without user interaction. These are what we care"
    },
    {
      "Time_Start": 241.86,
      "Time_End": 246.86,
      "Text": " about. 3 out of 4 were found between 2017 and 2019. And 3 out of 4 are in the wild. Let's"
    },
    {
      "Time_Start": 253.54000000000002,
      "Time_End": 258.54,
      "Text": " have a close look. CVE 2017-20149 aka Chimerae is one of the exploits leaking from a"
    },
    {
      "Time_Start": 258.90000000000003,
      "Time_End": 263.90000000000003,
      "Text": " CIA in uh 2017. By sending an HTTP request with crafty content length so we can corrupt stack"
    },
    {
      "Time_Start": 268.78000000000003,
      "Time_End": 273.78000000000003,
      "Text": " to execute arbitrary code by slag- by stack clash. CVE 2018-7445 is a buffer overflow in"
    },
    {
      "Time_Start": 278.02000000000004,
      "Time_End": 283.02000000000004,
      "Text": " SMB found by black box- black box fuzzing. CVE 2018-14847 is also one of the exploits"
    },
    {
      "Time_Start": 283.02,
      "Time_End": 288.02,
      "Text": " leaking from a CIA in 2017. This bug allows unauthenticated attackers to read arbitrary"
    },
    {
      "Time_Start": 295.71999999999997,
      "Time_End": 302.21999999999997,
      "Text": " file on router OS. It sounds not a big deal in the first place but since the password store"
    },
    {
      "Time_Start": 302.21999999999997,
      "Time_End": 307.24,
      "Text": " on router OS was from simply repeating XOR password in plain text with the hash of the"
    },
    {
      "Time_Start": 308.24,
      "Time_End": 313.24,
      "Text": " username and uh fixed string at that time. So the password can be recovered easily and the"
    },
    {
      "Time_Start": 317.04,
      "Time_End": 322.04,
      "Text": " bug with arbitrary file reading is sufficient to lock in us admin. CVE 2021-41987 is a"
    },
    {
      "Time_Start": 326.32,
      "Time_End": 331.32,
      "Text": " heap buffer overflow in the decode of the SCP service. This was discovered on an APTC2 server"
    },
    {
      "Time_Start": 332.28,
      "Time_End": 337.28,
      "Text": " in 2021. As we can see, these vulnerabilities are mostly in the wild. We can't learn too much"
    },
    {
      "Time_Start": 342.52,
      "Time_End": 347.52,
      "Text": " from them directly. So, let's take a look at some talks and articles about the router OS. In"
    },
    {
      "Time_Start": 350.15999999999997,
      "Time_End": 355.15999999999997,
      "Text": " 2017, there are 3 talks and they are about the package format adopted by the router OS, the"
    },
    {
      "Time_Start": 355.28000000000003,
      "Time_End": 360.28000000000003,
      "Text": " developer's backdoor, how the router OS store the password, et cetera. Uh, talks are"
    },
    {
      "Time_Start": 363.12,
      "Time_End": 368.12,
      "Text": " interesting and helpful to have a big picture of the router OS. In 2018, the talk, Bug"
    },
    {
      "Time_Start": 370.66,
      "Time_End": 375.86,
      "Text": " Hunting in Router OS, Analyze the Normal Message in Binary and JSON Format, introduced"
    },
    {
      "Time_Start": 375.86,
      "Time_End": 381.44000000000005,
      "Text": " the How Winbox Client Talked to the Winbox Interface by Normal Message, and found the Post-O"
    },
    {
      "Time_Start": 381.66,
      "Time_End": 386.66,
      "Text": " Stack Overflow. In 2019, the first one is the same as the previous one, so the next one is"
    },
    {
      "Time_Start": 391.6,
      "Time_End": 396.6,
      "Text": " MicroTik Firewall and Net Bypass. It's a talk about the vulnerability in the Winbox that can be"
    },
    {
      "Time_Start": 398.24,
      "Time_End": 403.24,
      "Text": " used to scan the intranet if the Winbox is exposed to the intranet. The next, Finding and"
    },
    {
      "Time_Start": 403.98,
      "Time_End": 408.98,
      "Text": " Exploiting CVE, Found a Stack Buffer Overflow in SMB by Black Box Fuzzing, and explain how"
    },
    {
      "Time_Start": 415.56,
      "Time_End": 420.56,
      "Text": " they got the shell with their exploit on the router OS VM. And the Deep Dive MicroTik"
    },
    {
      "Time_Start": 423.6,
      "Time_End": 428.6,
      "Text": " Exploits. It's a security, uh, analyze about the CIA exploits and the massive exploit"
    },
    {
      "Time_Start": 429.3,
      "Time_End": 434.3,
      "Text": " event based on the leaky payload. The next one, Help Me Vulnerability, You Are My Only"
    },
    {
      "Time_Start": 437.28000000000003,
      "Time_End": 442.28000000000003,
      "Text": " Hope, released a tool to help users to jailbreak their device to check if leaky exploit was"
    },
    {
      "Time_Start": 444.58000000000004,
      "Time_End": 449.58000000000004,
      "Text": " already compromising them. And the last one, Router OS Chain to Root, it's a, it's about"
    },
    {
      "Time_Start": 451.32000000000005,
      "Time_End": 456.32000000000005,
      "Text": " chaining DNS poisoning vulnerability and a downgrade attack to get a shell. Finally,"
    },
    {
      "Time_Start": 458.92,
      "Time_End": 463.92,
      "Text": " in 2022, pulling MicroTik into the limelight, talk more about NOVA message and disclose, uh,"
    },
    {
      "Time_Start": 466.5,
      "Time_End": 472.08000000000004,
      "Text": " post-auth vulnerability in triple W that can be used to jailbreak. They also released a tool"
    },
    {
      "Time_Start": 472.08000000000004,
      "Time_End": 477.08000000000004,
      "Text": " to help researchers quickly get a shell on the AMD 64 version of router OS with the vulnerability."
    },
    {
      "Time_Start": 480.54,
      "Time_End": 486.22,
      "Text": " It seems like the whole world is talking about the NOVA message in the IPC of the router OS."
    },
    {
      "Time_Start": 486.24,
      "Time_End": 491.24,
      "Text": " So we also try to understand what it is. Let's talk about the IPC of router OS with an example."
    },
    {
      "Time_Start": 493.72,
      "Time_End": 499.02000000000004,
      "Text": " While a user log in through the telnet to access the console of router OS, the telnet will"
    },
    {
      "Time_Start": 499.02000000000004,
      "Time_End": 504.02000000000004,
      "Text": " immediately call the EXECL to execute the login process to ask the user for a username and"
    },
    {
      "Time_Start": 505.62,
      "Time_End": 511.6,
      "Text": " password. Then the login process will send a NOVA message with your username and the"
    },
    {
      "Time_Start": 511.62,
      "Time_End": 516.62,
      "Text": " password to the user process to check if they are correct. The user process also responds in"
    },
    {
      "Time_Start": 519.26,
      "Time_End": 524.26,
      "Text": " NOVA message. The NOVA message consists of key value pairs and the key can only be numbers."
    },
    {
      "Time_Start": 526.46,
      "Time_End": 533.0,
      "Text": " The key, the systool and the sysform are arrays containing the ID of NOVA binary and the ID of"
    },
    {
      "Time_Start": 533.0,
      "Time_End": 539.74,
      "Text": " the handler. The communication between two process is something like this. Every message is"
    },
    {
      "Time_Start": 539.78,
      "Time_End": 545.22,
      "Text": " sent to the loader via socket and the loader dispatches the message to the corresponding"
    },
    {
      "Time_Start": 545.22,
      "Time_End": 550.22,
      "Text": " binary. Login process sends a request with a username and password to the user process. The"
    },
    {
      "Time_Start": 554.46,
      "Time_End": 559.46,
      "Text": " value of systool means the target is the handler 4 and the binary ID is 13. And the process"
    },
    {
      "Time_Start": 563.14,
      "Time_End": 568.14,
      "Text": " itself does doesn't have to fill the sysform with its process ID because the loader will do the"
    },
    {
      "Time_Start": 570.34,
      "Time_End": 575.34,
      "Text": " process. We do that based on which socket is received the message from. Next, uh, the loader"
    },
    {
      "Time_Start": 577.52,
      "Time_End": 582.52,
      "Text": " removes the target binary ID in systool as the source ID to sysform and then forward the message"
    },
    {
      "Time_Start": 584.76,
      "Time_End": 590.2,
      "Text": " to the target process. When the user process receives the message from the socket, it also"
    },
    {
      "Time_Start": 590.2,
      "Time_End": 595.4,
      "Text": " removes the handler from the systool and passes it to the corresponding handler. Then the"
    },
    {
      "Time_Start": 595.4,
      "Time_End": 601.9399999999999,
      "Text": " handler does the rest of the thing. We mentioned that a winbox interface on the router OS is a"
    },
    {
      "Time_Start": 601.9399999999999,
      "Time_End": 608.64,
      "Text": " popular attack service since it can be used to access all the process. That's because the"
    },
    {
      "Time_Start": 608.64,
      "Time_End": 613.98,
      "Text": " protocol winbox client used to talk to the interface on the router is basically a NOVA"
    },
    {
      "Time_Start": 613.98,
      "Time_End": 620.56,
      "Text": " message in the TCP packet. So if the target handler failed to check the sender's priv-"
    },
    {
      "Time_Start": 620.62,
      "Time_End": 625.62,
      "Text": " privilege, that can cause problems. No- NOVA message is type value mapping and can contain"
    },
    {
      "Time_Start": 628.2600000000001,
      "Time_End": 633.2600000000001,
      "Text": " various types and also NOVA message itself. Because the JSON format of the NOVA message is"
    },
    {
      "Time_Start": 636.0000000000001,
      "Time_End": 641.0000000000001,
      "Text": " deprecated, we only talk about the binary form today. Okay, the M2 at- at the beginning is the"
    },
    {
      "Time_Start": 642.0,
      "Time_End": 647.0,
      "Text": " magic bytes for the NOVA message. Then it use four bytes to describe a key. The first three"
    },
    {
      "Time_Start": 651.1,
      "Time_End": 656.1,
      "Text": " bytes of key are ID and the last byte is- is type. And the bytes following are the value for that"
    },
    {
      "Time_Start": 658.94,
      "Time_End": 663.94,
      "Text": " key. So, this message's ID types and values look like this. Types like bool can be expressed"
    },
    {
      "Time_Start": 663.94,
      "Time_End": 668.94,
      "Text": " with one bit directly using the lower bit of the type bytes. To understand which binary"
    },
    {
      "Time_Start": 675.0400000000001,
      "Time_End": 681.2800000000001,
      "Text": " corresponding to the ID in the sysrom and sys2, we need to parse x3 file under the loader"
    },
    {
      "Time_Start": 681.2800000000001,
      "Time_End": 686.2800000000001,
      "Text": " directory. It's kind of XML but in binary form. If the binary was introduced by installing a"
    },
    {
      "Time_Start": 687.0,
      "Time_End": 692.0,
      "Text": " package, it's ID is under the loader directory of that package. Some IDs can- can be found in"
    },
    {
      "Time_Start": 698.54,
      "Time_End": 703.54,
      "Text": " the x3 file because the process is not persistent. The ID is just a serial number like the"
    },
    {
      "Time_Start": 706.68,
      "Time_End": 711.68,
      "Text": " locking process we just mentioned. Other binaries also have their x3 files for different"
    },
    {
      "Time_Start": 712.4200000000001,
      "Time_End": 717.4200000000001,
      "Text": " purpose. For example, the x3 of triple w- of triple w describe which URI should be handled by"
    },
    {
      "Time_Start": 721.5000000000001,
      "Time_End": 726.5000000000001,
      "Text": " which servlet. It seems like it's a good target for parsing, right? But we can't just parse it"
    },
    {
      "Time_Start": 729.0400000000001,
      "Time_End": 734.0400000000001,
      "Text": " and expect that we get something after 2 months. Now, it's a spoiler. While we were writing"
    },
    {
      "Time_Start": 734.8399999999999,
      "Time_End": 739.8399999999999,
      "Text": " our exploit with the vulnerability that I will introduce later, uh, talk at POC 2022,"
    },
    {
      "Time_Start": 744.28,
      "Time_End": 749.28,
      "Text": " MicroTik wrote OS security, the forgotten IPC message. Though I think it's far from forgotten,"
    },
    {
      "Time_Start": 751.92,
      "Time_End": 756.92,
      "Text": " but anyway, the talk is about parsing and the Nova message. And it found lots of post-auth"
    },
    {
      "Time_Start": 757.38,
      "Time_End": 762.38,
      "Text": " CVEs. By the number of CVEs, it looks like the fuzzer has been running for a long time. A"
    },
    {
      "Time_Start": 767.36,
      "Time_End": 773.0,
      "Text": " bit of an afterthought, I don't think we can get a better result if we do the same thing at"
    },
    {
      "Time_Start": 773.0,
      "Time_End": 778.0,
      "Text": " the time. Not to mention that we only have 2 months. So, is it still possible to pwn the"
    },
    {
      "Time_Start": 778.8,
      "Time_End": 783.8,
      "Text": " router OS? Review these CVEs again. Most of the most of the vulnerability we think interesting"
    },
    {
      "Time_Start": 789.04,
      "Time_End": 795.34,
      "Text": " were discovered many years ago. Researchers also found lots of vulnerability, but as we can"
    },
    {
      "Time_Start": 795.34,
      "Time_End": 800.34,
      "Text": " see, the MicroTik becomes safer and safer. But in 2021, a vulnerability in the SCEP server"
    },
    {
      "Time_Start": 800.4,
      "Time_End": 805.4,
      "Text": " we just mentioned was discovered by analyzing an in the wild exploit on the APT C2 server."
    },
    {
      "Time_Start": 811.08,
      "Time_End": 816.08,
      "Text": " Was it- was it undiscovered until- until then because it was not a default feature? Or is it"
    },
    {
      "Time_Start": 819.02,
      "Time_End": 824.02,
      "Text": " just because people have overlooked something? Most talks and articles focus on jailbreaking,"
    },
    {
      "Time_Start": 824.88,
      "Time_End": 829.88,
      "Text": " analyzing the in the wild exploits and normal message in IPC. I have a summary after reading"
    },
    {
      "Time_Start": 833.72,
      "Time_End": 838.72,
      "Text": " them and starting to reverse by ourself. That is, no one with sanity will like to dive into the"
    },
    {
      "Time_Start": 840.66,
      "Time_End": 845.66,
      "Text": " details of normal binaries. I mean, it's expect for the exploits from the CIA and APT. Most of"
    },
    {
      "Time_Start": 846.66,
      "Time_End": 851.66,
      "Text": " the research about bug hunting is fuzzing the protocol playing with normal message or"
    },
    {
      "Time_Start": 855.26,
      "Time_End": 860.1,
      "Text": " fuzzing normal message. By the outcome, it seems like attackers are familiar with the router OS"
    },
    {
      "Time_Start": 860.1,
      "Time_End": 865.1,
      "Text": " than us. We need more details about the normal message. And don't get me wrong, I'm not"
    },
    {
      "Time_Start": 868.74,
      "Time_End": 873.74,
      "Text": " against fuzzing, but we have to ensure we check everything to take- to take advantage of the"
    },
    {
      "Time_Start": 875.78,
      "Time_End": 880.78,
      "Text": " contest. I don't think the system is perfect now. There's a gap between researchers and attackers."
    },
    {
      "Time_Start": 883.4599999999999,
      "Time_End": 889.16,
      "Text": " So what was missed if we want to find some preauth RCE bugs in router OS? The first"
    },
    {
      "Time_Start": 889.16,
      "Time_End": 894.16,
      "Text": " question is, where are the entry point to the customized IPC? Most of them can only access by"
    },
    {
      "Time_Start": 896.5,
      "Time_End": 901.5,
      "Text": " authenticated user. We can foresee that playing with normal message in IPC will result in lots"
    },
    {
      "Time_Start": 901.82,
      "Time_End": 906.82,
      "Text": " of post-auth bugs. IPC just a part of implementation of the MOS functionality. We want to"
    },
    {
      "Time_Start": 912.2,
      "Time_End": 917.2,
      "Text": " review the crucial part directly and carefully. For example, how does the DSCP process pass a"
    },
    {
      "Time_Start": 919.4,
      "Time_End": 924.4,
      "Text": " DSCP packet to extract the info in it? Then we have to mention architecture of the normal"
    },
    {
      "Time_Start": 925.14,
      "Time_End": 930.14,
      "Text": " message, normal binary. Every normal binary has a looper. The looper use port to check the"
    },
    {
      "Time_Start": 934.3199999999999,
      "Time_End": 939.3199999999999,
      "Text": " status of socket and process event in each loop just like a regular event loop you've seen"
    },
    {
      "Time_Start": 941.26,
      "Time_End": 946.4,
      "Text": " everywhere. Looper is responsible for the communication between the kernel process and the"
    },
    {
      "Time_Start": 946.4,
      "Time_End": 951.64,
      "Text": " loader. The looper register a special callback for the unit socket which is used to"
    },
    {
      "Time_Start": 951.64,
      "Time_End": 957.92,
      "Text": " communicate with loader. The special callback on MSG sock will dispatch the message to the"
    },
    {
      "Time_Start": 957.92,
      "Time_End": 964.26,
      "Text": " corresponding handler once it receive normal message from the socket. So, how does the"
    },
    {
      "Time_Start": 964.26,
      "Time_End": 969.4,
      "Text": " handler work? While the looper receive a normal message, it will dispatch it to the"
    },
    {
      "Time_Start": 969.4,
      "Time_End": 974.4,
      "Text": " corresponding handler. Look at the right hand side. And let's assume that handler 1 is"
    },
    {
      "Time_Start": 975.1,
      "Time_End": 980.1,
      "Text": " responsible for the normal message. And then you call a function in vtable with the CMD"
    },
    {
      "Time_Start": 983.34,
      "Time_End": 988.34,
      "Text": " prefix like corresponding to the command specified by the C's CMD. There are many"
    },
    {
      "Time_Start": 991.3199999999999,
      "Time_End": 996.3199999999999,
      "Text": " functions here but because the handler is the base class, commands relative to objects are"
    },
    {
      "Time_Start": 996.88,
      "Time_End": 1001.88,
      "Text": " unimplemented. The CMD unknown is often overridden and used to extend the customized"
    },
    {
      "Time_Start": 1007.46,
      "Time_End": 1012.46,
      "Text": " command. Sometimes the developers override the handle CMD instead of the CMD unknown. You"
    },
    {
      "Time_Start": 1015.6400000000001,
      "Time_End": 1020.6400000000001,
      "Text": " may have already read some of this in a past research. But most of the time, the normal"
    },
    {
      "Time_Start": 1020.96,
      "Time_End": 1025.96,
      "Text": " binary use the derived classes rather than the best handler class. The derived classes can"
    },
    {
      "Time_Start": 1028.8,
      "Time_End": 1034.98,
      "Text": " store a collection of object of a specific type. For for example, while the user is setting up a"
    },
    {
      "Time_Start": 1034.98,
      "Time_End": 1041.42,
      "Text": " DHCP server, they will send a message to the handler 0 of DHCP process to create a DHCP"
    },
    {
      "Time_Start": 1041.42,
      "Time_End": 1046.42,
      "Text": " server. The handler 0 which is an instance of AMAP calls the function on its vtable with offset"
    },
    {
      "Time_Start": 1047.28,
      "Time_End": 1052.28,
      "Text": " hex 7c to create a DHCP server object and insert it into a tree. The 7c is the offset to the"
    },
    {
      "Time_Start": 1058.52,
      "Time_End": 1064.16,
      "Text": " constructor of the inner object. And you can find the offset of such function in other derived"
    },
    {
      "Time_Start": 1064.16,
      "Time_End": 1069.16,
      "Text": " classes by reversing the CMD add object. In the previous example, the web panel sends a normal"
    },
    {
      "Time_Start": 1069.38,
      "Time_End": 1074.38,
      "Text": " message to DHCP to create a DHCP server. But what if I told you that some functionality don't"
    },
    {
      "Time_Start": 1081.02,
      "Time_End": 1086.02,
      "Text": " even use the normal message? Take the CDP and the LLDP for example. They are implemented in"
    },
    {
      "Time_Start": 1088.1000000000001,
      "Time_End": 1094.5400000000002,
      "Text": " discover. The looper register 2 callback functions. The looper keeps looping and check the"
    },
    {
      "Time_Start": 1094.56,
      "Time_End": 1099.56,
      "Text": " status of sockets. If there are incoming packets, the looper call a callback function. The"
    },
    {
      "Time_Start": 1101.8,
      "Time_End": 1107.6,
      "Text": " callback of CDP will check if the interface that receive the packet is not filtered by firewall"
    },
    {
      "Time_Start": 1107.6,
      "Time_End": 1114.6,
      "Text": " rule. Then extract the information from the packet and store them directly into another ASEC"
    },
    {
      "Time_Start": 1114.6,
      "Time_End": 1119.62,
      "Text": " map without sending normal message. So there's no normal message here. So, we started to"
    },
    {
      "Time_Start": 1120.4,
      "Time_End": 1125.4,
      "Text": " review the router OS by enumerating functions and reversing them. Then we found something"
    },
    {
      "Time_Start": 1127.94,
      "Time_End": 1132.94,
      "Text": " strange. One day, while plugging and unplugging some cable connect to the router, suddenly the"
    },
    {
      "Time_Start": 1135.68,
      "Time_End": 1142.8600000000001,
      "Text": " log file showed that RADVD crashed several times. So we tried to reproduce the crash by manually"
    },
    {
      "Time_Start": 1142.8600000000001,
      "Time_End": 1148.8600000000001,
      "Text": " plugging and unplugging cables about a thousand times. But couldn't figure out the crash"
    },
    {
      "Time_Start": 1148.8600000000001,
      "Time_End": 1153.88,
      "Text": " condition. The condition is unknown and the crash appears randomly. Instead of mindlessly"
    },
    {
      "Time_Start": 1156.88,
      "Time_End": 1163.3200000000002,
      "Text": " unplugging and plugging the cables, we reversed the RADVD to see if we can find something"
    },
    {
      "Time_Start": 1163.3200000000002,
      "Time_End": 1170.3200000000002,
      "Text": " interesting. We didn't find the root cause of the crash, but we got something better. So, why"
    },
    {
      "Time_Start": 1171.66,
      "Time_End": 1176.66,
      "Text": " is RADVD? RADVD is a service about SLAAC of IPv6. Let's say a computer, let's say,"
    },
    {
      "Time_Start": 1178.8600000000001,
      "Time_End": 1183.8600000000001,
      "Text": " or a node, wants to get an IPv6 address. It will first multiply the rout- router"
    },
    {
      "Time_Start": 1186.5400000000002,
      "Time_End": 1191.5400000000002,
      "Text": " solicitation to all router asking for a network prefix. Then, if a router receives the OS,"
    },
    {
      "Time_Start": 1195.38,
      "Time_End": 1202.2600000000002,
      "Text": " we will- it will multiply the router advertisement with network prefix to all nodes. After that,"
    },
    {
      "Time_Start": 1202.26,
      "Time_End": 1207.26,
      "Text": " a node can calculate its IPv6 address by combining the network prefix and EUI-64, which is"
    },
    {
      "Time_Start": 1210.8,
      "Time_End": 1215.8,
      "Text": " calculated from the MAC address. Another scenario is like if an upstream router, router A, maybe"
    },
    {
      "Time_Start": 1218.44,
      "Time_End": 1223.44,
      "Text": " it's an IS- ISP. They give you a prefix with slash 48, which assign in advance by email or"
    },
    {
      "Time_Start": 1226.24,
      "Time_End": 1231.24,
      "Text": " something. Then you can use them with whatever- whatever you want in your network prefix."
    },
    {
      "Time_Start": 1232.26,
      "Time_End": 1237.26,
      "Text": " Then- then here comes the link prefix and router prefix. First, the router B act- act as a"
    },
    {
      "Time_Start": 1241.3,
      "Time_End": 1248.04,
      "Text": " node on the interface that link to the router A. The router B ask router A for a prefix. The"
    },
    {
      "Time_Start": 1248.04,
      "Time_End": 1253.04,
      "Text": " router A send a slash 64 prefix for router B to calculate its IPv6 address. Router B"
    },
    {
      "Time_Start": 1253.6,
      "Time_End": 1258.6,
      "Text": " calculate an IPv6 address. Let's say it's 2001 colon DBA colon colon 1. And use it on the"
    },
    {
      "Time_Start": 1264.28,
      "Time_End": 1271.22,
      "Text": " interface that links to- with router A. So now, the router A can route all traffic to the"
    },
    {
      "Time_Start": 1271.22,
      "Time_End": 1276.22,
      "Text": " address on the slash 48 to router B. Now when nodes want to get IPv6 and send OS to the"
    },
    {
      "Time_Start": 1277.22,
      "Time_End": 1282.22,
      "Text": " router B, the router B just multicast the slash 48 prefix to nodes. Then the nodes act as"
    },
    {
      "Time_Start": 1289.8600000000001,
      "Time_End": 1296.3,
      "Text": " usual. So the functionality of RA-DVD in router OS should have two function- two"
    },
    {
      "Time_Start": 1296.3,
      "Time_End": 1301.3,
      "Text": " functionality. It- first, it can act as a node to receive RA. And it can also multicast RA to"
    },
    {
      "Time_Start": 1301.6,
      "Time_End": 1306.6,
      "Text": " the LAN. Let's follow the execution flow of RA-DVD to find a bug. The RA-DVD have a similar"
    },
    {
      "Time_Start": 1313.8,
      "Time_End": 1319.54,
      "Text": " design pattern to the discover process we mentioned earlier. It register a callback, the"
    },
    {
      "Time_Start": 1319.54,
      "Time_End": 1324.54,
      "Text": " looper pull a socket in every loop. And there- if there is an incoming ICMPv6 socket, the"
    },
    {
      "Time_Start": 1325.1,
      "Time_End": 1330.1,
      "Text": " looper call a register callback. What callback do is roughly like this. It check if the"
    },
    {
      "Time_Start": 1336.28,
      "Time_End": 1341.28,
      "Text": " packet is a valid RA or a valid RS. If it is a RA, then extract information and store them in"
    },
    {
      "Time_Start": 1344.98,
      "Time_End": 1349.98,
      "Text": " the handler 1 which is AMAP. And if it is an RA, it will multicast the RA immediately. Oh"
    },
    {
      "Time_Start": 1350.94,
      "Time_End": 1355.94,
      "Text": " sorry, if it is RS, it will multicast RA immediately. There are 3 cases the router OS will"
    },
    {
      "Time_Start": 1361.88,
      "Time_End": 1367.92,
      "Text": " multicast the prefix to nodes. The first one is when you receive the RA's from nodes. The"
    },
    {
      "Time_Start": 1367.92,
      "Time_End": 1374.92,
      "Text": " second is when you receive an RA from upstream router. The last one is when you- sorry, the"
    },
    {
      "Time_Start": 1374.94,
      "Time_End": 1379.94,
      "Text": " last one is the router will multicast prefix in a default period which is in 200 to 600"
    },
    {
      "Time_Start": 1383.18,
      "Time_End": 1388.18,
      "Text": " seconds. And yes, the router will multicast the RA to nodes once it receive RA. But it's hard"
    },
    {
      "Time_Start": 1393.22,
      "Time_End": 1399.16,
      "Text": " to trace this behavior directly because this is about a subscription. I'll talk about it"
    },
    {
      "Time_Start": 1399.2,
      "Time_End": 1404.2,
      "Text": " later. We didn't know that then. But the other 2 cases can be traced directly. The RA DVD"
    },
    {
      "Time_Start": 1407.98,
      "Time_End": 1412.98,
      "Text": " call send RA right after it receive an RS. The handler 1 register a timer to send RA"
    },
    {
      "Time_Start": 1416.16,
      "Time_End": 1421.16,
      "Text": " periodically. So, we can find the send RA function by tracing these 2 methods. Following the"
    },
    {
      "Time_Start": 1422.16,
      "Time_End": 1427.16,
      "Text": " send RA function, we found something interesting while the RA DVD deal with DNS advisory. It"
    },
    {
      "Time_Start": 1432.44,
      "Time_End": 1437.44,
      "Text": " will advise DNS to nodes based on the DNS list it received from upstream. The ADD DNS"
    },
    {
      "Time_Start": 1440.0800000000002,
      "Time_End": 1445.0800000000002,
      "Text": " function is used to flatten the DNS tree and add it to the ICMPv6. The RA row is the ICMPv6"
    },
    {
      "Time_Start": 1446.08,
      "Time_End": 1451.08,
      "Text": " payload which is the local variable with a size of 496 bytes. Step into the ADD DNS and we"
    },
    {
      "Time_Start": 1458.8799999999999,
      "Time_End": 1463.8799999999999,
      "Text": " can immediately find out there is a probably a stack buffer overflow. The function ADD"
    },
    {
      "Time_Start": 1466.6,
      "Time_End": 1471.6,
      "Text": " DNS to packets by memory copy without any- without any bundling check. That causes stack"
    },
    {
      "Time_Start": 1471.6200000000001,
      "Time_End": 1476.6200000000001,
      "Text": " buffer overflow in if the DNS is big enough. The DNS addresses are from the RDNSS of the RA."
    },
    {
      "Time_Start": 1482.66,
      "Time_End": 1489.66,
      "Text": " But the max length of the RDNSS of an RA is 8 by- 8 bit which is insufficient to override the"
    },
    {
      "Time_Start": 1489.66,
      "Time_End": 1494.68,
      "Text": " return address. But if this is not the first time the router OS receive an RA, the RA DVD"
    },
    {
      "Time_Start": 1495.16,
      "Time_End": 1500.16,
      "Text": " have to expire all RDNSS. That makes the RD- RA DVD flatten another tree to override more"
    },
    {
      "Time_Start": 1506.8400000000001,
      "Time_End": 1511.8400000000001,
      "Text": " bytes for- for us. So what we have to do is we have to act as a bay neighbor. Let's send a"
    },
    {
      "Time_Start": 1516.48,
      "Time_End": 1521.48,
      "Text": " router advertisement with a big RDNSS list to the target router. Then send another router"
    },
    {
      "Time_Start": 1521.98,
      "Time_End": 1526.98,
      "Text": " advi- advertisement with a big RDNSS list. Now the return address is over- overwritten with an IPv6"
    },
    {
      "Time_Start": 1533.8600000000001,
      "Time_End": 1538.8600000000001,
      "Text": " address in the RDNSS of the first RA. It's time to construct the exploits. And it looks easy"
    },
    {
      "Time_Start": 1543.34,
      "Time_End": 1550.0,
      "Text": " because there is no protection enable. So let's find a way to jump on the stack and run our"
    },
    {
      "Time_Start": 1550.0,
      "Time_End": 1555.0,
      "Text": " shellcode. That should be easy. Thank you. The overflow IPv6 addresses are sorted since they"
    },
    {
      "Time_Start": 1560.04,
      "Time_End": 1566.38,
      "Text": " were stored in the tree. To make the order of the IP addresses stable to ensure the shellcode is"
    },
    {
      "Time_Start": 1566.38,
      "Time_End": 1571.38,
      "Text": " good, we can use part of the IPv6 prefix as a serial number and put a jump and at the end of each"
    },
    {
      "Time_Start": 1573.82,
      "Time_End": 1578.82,
      "Text": " address to jump over the prefix because they are not valid instructions. But because the"
    },
    {
      "Time_Start": 1580.7,
      "Time_End": 1587.7,
      "Text": " delay slot of MIPS, which means uh the instruction after the branch instruction will always be"
    },
    {
      "Time_Start": 1587.7,
      "Time_End": 1592.7,
      "Text": " executed before the branch instruction itself, we have to move the jump instruction forward. But"
    },
    {
      "Time_Start": 1596.04,
      "Time_End": 1601.04,
      "Text": " the other problem is that you cannot do a syscall in the delay slot. So basically this is a bad"
    },
    {
      "Time_Start": 1603.92,
      "Time_End": 1608.92,
      "Text": " idea. It's actually a CTF 101 problem, just make a prefix a valid instruction. So the"
    },
    {
      "Time_Start": 1610.86,
      "Time_End": 1616.3,
      "Text": " branch instruction, they won't affect our gadget or shellcode, then everything is fine. And"
    },
    {
      "Time_Start": 1616.3,
      "Time_End": 1623.16,
      "Text": " because we didn't leak any stack address, plus we didn't find any gadget that can be used to"
    },
    {
      "Time_Start": 1623.16,
      "Time_End": 1628.18,
      "Text": " move stack pointer to register T9 for jump instruction in the first place. So what we did"
    },
    {
      "Time_Start": 1631.48,
      "Time_End": 1636.48,
      "Text": " here is first write our gadget on memory, then jump to that gadget. Finally our shellcode will"
    },
    {
      "Time_Start": 1637.4,
      "Time_End": 1642.4,
      "Text": " be executed. Sounds good, but there is eye cache. The MIPS CPU has two cache, the instruction"
    },
    {
      "Time_Start": 1648.34,
      "Time_End": 1654.48,
      "Text": " cache and the data cache. While writing our gadget on memory, we are actually writing on"
    },
    {
      "Time_Start": 1654.48,
      "Time_End": 1659.48,
      "Text": " dcache. Now when we try to control execution flow of executes, uh sorry, to execute the gadget"
    },
    {
      "Time_Start": 1660.42,
      "Time_End": 1665.42,
      "Text": " for running our shellcode, the process- the processor first check if the instruction are"
    },
    {
      "Time_Start": 1669.26,
      "Time_End": 1674.26,
      "Text": " already in the eye cache. Because we wrote our gadget on the data section, the cache always"
    },
    {
      "Time_Start": 1676.7,
      "Time_End": 1681.7,
      "Text": " miss it. So the memory content will be loaded into eye cache. They cause the process- they"
    },
    {
      "Time_Start": 1681.7,
      "Time_End": 1686.7,
      "Text": " cause the processor to execute a bunch of no- nope until the program crash. To flush the"
    },
    {
      "Time_Start": 1693.18,
      "Time_End": 1699.82,
      "Text": " dcache, we need to make the processor content switch or exhaust the dcache whose size is"
    },
    {
      "Time_Start": 1699.82,
      "Time_End": 1704.82,
      "Text": " 32 kilobytes. There is no sleep in RADVD. Other functions we also trap into the kernel, but"
    },
    {
      "Time_Start": 1705.12,
      "Time_End": 1710.12,
      "Text": " they don't guarantee the content switch will always happen. To make our exploit consistently"
    },
    {
      "Time_Start": 1713.02,
      "Time_End": 1718.02,
      "Text": " successful in maximizing the chance to win the game, we have to flush the 32 kilobyte dcache."
    },
    {
      "Time_Start": 1721.86,
      "Time_End": 1726.86,
      "Text": " Luckily, the value in ran- randomized VA space of router OS is 1, which means the heap is not"
    },
    {
      "Time_Start": 1727.22,
      "Time_End": 1732.22,
      "Text": " randomized. The only things we need to do is do some memory allocation to extend the heap and"
    },
    {
      "Time_Start": 1737.1000000000001,
      "Time_End": 1742.1000000000001,
      "Text": " write some gadget on it. We may run out of bytes for shellcode because of that. But the DNS"
    },
    {
      "Time_Start": 1746.3000000000002,
      "Time_End": 1751.3000000000002,
      "Text": " addresses were stored in a tree. They cost lots of memory space. The heap is already larger"
    },
    {
      "Time_Start": 1751.56,
      "Time_End": 1756.56,
      "Text": " than 32 kilobytes during the proc- during the processing of a request. So we can call the"
    },
    {
      "Time_Start": 1761.0,
      "Time_End": 1766.0,
      "Text": " memory copy by GOT hijack to write 32 kilobytes garbage on the heap to flush the dcache for our"
    },
    {
      "Time_Start": 1768.3799999999999,
      "Time_End": 1773.3799999999999,
      "Text": " shellcode directly. And the profit. The vulnerability was assigned CVE 2020- 2023-32154."
    },
    {
      "Time_Start": 1781.72,
      "Time_End": 1788.5,
      "Text": " And it's already been fixed. After that, we found a vulnerable code had existed at least since"
    },
    {
      "Time_Start": 1788.5,
      "Time_End": 1793.5,
      "Text": " the router OS v6. This means the vulnerability has existed since 2013. 9 years until we found"
    },
    {
      "Time_Start": 1797.94,
      "Time_End": 1802.94,
      "Text": " it and 10 years until they fixed it. So, no one with sanity would like to dive into the details"
    },
    {
      "Time_Start": 1802.96,
      "Time_End": 1807.96,
      "Text": " of a normal binary. QED, you're welcome. Combine the exploit with our exploit for the canon"
    },
    {
      "Time_Start": 1812.6000000000001,
      "Time_End": 1818.54,
      "Text": " printer for the point to own. The attacking scenario is that an attacker is a bad neighbor of"
    },
    {
      "Time_Start": 1818.54,
      "Time_End": 1823.54,
      "Text": " the microtech router, sending crafty ICMP v6 to attacking the ro- router. And if we, if we"
    },
    {
      "Time_Start": 1826.1200000000001,
      "Time_End": 1832.02,
      "Text": " compromise the router successfully, we can forward our payload to attack the printer behind the"
    },
    {
      "Time_Start": 1832.04,
      "Time_End": 1837.04,
      "Text": " router. The whole setup can be simplified as such in the context. Just let our laptop act- act"
    },
    {
      "Time_Start": 1839.8799999999999,
      "Time_End": 1844.8799999999999,
      "Text": " as the upstream router of the target router. We can almost see our 100k voting. But, another"
    },
    {
      "Time_Start": 1849.56,
      "Time_End": 1854.56,
      "Text": " but, our exploit only working on macOS and fail on Ubuntu, whether it's uh VM or not. We try to"
    },
    {
      "Time_Start": 1854.58,
      "Time_End": 1859.58,
      "Text": " debug the exploit by running the exploit on VM and recording the traffic. Dump those traffic"
    },
    {
      "Time_Start": 1865.4199999999998,
      "Time_End": 1870.4199999999998,
      "Text": " and replay it. It just fail as we expected. We also dump the traffic from Ubuntu and replay it"
    },
    {
      "Time_Start": 1873.4199999999998,
      "Time_End": 1878.4199999999998,
      "Text": " on Mac. However, it somehow succeed. So, we guess there is an OS that will reorder the package."
    },
    {
      "Time_Start": 1884.7,
      "Time_End": 1890.44,
      "Text": " We put a sniffer on router to monitor the traffic from Mac and Ubuntu. And because the AF"
    },
    {
      "Time_Start": 1890.44,
      "Time_End": 1895.44,
      "Text": " packet is not affected by any firewall chance, the result should be reliable. But they look the"
    },
    {
      "Time_Start": 1899.22,
      "Time_End": 1904.22,
      "Text": " same. The last result could be that I have to go to Toronto in person. But we can't leave it"
    },
    {
      "Time_Start": 1906.32,
      "Time_End": 1913.32,
      "Text": " like that. Because who knows if the bug will suddenly happen again during the contest. Even on"
    },
    {
      "Time_Start": 1913.36,
      "Time_End": 1918.36,
      "Text": " the macOS. Eventually, we find a problem. It's all about speed. The gaps look tiny and you may"
    },
    {
      "Time_Start": 1921.5,
      "Time_End": 1926.5,
      "Text": " never notice in Wireshark. But the difference between them is actually 390 times. The problem"
    },
    {
      "Time_Start": 1929.2,
      "Time_End": 1935.4399999999998,
      "Text": " is not on Ubuntu, it's just because the Mac sends two packet too quickly causing rest"
    },
    {
      "Time_Start": 1935.4399999999998,
      "Time_End": 1941.08,
      "Text": " condition. Plus, we were lazy and did not actually calculate how many bytes we need to override"
    },
    {
      "Time_Start": 1941.08,
      "Time_End": 1947.32,
      "Text": " the return address. We just send a bunch of garbage and do the pattern matching. So, the"
    },
    {
      "Time_Start": 1947.32,
      "Time_End": 1952.32,
      "Text": " solution is put a sleep before sending the second RA and fixing the offset of our payload. Then"
    },
    {
      "Time_Start": 1954.6599999999999,
      "Time_End": 1959.6599999999999,
      "Text": " it's very stable. The probability of success is almost 100 percent. But how? The RA DVD is"
    },
    {
      "Time_Start": 1962.3,
      "Time_End": 1968.6799999999998,
      "Text": " only 1 thread. How could there be a rest condition? I didn't mention that while the RA DVD"
    },
    {
      "Time_Start": 1968.68,
      "Time_End": 1974.3400000000001,
      "Text": " parsing the incoming packet, the DNS address are stored in a vector. But somehow, the handler"
    },
    {
      "Time_Start": 1974.3400000000001,
      "Time_End": 1980.42,
      "Text": " passed a DNS tree to the add- add DNS function. What's the relationship between these two"
    },
    {
      "Time_Start": 1980.42,
      "Time_End": 1985.42,
      "Text": " members? It's actually about why we can't find where the codebase function multicast the RA"
    },
    {
      "Time_Start": 1987.6200000000001,
      "Time_End": 1994.14,
      "Text": " when you receive an RA packet. Let's look closely at the codebase function. There is an array"
    },
    {
      "Time_Start": 1994.16,
      "Time_End": 2000.44,
      "Text": " responsible for storing something called a remote object. Then it looks straightforward. Just"
    },
    {
      "Time_Start": 2000.44,
      "Time_End": 2005.44,
      "Text": " enter the new DNS vector then do RODNS on each of them and append result to the DNS remote object"
    },
    {
      "Time_Start": 2007.8400000000001,
      "Time_End": 2014.0800000000002,
      "Text": " vector. So, what is the remote object? The remote object is a mechanism to store common"
    },
    {
      "Time_Start": 2014.0800000000002,
      "Time_End": 2019.8200000000002,
      "Text": " resources in the process and other process can access them via ID. For example, a DNS remote"
    },
    {
      "Time_Start": 2019.84,
      "Time_End": 2025.3799999999999,
      "Text": " object is actually stored in the handle 2 of the resolver. And the RA DVD only preserves the ID"
    },
    {
      "Time_Start": 2025.3799999999999,
      "Time_End": 2030.3799999999999,
      "Text": " of the object in handle 1. Now let's talk about the subscription in NOVA binary. The binary IP"
    },
    {
      "Time_Start": 2033.72,
      "Time_End": 2040.12,
      "Text": " pool 6 is responsible for managing the IPv6 address pool. The DHCP subscribes to it so the"
    },
    {
      "Time_Start": 2040.12,
      "Time_End": 2047.04,
      "Text": " DHCP can react to the change. It's done by sending a subscribe NOVA message and the sys notify"
    },
    {
      "Time_Start": 2047.06,
      "Time_End": 2052.06,
      "Text": " the CMD can specify which command you want to subscribe to. The FEOOB means notification. So,"
    },
    {
      "Time_Start": 2058.3,
      "Time_End": 2063.84,
      "Text": " if there is another binary, try to add an object to the handle 1 of IP pool 6 by sending a NOVA"
    },
    {
      "Time_Start": 2063.84,
      "Time_End": 2068.84,
      "Text": " message, the add object of handle 1 will be executed. In most cases, the add object will call"
    },
    {
      "Time_Start": 2069.82,
      "Time_End": 2074.82,
      "Text": " send not- notifies to notify subscribers who subscribe to FEOOB to inform them that the IP pool"
    },
    {
      "Time_Start": 2080.36,
      "Time_End": 2085.36,
      "Text": " 6 has changed. So, when the RA DVD receive a RA from the upstream router, it call RODNS to"
    },
    {
      "Time_Start": 2088.04,
      "Time_End": 2093.04,
      "Text": " create DNS remote object for each IPv6 address in RDNSS of RA. The command add object of"
    },
    {
      "Time_Start": 2093.48,
      "Time_End": 2098.48,
      "Text": " handle 4 in the resolver will- is responsible for such request and will add the IPv6 object into"
    },
    {
      "Time_Start": 2104.08,
      "Time_End": 2109.1,
      "Text": " the handle 2. Also, because the handle 1 of RA DVD subscribes to the hand- resolver's handle 2,"
    },
    {
      "Time_Start": 2111.56,
      "Time_End": 2116.56,
      "Text": " the handle 2 will notify it with every DNS addresses it has now. So, the handle 1 construct the RA"
    },
    {
      "Time_Start": 2117.2999999999997,
      "Time_End": 2122.2999999999997,
      "Text": " for LAN with these DNS addresses. The problem is in the implementation of RODNS. The sends NOVA"
    },
    {
      "Time_Start": 2128.48,
      "Time_End": 2133.48,
      "Text": " message by post message which is non-blocking. It means the remote object won't get the object ID"
    },
    {
      "Time_Start": 2135.74,
      "Time_End": 2140.74,
      "Text": " immediately. So, if we send request too fast, the second RA arrives before the RA DVD gets the"
    },
    {
      "Time_Start": 2141.6800000000003,
      "Time_End": 2146.6800000000003,
      "Text": " object ID of the old remote object. The RA DVD can only soft delete those old objects rather than"
    },
    {
      "Time_Start": 2153.1800000000003,
      "Time_End": 2158.1800000000003,
      "Text": " really delete- delete them. They cause the REST condition. This is what happen if we follow them"
    },
    {
      "Time_Start": 2160.6600000000003,
      "Time_End": 2165.92,
      "Text": " step by step. Because both process are single thread, let's assume they are in the first loop of"
    },
    {
      "Time_Start": 2165.94,
      "Time_End": 2170.94,
      "Text": " the looper while the ROD- RA DVD receive the first RA from WAN with one DNS address. The RA DVD"
    },
    {
      "Time_Start": 2174.46,
      "Time_End": 2179.46,
      "Text": " creates a remote object in the resolver by sending the NOVA message. And the resolver will set"
    },
    {
      "Time_Start": 2182.92,
      "Time_End": 2187.94,
      "Text": " up a timer after receiving the first request because it cannot tell how many aiding operation"
    },
    {
      "Time_Start": 2188.7000000000003,
      "Time_End": 2193.7000000000003,
      "Text": " should be grouped. It should- it just set a timer and send only one notification when the time's"
    },
    {
      "Time_Start": 2198.2400000000002,
      "Time_End": 2203.2400000000002,
      "Text": " up. Apart from notification, the resolver should send a response back to tell RA DVD the object"
    },
    {
      "Time_Start": 2207.78,
      "Time_End": 2212.78,
      "Text": " ID of the remote object it just asked for. But if we send the second RA quickly before the"
    },
    {
      "Time_Start": 2213.1000000000004,
      "Time_End": 2218.1000000000004,
      "Text": " resolver sends the object ID back, the RA DVD can only mark the old DNS remote object as"
    },
    {
      "Time_Start": 2222.84,
      "Time_End": 2227.84,
      "Text": " destroyed. Then keep going to cre- create the DNS remote object for the RDNSS in the second RA."
    },
    {
      "Time_Start": 2232.7200000000003,
      "Time_End": 2238.82,
      "Text": " Then we'll send a request to the resolver but- but as I say, we send the second RA too quickly."
    },
    {
      "Time_Start": 2238.84,
      "Time_End": 2243.84,
      "Text": " The resolver is still in the first loop which try to send the object ID it created in the first"
    },
    {
      "Time_Start": 2246.7400000000002,
      "Time_End": 2251.7400000000002,
      "Text": " loop. So our request will stay in the socket. Now the resolver send the object ID back. The"
    },
    {
      "Time_Start": 2254.82,
      "Time_End": 2261.42,
      "Text": " response handler uh is a callback re- registered by the first request. We'll handle the"
    },
    {
      "Time_Start": 2261.42,
      "Time_End": 2266.42,
      "Text": " response. The handler finds out the object has already been marked as soft delete. So the"
    },
    {
      "Time_Start": 2269.4,
      "Time_End": 2274.4,
      "Text": " it won't update the object ID. Instead it will post another request to the resolver to delete that"
    },
    {
      "Time_Start": 2277.1000000000004,
      "Time_End": 2282.1000000000004,
      "Text": " object. The request will- will be processed in the third loop of the resolver after the request"
    },
    {
      "Time_Start": 2285.5800000000004,
      "Time_End": 2290.5800000000004,
      "Text": " of creating the DNS remote object for the second RA. In the second loop of the resolver, it"
    },
    {
      "Time_Start": 2291.52,
      "Time_End": 2296.52,
      "Text": " processes the creation request with the DNS address from the second RA and the response with"
    },
    {
      "Time_Start": 2301.66,
      "Time_End": 2306.66,
      "Text": " object ID. Now time's up. The timer of the resolver think a group of 18 operations should have"
    },
    {
      "Time_Start": 2310.2599999999998,
      "Time_End": 2315.2599999999998,
      "Text": " been done and it's time to notify everyone what DNS addresses it has. And because the handler 1"
    },
    {
      "Time_Start": 2315.6200000000003,
      "Time_End": 2320.6200000000003,
      "Text": " of RA-DVD subscribes to the handler 2 of the resolvers, it receive the DNS addresses in the"
    },
    {
      "Time_Start": 2325.26,
      "Time_End": 2330.26,
      "Text": " normal message. Then store them as a tree and use them to construct the RA for then in the RA"
    },
    {
      "Time_Start": 2333.1400000000003,
      "Time_End": 2338.1400000000003,
      "Text": " routine. At the moment the result of 2 requests is missing. That's why our first version of"
    },
    {
      "Time_Start": 2339.14,
      "Time_End": 2344.14,
      "Text": " the exploit can only work on Mac OS because we trigger the REST condition. It seems hard to"
    },
    {
      "Time_Start": 2348.54,
      "Time_End": 2353.54,
      "Text": " achieve a REST condition because there is a timer. But the mechanism is actually more complex"
    },
    {
      "Time_Start": 2356.22,
      "Time_End": 2361.22,
      "Text": " than I just explained. So the REST would always happen as long as the 2 RAs arrive at the"
    },
    {
      "Time_Start": 2361.78,
      "Time_End": 2366.78,
      "Text": " router in the short period. So the pattern of the REST condition in a remote object is as"
    },
    {
      "Time_Start": 2370.7200000000003,
      "Time_End": 2375.7200000000003,
      "Text": " follows. Use non-blocking method to create delete remote object and the target process"
    },
    {
      "Time_Start": 2378.0000000000005,
      "Time_End": 2383.0000000000005,
      "Text": " subscribes to the remote object. Then we can mix the result of 2 requests into 1. They may make"
    },
    {
      "Time_Start": 2383.16,
      "Time_End": 2388.16,
      "Text": " us bypass some checks in the binary. We try to find other vulnerability with this pattern so"
    },
    {
      "Time_Start": 2396.44,
      "Time_End": 2401.44,
      "Text": " that we can, so that we could register the LAN category of the router in Pwn2Own. But we ran"
    },
    {
      "Time_Start": 2405.44,
      "Time_End": 2410.62,
      "Text": " out of time and did not manage to find other vulnerability to exploit the LAN side of the"
    },
    {
      "Time_Start": 2410.64,
      "Time_End": 2416.68,
      "Text": " router OS. But at least we are the first team to exploit the Soho Smashup category"
    },
    {
      "Time_Start": 2416.68,
      "Time_End": 2421.68,
      "Text": " successfully and also won the title of Master of Pwn. Okay, in summary, MicroTik re-implement"
    },
    {
      "Time_Start": 2424.7599999999998,
      "Time_End": 2429.7599999999998,
      "Text": " everything with its own design IPC. The business logic is scattered all over. We have to have"
    },
    {
      "Time_Start": 2433.46,
      "Time_End": 2438.46,
      "Text": " an abstract concept of NOVA binary to find the most critical code to reverse it. And the"
    },
    {
      "Time_Start": 2439.34,
      "Time_End": 2444.34,
      "Text": " latest pre-auth RCE on WAN that has existed for 9 years. Also, we introduce a pattern of"
    },
    {
      "Time_Start": 2448.7200000000003,
      "Time_End": 2453.7200000000003,
      "Text": " REST condition in remote object due to non-blocking method to you. And the last thing, we'll drop"
    },
    {
      "Time_Start": 2455.7,
      "Time_End": 2460.7,
      "Text": " tools that we use in the Pwn2Own event to ease the reversing of router OS at GitHub. And"
    },
    {
      "Time_Start": 2460.7000000000003,
      "Time_End": 2465.7400000000002,
      "Text": " that's it. Any question?"
    }
  ]
}