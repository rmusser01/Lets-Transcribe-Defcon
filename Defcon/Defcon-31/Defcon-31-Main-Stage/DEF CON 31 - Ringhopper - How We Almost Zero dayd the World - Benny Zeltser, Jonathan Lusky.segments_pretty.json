{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 15.08,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Good morning, DEF CON. How's everyone doing? Right. So hope you got a good night's sleep"
    },
    {
      "Time_Start": 15.08,
      "Time_End": 21.46,
      "Text": " because today we'll embark on a journey. A journey into the realm of Ring Hopper. But"
    },
    {
      "Time_Start": 21.46,
      "Time_End": 28.28,
      "Text": " first we'll tell you the story of how we almost zero-dayed the world. So usually a timeline"
    },
    {
      "Time_Start": 28.28,
      "Time_End": 34.28,
      "Text": " is presented towards the end of the talk, but we'll make an exception. It all started"
    },
    {
      "Time_Start": 34.28,
      "Time_End": 41.86,
      "Text": " on June 1st, 2021, when we initially reported the findings we'll be talking about today."
    },
    {
      "Time_Start": 41.86,
      "Time_End": 49.040000000000006,
      "Text": " On January 19th, 2022, CERT-CC started working on the coordinated disclosure. We'll soon"
    },
    {
      "Time_Start": 49.040000000000006,
      "Time_End": 54.68000000000001,
      "Text": " see why this disclosure had to be coordinated. By the way, I'd like to use this stage to"
    },
    {
      "Time_Start": 54.68,
      "Time_End": 61.82,
      "Text": " send a big shout-out to VGI and the folks for mastering the challenging disclosure."
    },
    {
      "Time_Start": 61.82,
      "Time_End": 66.44,
      "Text": " Right about now, a year ago, we should have presented our findings in the Black Hat and"
    },
    {
      "Time_Start": 66.44,
      "Time_End": 72.14,
      "Text": " DEF CON conferences, but unfortunately we were notified that the issues will not be"
    },
    {
      "Time_Start": 72.14,
      "Time_End": 80.24000000000001,
      "Text": " fixed in time. So we had to withdraw our talks. But we did it rather close to the conferences"
    },
    {
      "Time_Start": 81.24,
      "Time_End": 87.11999999999999,
      "Text": " themselves, so our abstract was still printed in the booklet, in DEF CON's booklet, which"
    },
    {
      "Time_Start": 87.11999999999999,
      "Time_End": 92.94,
      "Text": " might have caused some confusion. By the way, from the bottom of our hearts, we appreciate"
    },
    {
      "Time_Start": 92.94,
      "Time_End": 99.14,
      "Text": " the concern. Fast forward to November 8th, 2022, when the"
    },
    {
      "Time_Start": 99.14,
      "Time_End": 106.14,
      "Text": " last embargo set by CERT-CC has expired. And a note was published, which cleared pretty"
    },
    {
      "Time_Start": 107.14,
      "Time_End": 113.14,
      "Text": " much everything up. And now that we're out of the all-day danger zone, where we couldn't"
    },
    {
      "Time_Start": 113.14,
      "Time_End": 119.14,
      "Text": " talk about our findings, let's dive in. So at the beginning, there were four privilege"
    },
    {
      "Time_Start": 119.14,
      "Time_End": 125.14,
      "Text": " rings. The most notable are the user mode, user land, user space, ring three, it goes"
    },
    {
      "Time_Start": 125.14,
      "Time_End": 131.14,
      "Text": " by many names, and the kernel. The lower the number of the ring, the more privileges it"
    },
    {
      "Time_Start": 132.14000000000001,
      "Time_End": 138.14000000000001,
      "Text": " has, and it works in a manner that is opaque to all the rings above it. For instance, the"
    },
    {
      "Time_Start": 138.14000000000001,
      "Time_End": 146.14000000000001,
      "Text": " user mode has no notion whatsoever of what's going on the kernel. Over the years, new additional"
    },
    {
      "Time_Start": 146.14000000000001,
      "Time_End": 152.14000000000001,
      "Text": " rings were introduced, for instance, the VMM, ring minus one is usually where your hypervisor"
    },
    {
      "Time_Start": 152.14000000000001,
      "Time_End": 160.14000000000001,
      "Text": " runs, and SMM, ring minus two. So let's talk about SMM. It started, it stands for system"
    },
    {
      "Time_Start": 160.14000000000001,
      "Time_End": 165.14000000000001,
      "Text": " management mode, and it started as a small and humble processor operating mode that mostly"
    },
    {
      "Time_Start": 165.14000000000001,
      "Time_End": 171.14000000000001,
      "Text": " provided low-level system functionalities such as power management, system hardware"
    },
    {
      "Time_Start": 171.14000000000001,
      "Time_End": 178.14000000000001,
      "Text": " control, and OEMs ran their proprietary device-specific code there. Over the years, SMM got"
    },
    {
      "Time_Start": 178.14000000000001,
      "Time_End": 184.14000000000001,
      "Text": " bigger and bigger and turned into a huge monstrosity that performed all kinds of operations."
    },
    {
      "Time_Start": 184.14000000000001,
      "Time_End": 191.14000000000001,
      "Text": " For instance, it exposed and exposes an interface to the SM BIOS, does PS2 mouse keyboard"
    },
    {
      "Time_Start": 191.14000000000001,
      "Time_End": 198.14000000000001,
      "Text": " emulation, handles USB events and boot and run time, and the list is long. Together with"
    },
    {
      "Time_Start": 198.14000000000001,
      "Time_End": 205.14000000000001,
      "Text": " SMM grew the attack surface, and it has become so much more interesting for the attacker."
    },
    {
      "Time_Start": 205.14000000000001,
      "Time_End": 213.14000000000001,
      "Text": " But this is fine, because numerous registers and MSRs, along with some pretty awesome"
    },
    {
      "Time_Start": 213.14000000000001,
      "Time_End": 220.14000000000001,
      "Text": " mitigations, were created with the sole purpose to keep SMM safe."
    },
    {
      "Time_Start": 220.14000000000001,
      "Time_End": 225.14000000000001,
      "Text": " So in order to switch to SMM, the kernel has to trigger a special kind of interrupt called"
    },
    {
      "Time_Start": 225.14000000000001,
      "Time_End": 232.14000000000001,
      "Text": " system management interrupt, or SMI for short. Once an SMI is triggered, the processor switches"
    },
    {
      "Time_Start": 232.14000000000001,
      "Time_End": 238.14000000000001,
      "Text": " to running SMM, and the kernel is no longer active, and just like with any other interrupt,"
    },
    {
      "Time_Start": 238.14000000000001,
      "Time_End": 244.14000000000001,
      "Text": " there is an interrupt handler that corresponds to the interrupt number that was triggered,"
    },
    {
      "Time_Start": 244.14000000000001,
      "Time_End": 251.14000000000001,
      "Text": " and in our case, it's aptly named the SMI handler. Once the SMI handler is done running,"
    },
    {
      "Time_Start": 251.14000000000001,
      "Time_End": 257.14,
      "Text": " the processor switches back to running the kernel, and the SMM is no longer active."
    },
    {
      "Time_Start": 257.14,
      "Time_End": 265.14,
      "Text": " The SMM resides in a special well-guarded portion of the RAM called SM RAM, system management"
    },
    {
      "Time_Start": 265.14,
      "Time_End": 271.14,
      "Text": " RAM, while all the other entities have no access to the SM RAM whatsoever. For instance,"
    },
    {
      "Time_Start": 271.14,
      "Time_End": 278.14,
      "Text": " if the kernel tries to read from the SM RAM, it will get a bunch of FFs."
    },
    {
      "Time_Start": 278.14,
      "Time_End": 285.14,
      "Text": " Overall, it looks like a worthy target, right? So in our research, we started with an agent"
    },
    {
      "Time_Start": 285.14,
      "Time_End": 293.14,
      "Text": " running in user mode, escalated to the kernel, and from there, we hopped to the SMM."
    },
    {
      "Time_Start": 293.14,
      "Time_End": 301.14,
      "Text": " And we did all that on this Intel NUC. But as we'll see later on, our research goes way beyond"
    },
    {
      "Time_Start": 301.14,
      "Time_End": 305.14,
      "Text": " this recently discontinued little fella."
    },
    {
      "Time_Start": 305.14,
      "Time_End": 311.14,
      "Text": " So this is a good time to dive into our findings, but before we do so, we need to understand"
    },
    {
      "Time_Start": 311.14,
      "Time_End": 316.14,
      "Text": " what is a time-of-check time-of-use vulnerability in SMM context. So let's say we have an SMI"
    },
    {
      "Time_Start": 316.14,
      "Time_End": 323.14,
      "Text": " handler that provides the awesome service of overriding a buffer with the value of coffee."
    },
    {
      "Time_Start": 323.14,
      "Time_End": 328.14,
      "Text": " Since we are SMM, we do not trust the operating system, so the first thing we have to do is"
    },
    {
      "Time_Start": 328.14,
      "Time_End": 333.14,
      "Text": " to validate the input and basically make sure that the output buffer points to a valid location."
    },
    {
      "Time_Start": 333.14,
      "Time_End": 339.14,
      "Text": " This will be the time-of-check. Then, once it was validated, we can use it and override"
    },
    {
      "Time_Start": 339.14,
      "Time_End": 343.14,
      "Text": " its content with the value of coffee. This will be the time-of-use."
    },
    {
      "Time_Start": 343.14,
      "Time_End": 349.14,
      "Text": " If an attacker can modify this output buffer, the pointer, to lead to another location"
    },
    {
      "Time_Start": 349.14,
      "Time_End": 354.14,
      "Text": " in between the time-of-check and the time-of-use, it will basically gain a right primitive"
    },
    {
      "Time_Start": 354.14,
      "Time_End": 359.14,
      "Text": " of the value coffee. So let's see how it works in SMM context."
    },
    {
      "Time_Start": 359.14,
      "Time_End": 365.14,
      "Text": " So in the normal scenario, we have an input buffer which would lead to an OS-owned memory"
    },
    {
      "Time_Start": 365.14,
      "Time_End": 370.14,
      "Text": " and the SMI handler will simply override the content of it with the value of coffee."
    },
    {
      "Time_Start": 371.14,
      "Time_End": 377.14,
      "Text": " However, an attacker may try to modify this output buffer to lead to the SMRAM in between"
    },
    {
      "Time_Start": 377.14,
      "Time_End": 382.14,
      "Text": " the time-of-check and time-of-use, and by doing so, gain a right primitive of the value"
    },
    {
      "Time_Start": 382.14,
      "Time_End": 388.14,
      "Text": " coffee to the SMRAM. By the way, this is exactly what a validation function does."
    },
    {
      "Time_Start": 388.14,
      "Time_End": 393.14,
      "Text": " It makes sure that the output buffer is not located inside the SMRAM."
    },
    {
      "Time_Start": 393.14,
      "Time_End": 396.14,
      "Text": " So let's discuss how we exploit such an issue."
    },
    {
      "Time_Start": 397.14,
      "Time_End": 401.14,
      "Text": " In a classic time-of-check, time-of-use exploitation, it will work as follows."
    },
    {
      "Time_Start": 401.14,
      "Time_End": 405.14,
      "Text": " Let's say we have a system with four different cores, and let's assume that the first core"
    },
    {
      "Time_Start": 405.14,
      "Time_End": 410.14,
      "Text": " does the critical SMI handling. It does the validation and usage steps."
    },
    {
      "Time_Start": 410.14,
      "Time_End": 414.14,
      "Text": " So between the other cores, we will try to corrupt the data. Sometimes we may do this"
    },
    {
      "Time_Start": 414.14,
      "Time_End": 419.14,
      "Text": " before the validation, and if so, it will simply not pass the validation phase."
    },
    {
      "Time_Start": 419.14,
      "Time_End": 423.14,
      "Text": " Sometimes after the usage, and in such scenario, nothing would happen."
    },
    {
      "Time_Start": 423.14,
      "Time_End": 428.14,
      "Text": " But eventually, with some luck, we may corrupt the data exactly in between the validation"
    },
    {
      "Time_Start": 428.14,
      "Time_End": 431.14,
      "Text": " and usage, and exploit this issue."
    },
    {
      "Time_Start": 431.14,
      "Time_End": 436.14,
      "Text": " However, when an SMI is triggered, all the other cores are going idle, and we cannot"
    },
    {
      "Time_Start": 436.14,
      "Time_End": 440.14,
      "Text": " use them to corrupt the data. So how did we do that?"
    },
    {
      "Time_Start": 440.14,
      "Time_End": 445.14,
      "Text": " The answer was DMA. DMA stands for direct memory access, and this is the way for your"
    },
    {
      "Time_Start": 445.14,
      "Time_End": 449.14,
      "Text": " peripheral devices to talk with the CPU, the operating system."
    },
    {
      "Time_Start": 450.14,
      "Time_End": 458.14,
      "Text": " And in precise, those devices could be your Ethernet adapter, or your graphics card, and etc."
    },
    {
      "Time_Start": 458.14,
      "Time_End": 462.14,
      "Text": " So to test this hypothesis, we took something that is called PCILH."
    },
    {
      "Time_Start": 462.14,
      "Time_End": 467.14,
      "Text": " It's a cool tool by Ulf Rysk. This is the small red FPGA device that you see here, which"
    },
    {
      "Time_Start": 467.14,
      "Time_End": 473.14,
      "Text": " is connected through the M2 bus, and basically it allows you to initiate arbitrary read and"
    },
    {
      "Time_Start": 473.14,
      "Time_End": 476.14,
      "Text": " write DMA transactions to the RAM."
    },
    {
      "Time_Start": 476.14,
      "Time_End": 481.14,
      "Text": " And using it, we were actually able to exploit this time check time fuse issue, which was"
    },
    {
      "Time_Start": 481.14,
      "Time_End": 485.14,
      "Text": " amazing, but as some of you may say, it's not good enough."
    },
    {
      "Time_Start": 485.14,
      "Time_End": 487.14,
      "Text": " It requires physical access, right?"
    },
    {
      "Time_Start": 487.14,
      "Time_End": 494.14,
      "Text": " And it could be considered only as an evil maid attack, or supply chain attack at best."
    },
    {
      "Time_Start": 494.14,
      "Time_End": 498.14,
      "Text": " And we thought so as well, and we wanted to make things even more powerful."
    },
    {
      "Time_Start": 498.14,
      "Time_End": 501.14,
      "Text": " We wanted to operate them remotely."
    },
    {
      "Time_Start": 501.14,
      "Time_End": 505.14,
      "Text": " So to do that, we utilized something that exists on any platform."
    },
    {
      "Time_Start": 505.14,
      "Time_End": 511.14,
      "Text": " We utilized a storage device, and we did it using a cool technique by Rafal that was presented"
    },
    {
      "Time_Start": 511.14,
      "Time_End": 516.14,
      "Text": " a couple of years ago, which allows you to generate DMA transactions using a storage device."
    },
    {
      "Time_Start": 516.14,
      "Time_End": 519.14,
      "Text": " So let's see how it works now."
    },
    {
      "Time_Start": 519.14,
      "Time_End": 521.14,
      "Text": " Remember the previous diagram?"
    },
    {
      "Time_Start": 521.14,
      "Time_End": 523.14,
      "Text": " Now we add another component into the equation."
    },
    {
      "Time_Start": 523.14,
      "Time_End": 527.14,
      "Text": " We add your storage device, and on top of it, we place a malicious file which contains"
    },
    {
      "Time_Start": 527.14,
      "Time_End": 530.14,
      "Text": " our payload, or basically the modified address."
    },
    {
      "Time_Start": 530.14,
      "Time_End": 535.14,
      "Text": " So once again, we will start by generating a DMA request."
    },
    {
      "Time_Start": 535.14,
      "Time_End": 540.14,
      "Text": " Due to the asynchronous nature of the storage device, it will take it some time to process"
    },
    {
      "Time_Start": 540.14,
      "Time_End": 541.14,
      "Text": " the request."
    },
    {
      "Time_Start": 541.14,
      "Time_End": 548.14,
      "Text": " Then we will also hook this request such that it will be redirected back to the input buffer,"
    },
    {
      "Time_Start": 548.14,
      "Time_End": 551.14,
      "Text": " and we will trigger an SMI."
    },
    {
      "Time_Start": 551.14,
      "Time_End": 555.14,
      "Text": " Once we trigger an SMI, all the cores are going idle."
    },
    {
      "Time_Start": 555.14,
      "Time_End": 556.14,
      "Text": " Remember?"
    },
    {
      "Time_Start": 557.14,
      "Time_End": 563.14,
      "Text": " Then eventually, the SMI handler will enter the critical validation and usage steps, and"
    },
    {
      "Time_Start": 563.14,
      "Time_End": 568.14,
      "Text": " with some luck, the data or the file will be returned exactly in between the validation"
    },
    {
      "Time_Start": 568.14,
      "Time_End": 574.14,
      "Text": " and usage, and will allow us to exploit this time-of-check, time-of-fuse issue."
    },
    {
      "Time_Start": 574.14,
      "Time_End": 578.14,
      "Text": " Okay, so we talked a lot, and it's probably a good time for a recap."
    },
    {
      "Time_Start": 578.14,
      "Time_End": 583.14,
      "Text": " So we discussed what is SMM and how we can communicate with it."
    },
    {
      "Time_Start": 583.14,
      "Time_End": 587.14,
      "Text": " We also discussed how we can turn those time-of-check, time-of-fuse issues into write primitives to"
    },
    {
      "Time_Start": 587.14,
      "Time_End": 593.14,
      "Text": " the SMRAM, and we also discussed how to manipulate DMA transactions to exploit exactly those"
    },
    {
      "Time_Start": 593.14,
      "Time_End": 596.14,
      "Text": " time-of-check, time-of-fuse issues."
    },
    {
      "Time_Start": 596.14,
      "Time_End": 599.14,
      "Text": " And we also discussed how to execute code inside SMM."
    },
    {
      "Time_Start": 599.14,
      "Time_End": 602.14,
      "Text": " Oh, well, not exactly."
    },
    {
      "Time_Start": 602.14,
      "Time_End": 607.14,
      "Text": " So, yeah, we don't currently have the ability to execute code in SMM, but we have something"
    },
    {
      "Time_Start": 607.14,
      "Time_End": 608.14,
      "Text": " pretty powerful."
    },
    {
      "Time_Start": 608.14,
      "Time_End": 610.14,
      "Text": " We have a write primitive to the SMRAM."
    },
    {
      "Time_Start": 610.14,
      "Time_End": 613.14,
      "Text": " So let's put that to some good use."
    },
    {
      "Time_Start": 613.14,
      "Time_End": 619.14,
      "Text": " One of the modules we analyzed was the SMBIOS DMA edit Dixie driver, and our analysis was"
    },
    {
      "Time_Start": 619.14,
      "Time_End": 620.14,
      "Text": " not in vain."
    },
    {
      "Time_Start": 620.14,
      "Time_End": 625.14,
      "Text": " It bore fruits in the image of potential write primitives."
    },
    {
      "Time_Start": 625.14,
      "Time_End": 631.14,
      "Text": " It's worth noting that this list is not exhaustive, and it's far from being the only vulnerable"
    },
    {
      "Time_Start": 631.14,
      "Time_End": 633.14,
      "Text": " module."
    },
    {
      "Time_Start": 633.14,
      "Time_End": 637.14,
      "Text": " However, with a bunch of write primitives in a classic scenario, you would probably"
    },
    {
      "Time_Start": 638.14,
      "Time_End": 641.14,
      "Text": " try to find an executable memory region, right?"
    },
    {
      "Time_Start": 641.14,
      "Time_End": 645.14,
      "Text": " And we thought that it would apply to SMM as well."
    },
    {
      "Time_Start": 645.14,
      "Time_End": 654.14,
      "Text": " But as we discovered, SMM has a paging mechanism of its own, where all pages containing code"
    },
    {
      "Time_Start": 654.14,
      "Time_End": 659.14,
      "Text": " are read-only, and all pages containing data are non-executable."
    },
    {
      "Time_Start": 659.14,
      "Time_End": 665.14,
      "Text": " Then you would probably try to forge some arbitrary payload out of your write primitives."
    },
    {
      "Time_Start": 666.14,
      "Time_End": 671.14,
      "Text": " And even though we have quite a few of them, their variety and number does not let us craft"
    },
    {
      "Time_Start": 671.14,
      "Time_End": 673.14,
      "Text": " anything decent."
    },
    {
      "Time_Start": 673.14,
      "Time_End": 677.14,
      "Text": " And lastly, you would strive to get unrestricted memory access."
    },
    {
      "Time_Start": 677.14,
      "Time_End": 685.14,
      "Text": " And here, once again, the paging mechanism in the SMM hinders our exploitation."
    },
    {
      "Time_Start": 685.14,
      "Time_End": 692.14,
      "Text": " So for starters, most of the non-SMRAM RAM is simply not mapped to the page table."
    },
    {
      "Time_Start": 692.14,
      "Time_End": 698.14,
      "Text": " And if that's not annoying enough, and it's annoying, the page table resides in read-only"
    },
    {
      "Time_Start": 698.14,
      "Time_End": 704.14,
      "Text": " pages, meaning no new pages can be allocated, and all attributes are permanent."
    },
    {
      "Time_Start": 704.14,
      "Time_End": 709.14,
      "Text": " Meaning that if we do manage to execute code in SMM, it would be pretty hard."
    },
    {
      "Time_Start": 709.14,
      "Time_End": 716.14,
      "Text": " Not impossible, but pretty hard to do something, for instance, to the OS."
    },
    {
      "Time_Start": 716.14,
      "Time_End": 724.14,
      "Text": " So as you all probably agree, I hope by now, the classic approach might not be very applicable here."
    },
    {
      "Time_Start": 724.14,
      "Time_End": 732.14,
      "Text": " So let's try to think out of the box and leverage some mechanisms that are unique and internal to SMM."
    },
    {
      "Time_Start": 734.14,
      "Time_End": 741.14,
      "Text": " So at this point, Jonathan and I turned to reading some works from the past."
    },
    {
      "Time_Start": 741.14,
      "Time_End": 749.14,
      "Text": " And one of the works we found was by Raphael Washtuk and Corey Kallenberg from 2015, where they write,"
    },
    {
      "Time_Start": 749.14,
      "Time_End": 756.14,
      "Text": " by forcing S3 suspend-resume cycle, an attacker can run an arbitrary code and take control over SMM."
    },
    {
      "Time_Start": 756.14,
      "Time_End": 762.14,
      "Text": " Sounds promising, right? But what's S3 suspend-resume, and what is S3?"
    },
    {
      "Time_Start": 762.14,
      "Time_End": 768.14,
      "Text": " So, well, S3 is a sleep state where the CPU is idle, but the memory keeps on working."
    },
    {
      "Time_Start": 768.14,
      "Time_End": 773.14,
      "Text": " And simply put, when you put your machine to sleep, it usually enters S3."
    },
    {
      "Time_Start": 773.14,
      "Time_End": 777.14,
      "Text": " Let's continue with some more background."
    },
    {
      "Time_Start": 777.14,
      "Time_End": 782.14,
      "Text": " So a normal boot process is rather time-consuming."
    },
    {
      "Time_Start": 782.14,
      "Time_End": 789.14,
      "Text": " But when we come back from S3, some of this process can be skipped because, well, the machine has already booted once."
    },
    {
      "Time_Start": 789.14,
      "Time_End": 794.14,
      "Text": " However, some configuration still needs to be restored."
    },
    {
      "Time_Start": 794.14,
      "Time_End": 798.14,
      "Text": " And here the S3 boot script comes to our aid."
    },
    {
      "Time_Start": 798.14,
      "Time_End": 804.14,
      "Text": " During the normal boot, the configuration of the platform is encoded into the S3 boot script."
    },
    {
      "Time_Start": 804.14,
      "Time_End": 818.14,
      "Text": " And then when the machine wakes up, the code boot engine simply executes the script and restores the configuration."
    },
    {
      "Time_Start": 818.14,
      "Time_End": 827.14,
      "Text": " And this boot script consists of rather primitive opcodes like reading, writing to IO, to memory, to PCI, etc."
    },
    {
      "Time_Start": 827.14,
      "Time_End": 829.14,
      "Text": " And here's the interesting bit."
    },
    {
      "Time_Start": 829.14,
      "Time_End": 834.14,
      "Text": " Previously, it was stored in a location that was accessible to the OS,"
    },
    {
      "Time_Start": 834.14,
      "Time_End": 841.14,
      "Text": " which is exactly the fact that the paper we saw earlier abuses."
    },
    {
      "Time_Start": 841.14,
      "Time_End": 846.14,
      "Text": " They modified the boot script from the kernel, put the machine to sleep, woke it up."
    },
    {
      "Time_Start": 846.14,
      "Time_End": 854.14,
      "Text": " At this point, their malicious S3 boot script was executed, and eventually they ran code in SMM."
    },
    {
      "Time_Start": 854.14,
      "Time_End": 863.14,
      "Text": " So as you could probably guess, this paper was from 2015, so it's already mitigated."
    },
    {
      "Time_Start": 863.14,
      "Time_End": 869.14,
      "Text": " And nowadays, the S3 boot script resides in a container aptly named Logbox."
    },
    {
      "Time_Start": 869.14,
      "Time_End": 875.14,
      "Text": " And the Logbox is a data structure that provides integrity of the data."
    },
    {
      "Time_Start": 875.14,
      "Time_End": 881.14,
      "Text": " It is located in the SMRAM, has a pretty standard implementation,"
    },
    {
      "Time_Start": 881.14,
      "Time_End": 887.14,
      "Text": " and there is a rather convenient API for reading, writing, and updating it from ring zero."
    },
    {
      "Time_Start": 887.14,
      "Time_End": 890.14,
      "Text": " So let's have a look at the update procedure."
    },
    {
      "Time_Start": 890.14,
      "Time_End": 895.14,
      "Text": " So here we see the function that updates the Logbox,"
    },
    {
      "Time_Start": 895.14,
      "Time_End": 901.14,
      "Text": " and it either returns access denied error or some internal status."
    },
    {
      "Time_Start": 902.14,
      "Time_End": 906.14,
      "Text": " The only way we do not get access denied, and, well, we don't want to get access denied,"
    },
    {
      "Time_Start": 906.14,
      "Time_End": 911.14,
      "Text": " is if the mLogged global variable is not set,"
    },
    {
      "Time_Start": 911.14,
      "Time_End": 920.14,
      "Text": " which is kind of a nice way of preventing the kernel from updating the Logbox."
    },
    {
      "Time_Start": 920.14,
      "Time_End": 926.14,
      "Text": " And this global variable unconveniently resides in the SMRAM,"
    },
    {
      "Time_Start": 926.14,
      "Time_End": 929.14,
      "Text": " but, hey, we have a right primitive there, right?"
    },
    {
      "Time_Start": 929.14,
      "Time_End": 937.14,
      "Text": " So let's utilize all the information we got and try to execute unauthorized code in XMM."
    },
    {
      "Time_Start": 937.14,
      "Time_End": 939.14,
      "Text": " So the plan is as follows."
    },
    {
      "Time_Start": 939.14,
      "Time_End": 943.14,
      "Text": " We use our right primitive to zero out the mLogged global variable."
    },
    {
      "Time_Start": 943.14,
      "Time_End": 948.14,
      "Text": " Then we invoke the update procedure of the Logbox,"
    },
    {
      "Time_Start": 948.14,
      "Time_End": 953.14,
      "Text": " and by that modify the S3 boot script with our malicious version of it."
    },
    {
      "Time_Start": 953.14,
      "Time_End": 957.14,
      "Text": " We put the machine to sleep, wake it up,"
    },
    {
      "Time_Start": 957.14,
      "Time_End": 961.14,
      "Text": " and at this point the S3 boot script will be executed"
    },
    {
      "Time_Start": 961.14,
      "Time_End": 964.14,
      "Text": " and will be eventually running code in SMM."
    },
    {
      "Time_Start": 964.14,
      "Time_End": 970.14,
      "Text": " So it's a great idea, but it doesn't really work"
    },
    {
      "Time_Start": 970.14,
      "Time_End": 977.14,
      "Text": " because right after the machine wakes up and just before the S3 boot script is executed,"
    },
    {
      "Time_Start": 977.14,
      "Time_End": 982.14,
      "Text": " the code will close and lock SMRAM and only then jump to the boot script,"
    },
    {
      "Time_Start": 982.14,
      "Time_End": 987.14,
      "Text": " meaning that even though we managed to execute code,"
    },
    {
      "Time_Start": 987.14,
      "Time_End": 994.14,
      "Text": " rather privileged code, at rather early stages of S3 resume,"
    },
    {
      "Time_Start": 994.14,
      "Time_End": 1001.14,
      "Text": " the SMRAM is locked and most of the RAM is simply not mapped to the page table."
    },
    {
      "Time_Start": 1001.14,
      "Time_End": 1004.14,
      "Text": " Yeah, we should have read that documentation."
    },
    {
      "Time_Start": 1004.14,
      "Time_End": 1009.14,
      "Text": " All right, so our quest continues, and let's take another attempt."
    },
    {
      "Time_Start": 1009.14,
      "Time_End": 1015.14,
      "Text": " And let's take another attempt where we emerge victorious."
    },
    {
      "Time_Start": 1015.14,
      "Time_End": 1018.14,
      "Text": " But as usual, some background."
    },
    {
      "Time_Start": 1018.14,
      "Time_End": 1022.14,
      "Text": " So each core has its own region of the SMRAM"
    },
    {
      "Time_Start": 1022.14,
      "Time_End": 1026.1399999999999,
      "Text": " pointed to by the SMBase MSR model-specific register."
    },
    {
      "Time_Start": 1026.1399999999999,
      "Time_End": 1029.1399999999999,
      "Text": " Each core has an MSR of its own."
    },
    {
      "Time_Start": 1029.1399999999999,
      "Time_End": 1032.1399999999999,
      "Text": " Each of these regions contains a lot of interesting things,"
    },
    {
      "Time_Start": 1032.1399999999999,
      "Time_End": 1034.1399999999999,
      "Text": " but we'll be focusing on two."
    },
    {
      "Time_Start": 1034.14,
      "Time_End": 1036.14,
      "Text": " The SMI handler entry point,"
    },
    {
      "Time_Start": 1036.14,
      "Time_End": 1040.14,
      "Text": " which is the first code that will be executed upon entering SMM,"
    },
    {
      "Time_Start": 1040.14,
      "Time_End": 1044.14,
      "Text": " and the save state, which contains, among other things,"
    },
    {
      "Time_Start": 1044.14,
      "Time_End": 1048.14,
      "Text": " the value of the SMBase MSR."
    },
    {
      "Time_Start": 1048.14,
      "Time_End": 1052.14,
      "Text": " And as a matter of fact, the proper way to modify the SMBase MSR"
    },
    {
      "Time_Start": 1052.14,
      "Time_End": 1056.14,
      "Text": " is by changing its value in the save state."
    },
    {
      "Time_Start": 1056.14,
      "Time_End": 1059.14,
      "Text": " And this whole operation is pretty special."
    },
    {
      "Time_Start": 1059.14,
      "Time_End": 1061.14,
      "Text": " How special is it, you might wonder."
    },
    {
      "Time_Start": 1061.14,
      "Time_End": 1065.14,
      "Text": " It's so special that it has a name, SMBase Relocation."
    },
    {
      "Time_Start": 1065.14,
      "Time_End": 1067.14,
      "Text": " From a developer's point of view,"
    },
    {
      "Time_Start": 1067.14,
      "Time_End": 1070.14,
      "Text": " SMBase Relocation is pretty straightforward."
    },
    {
      "Time_Start": 1070.14,
      "Time_End": 1075.14,
      "Text": " They modify the SMBase value in the save state,"
    },
    {
      "Time_Start": 1075.14,
      "Time_End": 1080.14,
      "Text": " and some magic behind the scene relocates the whole region"
    },
    {
      "Time_Start": 1080.14,
      "Time_End": 1083.14,
      "Text": " to the new address,"
    },
    {
      "Time_Start": 1083.14,
      "Time_End": 1086.14,
      "Text": " which leads to the following attack idea."
    },
    {
      "Time_Start": 1086.14,
      "Time_End": 1090.14,
      "Text": " So let's allocate some user-controlled memory"
    },
    {
      "Time_Start": 1090.14,
      "Time_End": 1094.14,
      "Text": " that is accessible to both kernel and SMM."
    },
    {
      "Time_Start": 1094.14,
      "Time_End": 1098.14,
      "Text": " There we'll craft our own SMI handler entry point,"
    },
    {
      "Time_Start": 1098.14,
      "Time_End": 1102.14,
      "Text": " the first code that will be executed upon entering SMM."
    },
    {
      "Time_Start": 1102.14,
      "Time_End": 1105.14,
      "Text": " And now we'll simply use our write primitive"
    },
    {
      "Time_Start": 1105.14,
      "Time_End": 1108.14,
      "Text": " to modify the SMBase value in the save state."
    },
    {
      "Time_Start": 1108.14,
      "Time_End": 1111.14,
      "Text": " This will trigger an SMBase relocation,"
    },
    {
      "Time_Start": 1111.14,
      "Time_End": 1115.14,
      "Text": " and eventually we'll execute code in SMM, right?"
    },
    {
      "Time_Start": 1115.14,
      "Time_End": 1118.14,
      "Text": " It's a great idea, but it doesn't work."
    },
    {
      "Time_Start": 1118.14,
      "Time_End": 1121.14,
      "Text": " It doesn't work at least out of the box,"
    },
    {
      "Time_Start": 1121.14,
      "Time_End": 1124.14,
      "Text": " and it doesn't work thanks to this MSR,"
    },
    {
      "Time_Start": 1124.14,
      "Time_End": 1128.14,
      "Text": " and in particular, the SMM code check enable bit."
    },
    {
      "Time_Start": 1128.14,
      "Time_End": 1133.14,
      "Text": " So when this bit is set and the machine is running in SMM,"
    },
    {
      "Time_Start": 1133.14,
      "Time_End": 1138.14,
      "Text": " if someone tries to execute code outside of SMRAM,"
    },
    {
      "Time_Start": 1138.14,
      "Time_End": 1140.14,
      "Text": " it will simply trigger an exception."
    },
    {
      "Time_Start": 1140.14,
      "Time_End": 1143.14,
      "Text": " You can think of it as some sort of a SMAP mechanism."
    },
    {
      "Time_Start": 1143.14,
      "Time_End": 1145.14,
      "Text": " But that's not all."
    },
    {
      "Time_Start": 1145.14,
      "Time_End": 1148.14,
      "Text": " There is a lock bit here that if set,"
    },
    {
      "Time_Start": 1148.14,
      "Time_End": 1152.14,
      "Text": " this MSR cannot be modified or changed in any way"
    },
    {
      "Time_Start": 1152.14,
      "Time_End": 1154.14,
      "Text": " until the next reboot."
    },
    {
      "Time_Start": 1154.14,
      "Time_End": 1156.14,
      "Text": " And, well, rebooting the machine"
    },
    {
      "Time_Start": 1156.14,
      "Time_End": 1159.14,
      "Text": " or cutting power to the CPU kind of defeats the purpose."
    },
    {
      "Time_Start": 1159.14,
      "Time_End": 1163.14,
      "Text": " So at this point, Jonathan and I sat and thought,"
    },
    {
      "Time_Start": 1163.14,
      "Time_End": 1167.14,
      "Text": " what could be the closest thing to rebooting the machine"
    },
    {
      "Time_Start": 1167.14,
      "Time_End": 1169.14,
      "Text": " without rebooting the machine?"
    },
    {
      "Time_Start": 1169.14,
      "Time_End": 1171.14,
      "Text": " And then it hit us."
    },
    {
      "Time_Start": 1171.14,
      "Time_End": 1173.14,
      "Text": " We'll just put the machine to sleep,"
    },
    {
      "Time_Start": 1173.14,
      "Time_End": 1175.14,
      "Text": " prior to S3 sleep."
    },
    {
      "Time_Start": 1175.14,
      "Time_End": 1179.14,
      "Text": " Recall that the S3 sleep state is a processor state"
    },
    {
      "Time_Start": 1179.14,
      "Time_End": 1183.14,
      "Text": " where the CPU is idle, but the memory keeps on working."
    },
    {
      "Time_Start": 1183.14,
      "Time_End": 1185.14,
      "Text": " And as the CPU loses power,"
    },
    {
      "Time_Start": 1185.14,
      "Time_End": 1188.14,
      "Text": " all of the entries stored on the CPU"
    },
    {
      "Time_Start": 1188.14,
      "Time_End": 1190.14,
      "Text": " are cleared when going into S3."
    },
    {
      "Time_Start": 1190.14,
      "Time_End": 1192.14,
      "Text": " So if you care about all these entries,"
    },
    {
      "Time_Start": 1192.14,
      "Time_End": 1195.14,
      "Text": " for instance, the MSR we just saw,"
    },
    {
      "Time_Start": 1195.14,
      "Time_End": 1200.14,
      "Text": " all the data should be copied to the memory"
    },
    {
      "Time_Start": 1200.14,
      "Time_End": 1202.14,
      "Text": " prior to entering S3."
    },
    {
      "Time_Start": 1202.14,
      "Time_End": 1204.14,
      "Text": " And after the machine wakes up,"
    },
    {
      "Time_Start": 1204.14,
      "Time_End": 1207.14,
      "Text": " it should be restored to the CPU."
    },
    {
      "Time_Start": 1207.14,
      "Time_End": 1209.14,
      "Text": " So let's have a look at our beloved"
    },
    {
      "Time_Start": 1209.14,
      "Time_End": 1212.14,
      "Text": " MSM code check enable bit."
    },
    {
      "Time_Start": 1212.14,
      "Time_End": 1215.14,
      "Text": " In normal execution, it is set."
    },
    {
      "Time_Start": 1215.14,
      "Time_End": 1218.14,
      "Text": " When going into S3, it is still set."
    },
    {
      "Time_Start": 1218.14,
      "Time_End": 1221.14,
      "Text": " When the machine wakes up and we come back from S3"
    },
    {
      "Time_Start": 1221.14,
      "Time_End": 1224.14,
      "Text": " as the CPU lost its power, it is cleared."
    },
    {
      "Time_Start": 1224.14,
      "Time_End": 1228.14,
      "Text": " And at the very early stage of the boot process,"
    },
    {
      "Time_Start": 1228.14,
      "Time_End": 1230.14,
      "Text": " there is some initialization code"
    },
    {
      "Time_Start": 1230.14,
      "Time_End": 1233.14,
      "Text": " that initializes this bit."
    },
    {
      "Time_Start": 1233.14,
      "Time_End": 1237.14,
      "Text": " So let's have a look at the initialization code."
    },
    {
      "Time_Start": 1237.14,
      "Time_End": 1242.14,
      "Text": " So clearly, we see the write MSR over here"
    },
    {
      "Time_Start": 1242.14,
      "Time_End": 1243.14,
      "Text": " with a certain value."
    },
    {
      "Time_Start": 1243.14,
      "Time_End": 1246.14,
      "Text": " You'd have to believe us that it comes from the memory."
    },
    {
      "Time_Start": 1246.14,
      "Time_End": 1249.14,
      "Text": " And here's the interesting bit."
    },
    {
      "Time_Start": 1249.14,
      "Time_End": 1252.14,
      "Text": " This write MSR happens only if the condition"
    },
    {
      "Time_Start": 1252.14,
      "Time_End": 1254.14,
      "Text": " in the if statement holds,"
    },
    {
      "Time_Start": 1254.14,
      "Time_End": 1258.14,
      "Text": " meaning the MSMM feature control supported global variable"
    },
    {
      "Time_Start": 1258.14,
      "Time_End": 1261.14,
      "Text": " should not be zero."
    },
    {
      "Time_Start": 1261.14,
      "Time_End": 1264.14,
      "Text": " And remember, we have a write primitive to the SMRAM"
    },
    {
      "Time_Start": 1264.14,
      "Time_End": 1269.14,
      "Text": " to the place where this global variable is stored."
    },
    {
      "Time_Start": 1269.14,
      "Time_End": 1274.14,
      "Text": " This leads to the full recipe of unauthorized code execution"
    },
    {
      "Time_Start": 1274.14,
      "Time_End": 1276.14,
      "Text": " in SMM from kernel."
    },
    {
      "Time_Start": 1276.14,
      "Time_End": 1279.14,
      "Text": " So first, we use our write primitive"
    },
    {
      "Time_Start": 1279.14,
      "Time_End": 1283.14,
      "Text": " to annul the MSMM feature control supported global variable."
    },
    {
      "Time_Start": 1283.14,
      "Time_End": 1286.14,
      "Text": " Then we put the machine to sleep, wake it up."
    },
    {
      "Time_Start": 1286.14,
      "Time_End": 1290.14,
      "Text": " At this point, the function you saw earlier is executed."
    },
    {
      "Time_Start": 1290.14,
      "Time_End": 1293.14,
      "Text": " The condition in the if statement does not hold."
    },
    {
      "Time_Start": 1293.14,
      "Time_End": 1297.14,
      "Text": " And the SMAP-like mechanism is not enabled."
    },
    {
      "Time_Start": 1297.14,
      "Time_End": 1299.14,
      "Text": " Hooray."
    },
    {
      "Time_Start": 1299.14,
      "Time_End": 1302.14,
      "Text": " Now we create our own SMI handler entry point,"
    },
    {
      "Time_Start": 1302.14,
      "Time_End": 1306.14,
      "Text": " the first code that will be executed upon entering SMM."
    },
    {
      "Time_Start": 1306.14,
      "Time_End": 1309.14,
      "Text": " And we use a write primitive once again"
    },
    {
      "Time_Start": 1309.14,
      "Time_End": 1313.14,
      "Text": " to modify the value of the SMBase MSR in the safe state."
    },
    {
      "Time_Start": 1313.14,
      "Time_End": 1317.14,
      "Text": " And thus, we trigger an SMBase relocation."
    },
    {
      "Time_Start": 1317.14,
      "Time_End": 1319.14,
      "Text": " And we trigger an SMI."
    },
    {
      "Time_Start": 1319.14,
      "Time_End": 1322.14,
      "Text": " And drumrolls, please."
    },
    {
      "Time_Start": 1322.14,
      "Time_End": 1325.14,
      "Text": " We have code execution in SMM."
    },
    {
      "Time_Start": 1325.14,
      "Time_End": 1327.14,
      "Text": " All right."
    },
    {
      "Time_Start": 1327.14,
      "Time_End": 1331.14,
      "Text": " Great success."
    },
    {
      "Time_Start": 1331.14,
      "Time_End": 1336.14,
      "Text": " So frankly and humbly speaking, this method is pretty awesome."
    },
    {
      "Time_Start": 1336.14,
      "Time_End": 1338.14,
      "Text": " But it gets even better."
    },
    {
      "Time_Start": 1338.14,
      "Time_End": 1342.14,
      "Text": " So the SMI handler entry point starts running in real mode,"
    },
    {
      "Time_Start": 1342.14,
      "Time_End": 1345.14,
      "Text": " meaning that the page tables, enforcements"
    },
    {
      "Time_Start": 1345.14,
      "Time_End": 1348.14,
      "Text": " have not kicked in yet because, well, there is no paging."
    },
    {
      "Time_Start": 1348.14,
      "Time_End": 1353.14,
      "Text": " And as we crafted our own SMI handler entry point,"
    },
    {
      "Time_Start": 1353.14,
      "Time_End": 1356.14,
      "Text": " we have full and unrestricted memory access"
    },
    {
      "Time_Start": 1356.14,
      "Time_End": 1359.14,
      "Text": " to all of the RAM."
    },
    {
      "Time_Start": 1359.14,
      "Time_End": 1362.14,
      "Text": " So for instance, we do not mind the non-executable"
    },
    {
      "Time_Start": 1362.14,
      "Time_End": 1364.14,
      "Text": " or read-only pages,"
    },
    {
      "Time_Start": 1364.14,
      "Time_End": 1368.14,
      "Text": " or the fact that the paging mechanism is static,"
    },
    {
      "Time_Start": 1369.14,
      "Time_End": 1374.14,
      "Text": " or the fact that the page table resides in read-only pages,"
    },
    {
      "Time_Start": 1374.14,
      "Time_End": 1378.14,
      "Text": " or the non-executable stack, or any of these mitigations."
    },
    {
      "Time_Start": 1378.14,
      "Time_End": 1380.14,
      "Text": " This is pretty awesome."
    },
    {
      "Time_Start": 1380.14,
      "Time_End": 1385.14,
      "Text": " However, newer mitigations do hinder our exploitation."
    },
    {
      "Time_Start": 1385.14,
      "Time_End": 1389.14,
      "Text": " In particular, the S3 and SMBase log bits."
    },
    {
      "Time_Start": 1389.14,
      "Time_End": 1391.14,
      "Text": " When these bits are set,"
    },
    {
      "Time_Start": 1391.14,
      "Time_End": 1396.14,
      "Text": " the CR3 register and the SMBase MSR"
    },
    {
      "Time_Start": 1396.14,
      "Time_End": 1401.14,
      "Text": " cannot be modified until next reboot."
    },
    {
      "Time_Start": 1401.14,
      "Time_End": 1405.14,
      "Text": " So while those mitigations are not fully adopted yet"
    },
    {
      "Time_Start": 1405.14,
      "Time_End": 1407.14,
      "Text": " in all platforms,"
    },
    {
      "Time_Start": 1407.14,
      "Time_End": 1410.14,
      "Text": " we wanted to deal with them as well."
    },
    {
      "Time_Start": 1410.14,
      "Time_End": 1413.14,
      "Text": " And to do that, we had no lead at this moment."
    },
    {
      "Time_Start": 1413.14,
      "Time_End": 1415.14,
      "Text": " So we decided to dig up once again"
    },
    {
      "Time_Start": 1415.14,
      "Time_End": 1417.14,
      "Text": " through the pages of history."
    },
    {
      "Time_Start": 1417.14,
      "Time_End": 1420.14,
      "Text": " And we stumbled upon this cache poisoning attack"
    },
    {
      "Time_Start": 1420.14,
      "Time_End": 1424.14,
      "Text": " that was presented in 2009 by Rafael and Joanna."
    },
    {
      "Time_Start": 1424.14,
      "Time_End": 1426.14,
      "Text": " And using the cache poisoning technique,"
    },
    {
      "Time_Start": 1426.14,
      "Time_End": 1431.14,
      "Text": " you basically are able to arbitrarily read and write"
    },
    {
      "Time_Start": 1431.14,
      "Time_End": 1433.14,
      "Text": " to and from the SMRAM."
    },
    {
      "Time_Start": 1433.14,
      "Time_End": 1436.14,
      "Text": " So let's see how this mechanism works."
    },
    {
      "Time_Start": 1436.14,
      "Time_End": 1440.14,
      "Text": " So when we try to write to the SMRAM from the kernel,"
    },
    {
      "Time_Start": 1440.14,
      "Time_End": 1442.14,
      "Text": " we will stumble upon a barrier,"
    },
    {
      "Time_Start": 1442.14,
      "Time_End": 1444.14,
      "Text": " which basically makes sense, right?"
    },
    {
      "Time_Start": 1444.14,
      "Time_End": 1446.14,
      "Text": " We are not allowed to write to the SMRAM,"
    },
    {
      "Time_Start": 1446.14,
      "Time_End": 1449.14,
      "Text": " so the memory transactions will be discarded."
    },
    {
      "Time_Start": 1449.14,
      "Time_End": 1452.14,
      "Text": " However, this was a little bit misleading."
    },
    {
      "Time_Start": 1452.14,
      "Time_End": 1455.14,
      "Text": " In practice, when we try to write to the SMRAM,"
    },
    {
      "Time_Start": 1455.14,
      "Time_End": 1457.14,
      "Text": " we'll go through the cache first,"
    },
    {
      "Time_Start": 1457.14,
      "Time_End": 1459.14,
      "Text": " and the data will be stored there first,"
    },
    {
      "Time_Start": 1459.14,
      "Time_End": 1462.14,
      "Text": " and only then it will be written back to the SMRAM."
    },
    {
      "Time_Start": 1462.14,
      "Time_End": 1468.14,
      "Text": " So what if before the data is written back to the SMRAM,"
    },
    {
      "Time_Start": 1468.14,
      "Time_End": 1470.14,
      "Text": " we will trigger an SMI,"
    },
    {
      "Time_Start": 1470.14,
      "Time_End": 1474.14,
      "Text": " and the CPU will enter SMM state,"
    },
    {
      "Time_Start": 1474.14,
      "Time_End": 1476.14,
      "Text": " the barrier will be removed,"
    },
    {
      "Time_Start": 1476.14,
      "Time_End": 1479.14,
      "Text": " and with some luck, only then the writeback will occur,"
    },
    {
      "Time_Start": 1479.14,
      "Time_End": 1483.14,
      "Text": " and we'll modify the content of the SMRAM."
    },
    {
      "Time_Start": 1483.14,
      "Time_End": 1485.14,
      "Text": " So this would work."
    },
    {
      "Time_Start": 1485.14,
      "Time_End": 1489.14,
      "Text": " But obviously, this is already mitigated,"
    },
    {
      "Time_Start": 1489.14,
      "Time_End": 1493.14,
      "Text": " and this is due to a special MSR that is called SMRR,"
    },
    {
      "Time_Start": 1493.14,
      "Time_End": 1495.14,
      "Text": " the System Management Range Register,"
    },
    {
      "Time_Start": 1495.14,
      "Time_End": 1497.14,
      "Text": " and it does a simple thing."
    },
    {
      "Time_Start": 1497.14,
      "Time_End": 1502.14,
      "Text": " It basically disables the caching of the SMRAM."
    },
    {
      "Time_Start": 1502.14,
      "Time_End": 1505.14,
      "Text": " But we already know how to disable MSRs, right?"
    },
    {
      "Time_Start": 1505.14,
      "Time_End": 1509.14,
      "Text": " So let's see the code that restores it from the sleep state."
    },
    {
      "Time_Start": 1509.14,
      "Time_End": 1512.14,
      "Text": " And this probably looks familiar,"
    },
    {
      "Time_Start": 1512.14,
      "Time_End": 1514.14,
      "Text": " and this is why."
    },
    {
      "Time_Start": 1514.14,
      "Time_End": 1518.14,
      "Text": " So this is the line of code that actually restores the MSR,"
    },
    {
      "Time_Start": 1518.14,
      "Time_End": 1522.14,
      "Text": " and once again, it is dependent upon a global."
    },
    {
      "Time_Start": 1522.14,
      "Time_End": 1524.14,
      "Text": " So what if we annul this global,"
    },
    {
      "Time_Start": 1524.14,
      "Time_End": 1527.14,
      "Text": " set it to zero using one of our write primitives,"
    },
    {
      "Time_Start": 1527.14,
      "Time_End": 1529.14,
      "Text": " we'll put the machine into sleep,"
    },
    {
      "Time_Start": 1529.14,
      "Time_End": 1531.14,
      "Text": " we'll wake it up,"
    },
    {
      "Time_Start": 1531.14,
      "Time_End": 1535.14,
      "Text": " and when we wake up, we will be able to write to the SMRAM"
    },
    {
      "Time_Start": 1535.14,
      "Time_End": 1539.14,
      "Text": " directly by resurrecting from the dead the cache-poisoning attack."
    },
    {
      "Time_Start": 1539.14,
      "Time_End": 1541.14,
      "Text": " So once again, success,"
    },
    {
      "Time_Start": 1541.14,
      "Time_End": 1545.14,
      "Text": " and we can deal with even those newer mitigations."
    },
    {
      "Time_Start": 1545.14,
      "Time_End": 1548.14,
      "Text": " So this is a great time for a demo,"
    },
    {
      "Time_Start": 1548.14,
      "Time_End": 1550.14,
      "Text": " and let's hope it will work."
    },
    {
      "Time_Start": 1555.14,
      "Time_End": 1557.14,
      "Text": " Okay. Perfect."
    },
    {
      "Time_Start": 1557.14,
      "Time_End": 1561.14,
      "Text": " So before we begin, please notice the Intel NUC logo."
    },
    {
      "Time_Start": 1561.14,
      "Time_End": 1563.14,
      "Text": " This logo..."
    },
    {
      "Time_Start": 1570.14,
      "Time_End": 1572.14,
      "Text": " This logo is stored on the SPI Flash,"
    },
    {
      "Time_Start": 1572.14,
      "Time_End": 1575.14,
      "Text": " along with the UEFI firmware."
    },
    {
      "Time_Start": 1575.14,
      "Time_End": 1579.14,
      "Text": " So if you are able to execute code inside SMM,"
    },
    {
      "Time_Start": 1579.14,
      "Time_End": 1581.14,
      "Text": " we will be able to modify this logo."
    },
    {
      "Time_Start": 1581.14,
      "Time_End": 1586.14,
      "Text": " The reason for that is because only SMM is accessible to the SPI Flash."
    },
    {
      "Time_Start": 1586.14,
      "Time_End": 1589.14,
      "Text": " It is the only one that is able to write to it."
    },
    {
      "Time_Start": 1589.14,
      "Time_End": 1592.14,
      "Text": " So now it's time to elevate our privileges."
    },
    {
      "Time_Start": 1592.14,
      "Time_End": 1595.14,
      "Text": " We'll begin by crafting a new write primitive"
    },
    {
      "Time_Start": 1595.14,
      "Time_End": 1597.14,
      "Text": " of the value of zero."
    },
    {
      "Time_Start": 1597.14,
      "Time_End": 1599.14,
      "Text": " Remember, we had a rather complex write primitive,"
    },
    {
      "Time_Start": 1599.14,
      "Time_End": 1601.14,
      "Text": " and none of them was an actual zero."
    },
    {
      "Time_Start": 1601.14,
      "Time_End": 1603.14,
      "Text": " So by chaining a couple of them"
    },
    {
      "Time_Start": 1603.14,
      "Time_End": 1606.14,
      "Text": " and modifying a couple of globals inside the SMRAM,"
    },
    {
      "Time_Start": 1606.14,
      "Time_End": 1609.14,
      "Text": " we were able to craft the value of zero,"
    },
    {
      "Time_Start": 1609.14,
      "Time_End": 1614.14,
      "Text": " and this will help us in the next step of our attack."
    },
    {
      "Time_Start": 1614.14,
      "Time_End": 1619.14,
      "Text": " So now we will try to annul the MSMM feature control supported global,"
    },
    {
      "Time_Start": 1619.14,
      "Time_End": 1624.14,
      "Text": " which is responsible for the MSR restoration."
    },
    {
      "Time_Start": 1624.14,
      "Time_End": 1627.14,
      "Text": " And if you are actually able to disable it,"
    },
    {
      "Time_Start": 1627.14,
      "Time_End": 1631.14,
      "Text": " when we return from sleep state, the MSR will be annulled."
    },
    {
      "Time_Start": 1631.14,
      "Time_End": 1636.14,
      "Text": " So now that we have annulled this global,"
    },
    {
      "Time_Start": 1636.14,
      "Time_End": 1639.14,
      "Text": " we will read the MSR before we go to sleep state."
    },
    {
      "Time_Start": 1639.14,
      "Time_End": 1643.14,
      "Text": " We will see that the value of the MSR is five,"
    },
    {
      "Time_Start": 1643.14,
      "Time_End": 1645.14,
      "Text": " which stands for two enabled bits,"
    },
    {
      "Time_Start": 1645.14,
      "Time_End": 1648.14,
      "Text": " both the enable bit and the lock bit,"
    },
    {
      "Time_Start": 1648.14,
      "Time_End": 1650.14,
      "Text": " and we'll put the machine into sleep."
    },
    {
      "Time_Start": 1650.14,
      "Time_End": 1654.14,
      "Text": " So at this moment, we count on the user to return from the sleep."
    },
    {
      "Time_Start": 1654.14,
      "Time_End": 1656.14,
      "Text": " I guess no one was ever concerned"
    },
    {
      "Time_Start": 1656.14,
      "Time_End": 1658.14,
      "Text": " that he's being SMM mega breached"
    },
    {
      "Time_Start": 1658.14,
      "Time_End": 1661.14,
      "Text": " when his machine suddenly went to sleep."
    },
    {
      "Time_Start": 1661.14,
      "Time_End": 1663.14,
      "Text": " And now that he is back,"
    },
    {
      "Time_Start": 1663.14,
      "Time_End": 1666.14,
      "Text": " we will read the MSR once again, and it is zero."
    },
    {
      "Time_Start": 1666.14,
      "Time_End": 1670.14,
      "Text": " So now we are able to execute code outside the SMRAM."
    },
    {
      "Time_Start": 1670.14,
      "Time_End": 1672.14,
      "Text": " But how we will do it?"
    },
    {
      "Time_Start": 1672.14,
      "Time_End": 1674.14,
      "Text": " Using the SMBase relocation attack."
    },
    {
      "Time_Start": 1674.14,
      "Time_End": 1677.14,
      "Text": " So at this point, we'll execute the SMBase relocation attack"
    },
    {
      "Time_Start": 1677.14,
      "Time_End": 1681.14,
      "Text": " and execute our own shellcode outside the SMRAM."
    },
    {
      "Time_Start": 1681.14,
      "Time_End": 1683.14,
      "Text": " So what the shellcode actually does,"
    },
    {
      "Time_Start": 1683.14,
      "Time_End": 1686.14,
      "Text": " it simply replaces one of the SMI handlers,"
    },
    {
      "Time_Start": 1686.14,
      "Time_End": 1690.14,
      "Text": " and now we are only left with triggering it."
    },
    {
      "Time_Start": 1690.14,
      "Time_End": 1694.14,
      "Text": " So now that we have triggered it,"
    },
    {
      "Time_Start": 1694.14,
      "Time_End": 1696.14,
      "Text": " we will reboot the machine"
    },
    {
      "Time_Start": 1696.14,
      "Time_End": 1700.14,
      "Text": " and see the result of what our SMI handler actually did."
    },
    {
      "Time_Start": 1702.14,
      "Time_End": 1708.14,
      "Text": " And voila!"
    },
    {
      "Time_Start": 1708.14,
      "Time_End": 1710.14,
      "Text": " We managed to change the logo!"
    },
    {
      "Time_Start": 1710.14,
      "Time_End": 1723.14,
      "Text": " So to better understand the implications of the issues we have found,"
    },
    {
      "Time_Start": 1723.14,
      "Time_End": 1725.14,
      "Text": " we need to understand the UEFI ecosystem first."
    },
    {
      "Time_Start": 1725.14,
      "Time_End": 1728.14,
      "Text": " So everything begins with the TianoCore project,"
    },
    {
      "Time_Start": 1728.14,
      "Time_End": 1730.14,
      "Text": " or what some of you may refer to as the ADK2,"
    },
    {
      "Time_Start": 1730.14,
      "Time_End": 1735.14,
      "Text": " or practically the source code for any of your modern UEFI frameworks."
    },
    {
      "Time_Start": 1735.14,
      "Time_End": 1738.14,
      "Text": " Then comes the IBVs, the independent BIOS vendors."
    },
    {
      "Time_Start": 1738.14,
      "Time_End": 1741.14,
      "Text": " They take this source code, ADK2,"
    },
    {
      "Time_Start": 1741.14,
      "Time_End": 1744.14,
      "Text": " and practically add a major portion of functionality."
    },
    {
      "Time_Start": 1744.14,
      "Time_End": 1748.14,
      "Text": " They add all the different SMI handlers along the way."
    },
    {
      "Time_Start": 1748.14,
      "Time_End": 1750.14,
      "Text": " Then they deliver it to the OEMs,"
    },
    {
      "Time_Start": 1750.14,
      "Time_End": 1752.14,
      "Text": " to the original equipment manufacturers,"
    },
    {
      "Time_Start": 1752.14,
      "Time_End": 1756.14,
      "Text": " such as Acer, Asus, Dell, Gigabyte, HP,"
    },
    {
      "Time_Start": 1756.14,
      "Time_End": 1758.14,
      "Text": " Intel in the case of the Intel NUCs,"
    },
    {
      "Time_Start": 1758.14,
      "Time_End": 1761.14,
      "Text": " Lenovo, and MSI."
    },
    {
      "Time_Start": 1761.14,
      "Time_End": 1765.14,
      "Text": " Then those OEMs deliver it to you guys, the end customers."
    },
    {
      "Time_Start": 1765.14,
      "Time_End": 1769.14,
      "Text": " So in the attempt to understand how many devices are vulnerable to Ringhopper,"
    },
    {
      "Time_Start": 1769.14,
      "Time_End": 1771.14,
      "Text": " we found out that only in 2020,"
    },
    {
      "Time_Start": 1771.14,
      "Time_End": 1774.14,
      "Text": " there were manufactured more than 200 million devices"
    },
    {
      "Time_Start": 1774.14,
      "Time_End": 1776.14,
      "Text": " that are vulnerable to our attack,"
    },
    {
      "Time_Start": 1776.14,
      "Time_End": 1778.14,
      "Text": " which is absolutely crazy,"
    },
    {
      "Time_Start": 1778.14,
      "Time_End": 1783.14,
      "Text": " and probably results in a couple of billion devices that are vulnerable."
    },
    {
      "Time_Start": 1783.14,
      "Time_End": 1786.14,
      "Text": " And obviously it means tons of CVs."
    },
    {
      "Time_Start": 1786.14,
      "Time_End": 1789.14,
      "Text": " So if things were not bad enough,"
    },
    {
      "Time_Start": 1789.14,
      "Time_End": 1791.14,
      "Text": " we want to make things even worse."
    },
    {
      "Time_Start": 1791.14,
      "Time_End": 1795.14,
      "Text": " Up until now, we attack the machine from kernel"
    },
    {
      "Time_Start": 1795.14,
      "Time_End": 1798.14,
      "Text": " to SMM, a.k.a. Ring-2."
    },
    {
      "Time_Start": 1798.14,
      "Time_End": 1802.14,
      "Text": " But we want to make our attack work from Ring-3 as well,"
    },
    {
      "Time_Start": 1802.14,
      "Time_End": 1803.14,
      "Text": " from user space."
    },
    {
      "Time_Start": 1803.14,
      "Time_End": 1806.14,
      "Text": " And to do that, we require three different things."
    },
    {
      "Time_Start": 1806.14,
      "Time_End": 1808.14,
      "Text": " We need to be able to generate DMA transactions,"
    },
    {
      "Time_Start": 1808.14,
      "Time_End": 1811.14,
      "Text": " we need to be able to trigger SMIs,"
    },
    {
      "Time_Start": 1811.14,
      "Time_End": 1814.14,
      "Text": " and we need to be able to write to specific physical memory."
    },
    {
      "Time_Start": 1814.14,
      "Time_End": 1817.14,
      "Text": " So let's begin by generating DMA transactions."
    },
    {
      "Time_Start": 1817.14,
      "Time_End": 1819.14,
      "Text": " So remember the previous diagram"
    },
    {
      "Time_Start": 1819.14,
      "Time_End": 1823.14,
      "Text": " where we hooked inside a kernel the DMA response"
    },
    {
      "Time_Start": 1823.14,
      "Time_End": 1830.14,
      "Text": " and we made some very complicated DMA requests?"
    },
    {
      "Time_Start": 1830.14,
      "Time_End": 1833.14,
      "Text": " So we figured out it is way, way simpler."
    },
    {
      "Time_Start": 1833.14,
      "Time_End": 1835.14,
      "Text": " In order to generate DMA requests,"
    },
    {
      "Time_Start": 1835.14,
      "Time_End": 1837.14,
      "Text": " you only have to read a file."
    },
    {
      "Time_Start": 1837.14,
      "Time_End": 1840.14,
      "Text": " The data will be returned to us with DMA directly."
    },
    {
      "Time_Start": 1840.14,
      "Time_End": 1844.14,
      "Text": " And to make sure that it is being redirected"
    },
    {
      "Time_Start": 1844.14,
      "Time_End": 1846.14,
      "Text": " to the input buffer, we do not need a hook."
    },
    {
      "Time_Start": 1846.14,
      "Time_End": 1849.14,
      "Text": " We simply read it into the input buffer."
    },
    {
      "Time_Start": 1849.14,
      "Time_End": 1851.14,
      "Text": " So this was it,"
    },
    {
      "Time_Start": 1851.14,
      "Time_End": 1853.14,
      "Text": " and how we generated DMA transactions from user space."
    },
    {
      "Time_Start": 1853.14,
      "Time_End": 1855.14,
      "Text": " It was rather simple,"
    },
    {
      "Time_Start": 1855.14,
      "Time_End": 1859.14,
      "Text": " but triggering SMIs is way complicated."
    },
    {
      "Time_Start": 1859.14,
      "Time_End": 1863.14,
      "Text": " And this is because we need to execute a special opcode,"
    },
    {
      "Time_Start": 1863.14,
      "Time_End": 1867.14,
      "Text": " out B2, that can be executed only from kernel."
    },
    {
      "Time_Start": 1867.14,
      "Time_End": 1870.14,
      "Text": " And at this point, we got very frustrated."
    },
    {
      "Time_Start": 1870.14,
      "Time_End": 1873.14,
      "Text": " And like every frustrated millennial,"
    },
    {
      "Time_Start": 1873.14,
      "Time_End": 1875.14,
      "Text": " we went on social media."
    },
    {
      "Time_Start": 1875.14,
      "Time_End": 1877.14,
      "Text": " And in specific, the ones that,"
    },
    {
      "Time_Start": 1877.14,
      "Time_End": 1880.14,
      "Text": " if you triple its name by three,"
    },
    {
      "Time_Start": 1880.14,
      "Time_End": 1884.14,
      "Text": " you'll probably get the wrong results."
    },
    {
      "Time_Start": 1884.14,
      "Time_End": 1888.14,
      "Text": " So anyway,"
    },
    {
      "Time_Start": 1888.14,
      "Time_End": 1891.14,
      "Text": " we stumbled upon one of Alex Matrosoff's tweets,"
    },
    {
      "Time_Start": 1891.14,
      "Time_End": 1895.14,
      "Text": " which says that practically any BIOS update tools"
    },
    {
      "Time_Start": 1895.14,
      "Time_End": 1897.14,
      "Text": " that you'll find out there"
    },
    {
      "Time_Start": 1897.14,
      "Time_End": 1899.14,
      "Text": " probably has some low-level functionality"
    },
    {
      "Time_Start": 1899.14,
      "Time_End": 1902.14,
      "Text": " that can be reused for offensive purposes."
    },
    {
      "Time_Start": 1902.14,
      "Time_End": 1905.14,
      "Text": " And indeed there was."
    },
    {
      "Time_Start": 1905.14,
      "Time_End": 1908.14,
      "Text": " So AMI provides two drivers,"
    },
    {
      "Time_Start": 1908.14,
      "Time_End": 1910.14,
      "Text": " a Linux driver and a signed Windows driver,"
    },
    {
      "Time_Start": 1910.14,
      "Time_End": 1913.14,
      "Text": " and both of them expose an API"
    },
    {
      "Time_Start": 1913.14,
      "Time_End": 1916.14,
      "Text": " for triggering any arbitrary SMIs that we desire."
    },
    {
      "Time_Start": 1916.14,
      "Time_End": 1918.14,
      "Text": " Basically a yoke tool."
    },
    {
      "Time_Start": 1918.14,
      "Time_End": 1922.14,
      "Text": " So now that we have done with triggering SMIs,"
    },
    {
      "Time_Start": 1922.14,
      "Time_End": 1925.14,
      "Text": " we are only left with writing to specific physical memory."
    },
    {
      "Time_Start": 1925.14,
      "Time_End": 1927.14,
      "Text": " And I remind you,"
    },
    {
      "Time_Start": 1927.14,
      "Time_End": 1930.14,
      "Text": " we wanted to make it work both from Windows and Linux."
    },
    {
      "Time_Start": 1930.14,
      "Time_End": 1933.14,
      "Text": " So let's start with Windows."
    },
    {
      "Time_Start": 1933.14,
      "Time_End": 1937.14,
      "Text": " So the communication with SMM"
    },
    {
      "Time_Start": 1937.14,
      "Time_End": 1940.14,
      "Text": " is a little bit more complicated."
    },
    {
      "Time_Start": 1940.14,
      "Time_End": 1943.14,
      "Text": " It has a special struct that is called a mailbox,"
    },
    {
      "Time_Start": 1943.14,
      "Time_End": 1946.14,
      "Text": " which has a description of all the things"
    },
    {
      "Time_Start": 1946.14,
      "Time_End": 1948.14,
      "Text": " related with the communication with SMM."
    },
    {
      "Time_Start": 1948.14,
      "Time_End": 1951.14,
      "Text": " And among others, it contains a physical address"
    },
    {
      "Time_Start": 1951.14,
      "Time_End": 1953.14,
      "Text": " of a row buffer,"
    },
    {
      "Time_Start": 1953.14,
      "Time_End": 1955.14,
      "Text": " which would actually contain the input."
    },
    {
      "Time_Start": 1955.14,
      "Time_End": 1958.14,
      "Text": " So in order to access it from SMM,"
    },
    {
      "Time_Start": 1958.14,
      "Time_End": 1960.14,
      "Text": " we require a physical address,"
    },
    {
      "Time_Start": 1960.14,
      "Time_End": 1964.14,
      "Text": " which is basically the virtual address within SMM context."
    },
    {
      "Time_Start": 1964.14,
      "Time_End": 1967.14,
      "Text": " And to access it from user space,"
    },
    {
      "Time_Start": 1967.14,
      "Time_End": 1969.14,
      "Text": " we require a virtual address"
    },
    {
      "Time_Start": 1969.14,
      "Time_End": 1973.14,
      "Text": " that maps exactly this physical memory region."
    },
    {
      "Time_Start": 1973.14,
      "Time_End": 1976.14,
      "Text": " So let's look at the buffer mapping yoke tool"
    },
    {
      "Time_Start": 1976.14,
      "Time_End": 1978.14,
      "Text": " inside one of the Windows drivers."
    },
    {
      "Time_Start": 1978.14,
      "Time_End": 1981.14,
      "Text": " So it begins by triggering SMID 9,"
    },
    {
      "Time_Start": 1981.14,
      "Time_End": 1984.14,
      "Text": " which basically populates the mailbox"
    },
    {
      "Time_Start": 1984.14,
      "Time_End": 1987.14,
      "Text": " and along the way the row pointer to the buffer."
    },
    {
      "Time_Start": 1987.14,
      "Time_End": 1991.14,
      "Text": " And then in order to access this mailbox,"
    },
    {
      "Time_Start": 1991.14,
      "Time_End": 1995.14,
      "Text": " it needs to map this physical address."
    },
    {
      "Time_Start": 1995.14,
      "Time_End": 1997.14,
      "Text": " So the next thing that it does,"
    },
    {
      "Time_Start": 1997.14,
      "Time_End": 1999.14,
      "Text": " it basically maps this physical address"
    },
    {
      "Time_Start": 1999.14,
      "Time_End": 2001.14,
      "Text": " into an accessible virtual address."
    },
    {
      "Time_Start": 2001.14,
      "Time_End": 2004.14,
      "Text": " Then at offset 8,"
    },
    {
      "Time_Start": 2004.14,
      "Time_End": 2007.14,
      "Text": " it accesses the pointer to this physical buffer,"
    },
    {
      "Time_Start": 2007.14,
      "Time_End": 2008.14,
      "Text": " the row buffer,"
    },
    {
      "Time_Start": 2008.14,
      "Time_End": 2010.14,
      "Text": " and once again map it"
    },
    {
      "Time_Start": 2010.14,
      "Time_End": 2013.14,
      "Text": " into a user-accessible virtual address."
    },
    {
      "Time_Start": 2013.14,
      "Time_End": 2017.14,
      "Text": " And then returns everything into a user-accessible memory"
    },
    {
      "Time_Start": 2017.14,
      "Time_End": 2021.14,
      "Text": " so the user will be able to access those virtual addresses."
    },
    {
      "Time_Start": 2021.14,
      "Time_End": 2024.14,
      "Text": " So some of you may notice there is a race condition here."
    },
    {
      "Time_Start": 2024.14,
      "Time_End": 2027.14,
      "Text": " In between the time that the SMI is being triggered"
    },
    {
      "Time_Start": 2027.14,
      "Time_End": 2029.14,
      "Text": " and the mailbox is being populated"
    },
    {
      "Time_Start": 2029.14,
      "Time_End": 2033.14,
      "Text": " with the pointer to this row buffer"
    },
    {
      "Time_Start": 2033.14,
      "Time_End": 2037.14,
      "Text": " and the times it is being mapped to user virtual address."
    },
    {
      "Time_Start": 2037.14,
      "Time_End": 2039.14,
      "Text": " So what if we change this physical address"
    },
    {
      "Time_Start": 2039.14,
      "Time_End": 2043.14,
      "Text": " in between the time that the mailbox is being populated"
    },
    {
      "Time_Start": 2043.14,
      "Time_End": 2046.14,
      "Text": " and the times that this physical address is being mapped?"
    },
    {
      "Time_Start": 2046.14,
      "Time_End": 2049.1400000000003,
      "Text": " Basically we'll be able to map"
    },
    {
      "Time_Start": 2049.1400000000003,
      "Time_End": 2052.1400000000003,
      "Text": " any arbitrary physical address that we desire."
    },
    {
      "Time_Start": 2052.1400000000003,
      "Time_End": 2054.1400000000003,
      "Text": " So let's see how it works."
    },
    {
      "Time_Start": 2054.1400000000003,
      "Time_End": 2057.1400000000003,
      "Text": " We will trigger the buffer mapping yoke tool twice."
    },
    {
      "Time_Start": 2057.1400000000003,
      "Time_End": 2059.1400000000003,
      "Text": " On the first attempt we will get an access"
    },
    {
      "Time_Start": 2059.1400000000003,
      "Time_End": 2061.1400000000003,
      "Text": " to the mailbox virtual address"
    },
    {
      "Time_Start": 2061.14,
      "Time_End": 2064.14,
      "Text": " so we will be able to modify the mailbox at offset 8"
    },
    {
      "Time_Start": 2064.14,
      "Time_End": 2066.14,
      "Text": " with our own desired physical address."
    },
    {
      "Time_Start": 2066.14,
      "Time_End": 2068.14,
      "Text": " And then we will modify the mailbox"
    },
    {
      "Time_Start": 2068.14,
      "Time_End": 2070.14,
      "Text": " to exploit this race condition"
    },
    {
      "Time_Start": 2070.14,
      "Time_End": 2072.14,
      "Text": " and basically change this address"
    },
    {
      "Time_Start": 2072.14,
      "Time_End": 2074.14,
      "Text": " with our own arbitrary physical address"
    },
    {
      "Time_Start": 2074.14,
      "Time_End": 2077.14,
      "Text": " and we will get the corresponding virtual address."
    },
    {
      "Time_Start": 2077.14,
      "Time_End": 2079.14,
      "Text": " So this looks great,"
    },
    {
      "Time_Start": 2079.14,
      "Time_End": 2082.14,
      "Text": " but reality makes things even harder."
    },
    {
      "Time_Start": 2082.14,
      "Time_End": 2084.14,
      "Text": " In order to avoid the remapping"
    },
    {
      "Time_Start": 2084.14,
      "Time_End": 2087.14,
      "Text": " of the same physical addresses over and over again,"
    },
    {
      "Time_Start": 2087.14,
      "Time_End": 2089.14,
      "Text": " those globals are being checked,"
    },
    {
      "Time_Start": 2089.14,
      "Time_End": 2091.14,
      "Text": " which basically makes sense, right?"
    },
    {
      "Time_Start": 2091.14,
      "Time_End": 2095.14,
      "Text": " We do not want to map the same address over and over again."
    },
    {
      "Time_Start": 2095.14,
      "Time_End": 2099.14,
      "Text": " So at this point we decided to look at the cleanup yoke tool."
    },
    {
      "Time_Start": 2099.14,
      "Time_End": 2102.14,
      "Text": " And we noticed that the cleanup yoke tool,"
    },
    {
      "Time_Start": 2102.14,
      "Time_End": 2105.14,
      "Text": " all it does is to annul those globals."
    },
    {
      "Time_Start": 2105.14,
      "Time_End": 2108.14,
      "Text": " And I will repeat it, it only annuls the globals."
    },
    {
      "Time_Start": 2108.14,
      "Time_End": 2112.14,
      "Text": " There is no unmapping of this virtual address once or ever."
    },
    {
      "Time_Start": 2112.14,
      "Time_End": 2115.14,
      "Text": " So it is still accessible to user space."
    },
    {
      "Time_Start": 2115.14,
      "Time_End": 2117.14,
      "Text": " So we will use this fact"
    },
    {
      "Time_Start": 2117.14,
      "Time_End": 2119.14,
      "Text": " and we will make the following exploitation."
    },
    {
      "Time_Start": 2119.14,
      "Time_End": 2122.14,
      "Text": " So we will trigger the buffer mapping yoke tool"
    },
    {
      "Time_Start": 2122.14,
      "Time_End": 2124.14,
      "Text": " to get the mailbox virtual address."
    },
    {
      "Time_Start": 2124.14,
      "Time_End": 2127.14,
      "Text": " We will trigger the cleanup yoke tool to annul the globals."
    },
    {
      "Time_Start": 2127.14,
      "Time_End": 2129.14,
      "Text": " We will exploit the file,"
    },
    {
      "Time_Start": 2129.14,
      "Time_End": 2131.14,
      "Text": " and then we will exploit the following race condition."
    },
    {
      "Time_Start": 2131.14,
      "Time_End": 2133.14,
      "Text": " From two cores, we will do as follows."
    },
    {
      "Time_Start": 2133.14,
      "Time_End": 2135.14,
      "Text": " On the first core, we will trigger"
    },
    {
      "Time_Start": 2135.14,
      "Time_End": 2137.14,
      "Text": " the buffing mapping yoke tool once again"
    },
    {
      "Time_Start": 2137.14,
      "Time_End": 2139.14,
      "Text": " to populate the mailbox"
    },
    {
      "Time_Start": 2139.14,
      "Time_End": 2142.14,
      "Text": " and to map the physical address inside it."
    },
    {
      "Time_Start": 2142.14,
      "Time_End": 2144.14,
      "Text": " From within the other cores,"
    },
    {
      "Time_Start": 2144.14,
      "Time_End": 2147.14,
      "Text": " we will use our previous virtual address of the mailbox"
    },
    {
      "Time_Start": 2147.14,
      "Time_End": 2150.14,
      "Text": " to modify it at offset 8"
    },
    {
      "Time_Start": 2150.14,
      "Time_End": 2153.14,
      "Text": " with our own desired physical address."
    },
    {
      "Time_Start": 2153.14,
      "Time_End": 2155.14,
      "Text": " Then we'll check if the newly mapped physical address"
    },
    {
      "Time_Start": 2155.14,
      "Time_End": 2157.14,
      "Text": " is the ones that we wanted."
    },
    {
      "Time_Start": 2157.14,
      "Time_End": 2160.14,
      "Text": " If not, we will simply repeat the entire process."
    },
    {
      "Time_Start": 2160.14,
      "Time_End": 2162.14,
      "Text": " We'll trigger the cleanup yoke tool,"
    },
    {
      "Time_Start": 2162.14,
      "Time_End": 2165.14,
      "Text": " repeat the entire process once again until we succeed."
    },
    {
      "Time_Start": 2167.14,
      "Time_End": 2171.14,
      "Text": " So you folks are pretty tired by now, I guess."
    },
    {
      "Time_Start": 2171.14,
      "Time_End": 2173.14,
      "Text": " We've presented a lot of info,"
    },
    {
      "Time_Start": 2173.14,
      "Time_End": 2175.14,
      "Text": " but let's..."
    },
    {
      "Time_Start": 2175.14,
      "Time_End": 2179.14,
      "Text": " but do you have a moment to talk about Linux?"
    },
    {
      "Time_Start": 2179.14,
      "Time_End": 2181.14,
      "Text": " AMI does some pretty..."
    },
    {
      "Time_Start": 2181.14,
      "Time_End": 2185.14,
      "Text": " lets us do some pretty amazing things from user space."
    },
    {
      "Time_Start": 2185.14,
      "Time_End": 2189.14,
      "Text": " Here we open the Linux module,"
    },
    {
      "Time_Start": 2189.14,
      "Time_End": 2191.14,
      "Text": " the kernel module, sorry,"
    },
    {
      "Time_Start": 2191.14,
      "Time_End": 2194.14,
      "Text": " and trigger the mmap syscall"
    },
    {
      "Time_Start": 2194.14,
      "Time_End": 2197.14,
      "Text": " with the..."
    },
    {
      "Time_Start": 2197.14,
      "Time_End": 2200.14,
      "Text": " with the kernel module's file descriptor"
    },
    {
      "Time_Start": 2200.14,
      "Time_End": 2202.14,
      "Text": " to map any physical address."
    },
    {
      "Time_Start": 2202.14,
      "Time_End": 2204.14,
      "Text": " Which is pretty awesome."
    },
    {
      "Time_Start": 2204.14,
      "Time_End": 2207.14,
      "Text": " At this point, we'll have to somehow be able"
    },
    {
      "Time_Start": 2207.14,
      "Time_End": 2211.14,
      "Text": " to generate DMA transactions for our exploit to work."
    },
    {
      "Time_Start": 2211.14,
      "Time_End": 2213.14,
      "Text": " So just as we did on Windows,"
    },
    {
      "Time_Start": 2213.14,
      "Time_End": 2216.14,
      "Text": " we'll simply open a file,"
    },
    {
      "Time_Start": 2216.14,
      "Time_End": 2220.14,
      "Text": " read it to the previously mapped memory,"
    },
    {
      "Time_Start": 2220.14,
      "Time_End": 2223.14,
      "Text": " and hope for the best."
    },
    {
      "Time_Start": 2223.14,
      "Time_End": 2228.14,
      "Text": " From the Linux module's side,"
    },
    {
      "Time_Start": 2228.14,
      "Time_End": 2232.14,
      "Text": " they initialize the mmap attribute"
    },
    {
      "Time_Start": 2232.14,
      "Time_End": 2235.14,
      "Text": " of the file operations struct"
    },
    {
      "Time_Start": 2235.14,
      "Time_End": 2238.14,
      "Text": " with their own function,"
    },
    {
      "Time_Start": 2238.14,
      "Time_End": 2240.14,
      "Text": " which does..."
    },
    {
      "Time_Start": 2240.14,
      "Time_End": 2243.14,
      "Text": " which actually does the virtual to physical"
    },
    {
      "Time_Start": 2243.14,
      "Time_End": 2246.14,
      "Text": " to virtual mapping using the remap BFN range,"
    },
    {
      "Time_Start": 2246.14,
      "Time_End": 2248.14,
      "Text": " which is pretty straightforward."
    },
    {
      "Time_Start": 2248.14,
      "Time_End": 2250.14,
      "Text": " It gets a physical address"
    },
    {
      "Time_Start": 2250.14,
      "Time_End": 2253.14,
      "Text": " and returns a user-accessible virtual address."
    },
    {
      "Time_Start": 2253.14,
      "Time_End": 2256.14,
      "Text": " But there are some bad news."
    },
    {
      "Time_Start": 2256.14,
      "Time_End": 2258.14,
      "Text": " When we execute this code,"
    },
    {
      "Time_Start": 2258.14,
      "Time_End": 2260.14,
      "Text": " we get an e-fault."
    },
    {
      "Time_Start": 2260.14,
      "Time_End": 2263.14,
      "Text": " And the reason for that is"
    },
    {
      "Time_Start": 2263.14,
      "Time_End": 2266.14,
      "Text": " in the way remap BFN range works."
    },
    {
      "Time_Start": 2266.14,
      "Time_End": 2268.14,
      "Text": " When running this function,"
    },
    {
      "Time_Start": 2268.14,
      "Time_End": 2271.14,
      "Text": " page ranges are managed without struct page,"
    },
    {
      "Time_Start": 2271.14,
      "Time_End": 2273.14,
      "Text": " just pure BFN."
    },
    {
      "Time_Start": 2273.14,
      "Time_End": 2276.14,
      "Text": " Simply put, this will not work."
    },
    {
      "Time_Start": 2276.14,
      "Time_End": 2280.14,
      "Text": " No DMA transactions will be generated here."
    },
    {
      "Time_Start": 2280.14,
      "Time_End": 2283.14,
      "Text": " However, we have the ability"
    },
    {
      "Time_Start": 2283.14,
      "Time_End": 2286.14,
      "Text": " to map any physical address."
    },
    {
      "Time_Start": 2286.14,
      "Time_End": 2289.14,
      "Text": " Any physical address."
    },
    {
      "Time_Start": 2289.14,
      "Time_End": 2291.14,
      "Text": " So let's take the code from before,"
    },
    {
      "Time_Start": 2291.14,
      "Time_End": 2294.14,
      "Text": " and instead of mapping some arbitrary physical address,"
    },
    {
      "Time_Start": 2294.14,
      "Time_End": 2297.14,
      "Text": " let's map, for instance, the address of the Linux kernel"
    },
    {
      "Time_Start": 2297.14,
      "Time_End": 2301.14,
      "Text": " or a kernel module."
    },
    {
      "Time_Start": 2301.14,
      "Time_End": 2305.14,
      "Text": " At this point that we have the user-accessible mapping,"
    },
    {
      "Time_Start": 2305.14,
      "Time_End": 2309.14,
      "Text": " we will be able to patch ring zero code"
    },
    {
      "Time_Start": 2309.14,
      "Time_End": 2312.14,
      "Text": " and gain code execution in kernel."
    },
    {
      "Time_Start": 2313.14,
      "Time_End": 2316.14,
      "Text": " And which is pretty awesome,"
    },
    {
      "Time_Start": 2316.14,
      "Time_End": 2319.14,
      "Text": " but it sounds kind of familiar, right?"
    },
    {
      "Time_Start": 2319.14,
      "Time_End": 2324.14,
      "Text": " Do we remember how we generated DMA transactions from kernel?"
    },
    {
      "Time_Start": 2324.14,
      "Time_End": 2328.14,
      "Text": " So now that we have all three bullets"
    },
    {
      "Time_Start": 2328.14,
      "Time_End": 2330.14,
      "Text": " working from ring three,"
    },
    {
      "Time_Start": 2330.14,
      "Time_End": 2333.14,
      "Text": " we have a full exploitation chain"
    },
    {
      "Time_Start": 2333.14,
      "Time_End": 2336.14,
      "Text": " from user land to SMM,"
    },
    {
      "Time_Start": 2336.14,
      "Time_End": 2338.14,
      "Text": " which concludes our journey."
    },
    {
      "Time_Start": 2338.14,
      "Time_End": 2344.14,
      "Text": " We first got the ability to write to the SMRAM."
    },
    {
      "Time_Start": 2344.14,
      "Time_End": 2349.14,
      "Text": " Then we tried to leverage it into code execution in SMM"
    },
    {
      "Time_Start": 2349.14,
      "Time_End": 2352.14,
      "Text": " using the S3 boot script,"
    },
    {
      "Time_Start": 2352.14,
      "Time_End": 2355.14,
      "Text": " and we failed spectacularly."
    },
    {
      "Time_Start": 2355.14,
      "Time_End": 2360.14,
      "Text": " And we successfully ran unauthorized code in SMM"
    },
    {
      "Time_Start": 2360.14,
      "Time_End": 2365.14,
      "Text": " using and abusing the SMBase relocation technique."
    },
    {
      "Time_Start": 2365.14,
      "Time_End": 2370.14,
      "Text": " And lastly, we elevated the attack to work from user land,"
    },
    {
      "Time_Start": 2370.14,
      "Time_End": 2376.14,
      "Text": " and thus we managed to hop from user space to SMM."
    },
    {
      "Time_Start": 2376.14,
      "Time_End": 2378.14,
      "Text": " We were Jonathan and Benny."
    },
    {
      "Time_Start": 2378.14,
      "Time_End": 2381.14,
      "Text": " Thank you so much for taking part in this journey."
    },
    {
      "Time_Start": 2381.14,
      "Time_End": 2384.14,
      "Text": " Thank you for having me."
    }
  ]
}