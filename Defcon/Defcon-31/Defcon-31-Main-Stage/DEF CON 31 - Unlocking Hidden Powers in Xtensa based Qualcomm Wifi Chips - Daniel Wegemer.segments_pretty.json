{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 9.6,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Hey, thanks everybody for showing up so early."
    },
    {
      "Time_Start": 9.6,
      "Time_End": 17.2,
      "Text": " So yeah, I talk about extensor-based Qualcomm Wi-Fi chips, and so why even looking at Wi-Fi"
    },
    {
      "Time_Start": 17.2,
      "Time_End": 18.2,
      "Text": " chips?"
    },
    {
      "Time_Start": 18.2,
      "Time_End": 23.2,
      "Text": " So in my opinion, these Wi-Fi chips are pretty powerful chips, so even though they are just"
    },
    {
      "Time_Start": 23.2,
      "Time_End": 31.240000000000002,
      "Text": " intended to do your Wi-Fi stuff, they are still general purpose CPUs, so you in theory"
    },
    {
      "Time_Start": 31.240000000000002,
      "Time_End": 37.0,
      "Text": " can run any software on it, but the problem is the proprietary binaries which come with"
    },
    {
      "Time_Start": 37.0,
      "Time_End": 41.68,
      "Text": " those chips, they make it difficult to run your own code."
    },
    {
      "Time_Start": 41.68,
      "Time_End": 44.76,
      "Text": " And why would we even want to run our own code?"
    },
    {
      "Time_Start": 44.76,
      "Time_End": 52.8,
      "Text": " So what we could do is enable additional functionality, I have a few examples in a few seconds."
    },
    {
      "Time_Start": 52.800000000000004,
      "Time_End": 60.400000000000006,
      "Text": " And we could also make security research easier, so in case we manage to enable dynamic"
    },
    {
      "Time_Start": 60.400000000000006,
      "Time_End": 69.88000000000001,
      "Text": " analysis, security researchers have it easier to identify bugs and report them to the vendors."
    },
    {
      "Time_Start": 69.88000000000001,
      "Time_End": 77.96000000000001,
      "Text": " So some examples for additional features which we want to enable is for example, we can enable"
    },
    {
      "Time_Start": 77.96000000000001,
      "Time_End": 81.68,
      "Text": " monitor mode on chips which is not available by default."
    },
    {
      "Time_Start": 81.68,
      "Time_End": 87.16000000000001,
      "Text": " For example, this is monitor mode on a Qualcomm-based chip running on a Nexus 5, which is not available"
    },
    {
      "Time_Start": 87.16000000000001,
      "Time_End": 95.56,
      "Text": " by default, and then you can use your standard Wi-Fi tools like AeroDump and so on."
    },
    {
      "Time_Start": 95.56,
      "Time_End": 104.64000000000001,
      "Text": " We could also build a complete state machine for Berkeley packet filtering inside the firmware,"
    },
    {
      "Time_Start": 104.64000000000001,
      "Time_End": 111.48,
      "Text": " and then compile our rules for packet filtering on the user space, upload them via the kernel"
    },
    {
      "Time_Start": 111.48,
      "Time_End": 114.60000000000001,
      "Text": " to the firmware, and run them directly in the firmware."
    },
    {
      "Time_Start": 114.60000000000001,
      "Time_End": 122.84,
      "Text": " So that way we could save some power when we do monitor mode basically."
    },
    {
      "Time_Start": 122.84,
      "Time_End": 131.24,
      "Text": " And if we have access to even a deeper layer of firmware code, we can also implement stuff"
    },
    {
      "Time_Start": 131.24,
      "Time_End": 133.64000000000001,
      "Text": " which is closer to the physical layer of Wi-Fi."
    },
    {
      "Time_Start": 133.64000000000001,
      "Time_End": 140.24,
      "Text": " So here's an example of a pilot tone jammer, which only jams the pilot tone of OFDM to"
    },
    {
      "Time_Start": 140.24,
      "Time_End": 142.96,
      "Text": " be very power-efficient."
    },
    {
      "Time_Start": 142.96,
      "Time_End": 151.72,
      "Text": " So now that we have all these great goals in mind, let's take a few steps back and look"
    },
    {
      "Time_Start": 151.72,
      "Time_End": 153.96,
      "Text": " at the bigger picture."
    },
    {
      "Time_Start": 153.96,
      "Time_End": 159.28,
      "Text": " So in general there are two kinds of Wi-Fi chips, so full-MAC and soft-MAC chips."
    },
    {
      "Time_Start": 159.28,
      "Time_End": 163.4,
      "Text": " We will look at full-MAC chips in this talk."
    },
    {
      "Time_Start": 163.4,
      "Time_End": 169.12,
      "Text": " The biggest difference is that full-MAC chips run the MAC layer inside the firmware."
    },
    {
      "Time_Start": 169.12,
      "Time_End": 173.6,
      "Text": " So this also means if you want to change something in the firmware, in the MAC layer"
    },
    {
      "Time_Start": 173.6,
      "Time_End": 177.24,
      "Text": " you have to change the firmware directly."
    },
    {
      "Time_Start": 177.24,
      "Time_End": 183.18,
      "Text": " So it's not possible to do these changes on the driver itself."
    },
    {
      "Time_Start": 183.18,
      "Time_End": 190.04000000000002,
      "Text": " So the examples I have shown in the previous slides of stuff which we could want to enable,"
    },
    {
      "Time_Start": 190.04000000000002,
      "Time_End": 195.56,
      "Text": " this was based on the Nexmon framework."
    },
    {
      "Time_Start": 195.56,
      "Time_End": 204.24,
      "Text": " So I developed this together with a colleague of mine back in my time at university."
    },
    {
      "Time_Start": 204.24,
      "Time_End": 212.28,
      "Text": " So this framework will be used to modify Broadcom chips and we even managed to get deep modifications"
    },
    {
      "Time_Start": 212.28,
      "Time_End": 216.32,
      "Text": " working as this jammer I showed earlier."
    },
    {
      "Time_Start": 216.32,
      "Time_End": 219.0,
      "Text": " And you can get it at nexmon.org."
    },
    {
      "Time_Start": 219.0,
      "Time_End": 226.92,
      "Text": " And apart from Broadcom there was also work done on Blackcat 2020 about Intel-based chips"
    },
    {
      "Time_Start": 226.92,
      "Time_End": 233.72,
      "Text": " and there was also a talk about Hexagon-based Qualcomm chips on Defcon 27 and Blackcat 2019."
    },
    {
      "Time_Start": 233.72,
      "Time_End": 241.64,
      "Text": " But this talk is the first talk to explain extensor-based Qualcomm Wi-Fi firmware."
    },
    {
      "Time_Start": 241.64000000000001,
      "Time_End": 249.04000000000002,
      "Text": " So some background, how are Wi-Fi SOCs structured?"
    },
    {
      "Time_Start": 249.04000000000002,
      "Time_End": 256.96000000000004,
      "Text": " So normally you have an application core and then separately you have your Wi-Fi core."
    },
    {
      "Time_Start": 256.96000000000004,
      "Time_End": 264.12,
      "Text": " And optionally in some cases you also have a real-time core which handles time-critical"
    },
    {
      "Time_Start": 264.12,
      "Time_End": 270.8,
      "Text": " stuff like the distributed coordination function in Wi-Fi."
    },
    {
      "Time_Start": 270.96000000000004,
      "Time_End": 278.12,
      "Text": " And now for the chip which we will look at, there are several drivers available."
    },
    {
      "Time_Start": 278.12,
      "Time_End": 284.64,
      "Text": " So there's ADH-10K by Qualcomm directly and also a corresponding firmware with that."
    },
    {
      "Time_Start": 284.64,
      "Time_End": 288.76,
      "Text": " And then there's ADH-10K-CT by Candela Tech."
    },
    {
      "Time_Start": 288.76,
      "Time_End": 289.92,
      "Text": " So this is interesting."
    },
    {
      "Time_Start": 289.92,
      "Time_End": 297.40000000000003,
      "Text": " So Candela Tech bought the rights from Qualcomm some time ago and they have their own driver"
    },
    {
      "Time_Start": 297.40000000000003,
      "Time_End": 298.44,
      "Text": " and their own firmware."
    },
    {
      "Time_Start": 298.48,
      "Time_End": 305.6,
      "Text": " So they got the source code somehow from Qualcomm and added additional features."
    },
    {
      "Time_Start": 305.6,
      "Time_End": 313.12,
      "Text": " And so basically you have a complete separate kind of driver and firmware in addition to"
    },
    {
      "Time_Start": 313.12,
      "Time_End": 316.64,
      "Text": " the original Qualcomm driver and firmware."
    },
    {
      "Time_Start": 316.64,
      "Time_End": 321.56,
      "Text": " And lastly there's also the QCAC-LD driver by Qualcomm."
    },
    {
      "Time_Start": 321.56,
      "Time_End": 325.28,
      "Text": " This is used for factory processes."
    },
    {
      "Time_Start": 325.28000000000003,
      "Time_End": 331.04,
      "Text": " And also what you can do is you can use the Candela Tech driver and run the Qualcomm"
    },
    {
      "Time_Start": 331.04,
      "Time_End": 332.04,
      "Text": " firmware."
    },
    {
      "Time_Start": 332.04,
      "Time_End": 333.96000000000004,
      "Text": " This is also possible."
    },
    {
      "Time_Start": 333.96000000000004,
      "Time_End": 338.38000000000005,
      "Text": " So this is the chip and the board I have looked at."
    },
    {
      "Time_Start": 338.38000000000005,
      "Time_End": 340.76000000000005,
      "Text": " It's the IPQ4019."
    },
    {
      "Time_Start": 340.76000000000005,
      "Time_End": 345.92,
      "Text": " It's based on a development board by 8 devices."
    },
    {
      "Time_Start": 345.92,
      "Time_End": 348.0,
      "Text": " This board is called Habanero."
    },
    {
      "Time_Start": 348.0,
      "Time_End": 354.64000000000004,
      "Text": " And in the middle of it you can see the chip we are interested in."
    },
    {
      "Time_Start": 354.76,
      "Time_End": 359.76,
      "Text": " And this is basically a development board for Wi-Fi enabled home routers."
    },
    {
      "Time_Start": 359.76,
      "Time_End": 365.03999999999996,
      "Text": " So what does this chip look like from the inside?"
    },
    {
      "Time_Start": 365.03999999999996,
      "Time_End": 371.08,
      "Text": " So as I said, this is used for Wi-Fi enabled home routers."
    },
    {
      "Time_Start": 371.08,
      "Time_End": 373.56,
      "Text": " And one of the big vendors in Germany is also using it."
    },
    {
      "Time_Start": 373.56,
      "Time_End": 376.64,
      "Text": " So this is AVM, the Fritzbox."
    },
    {
      "Time_Start": 376.64,
      "Time_End": 383.36,
      "Text": " And apart from this, the chip consists of, as I explained before, also of an application"
    },
    {
      "Time_Start": 383.36,
      "Time_End": 385.28000000000003,
      "Text": " core and multiple Wi-Fi cores."
    },
    {
      "Time_Start": 385.28000000000003,
      "Time_End": 391.28000000000003,
      "Text": " And the application core runs on OpenWRT, in this case, with a pretty old kernel."
    },
    {
      "Time_Start": 391.28000000000003,
      "Time_End": 396.52000000000004,
      "Text": " And for Wi-Fi they have one core for 2.4 gigahertz and one for 5 gigahertz."
    },
    {
      "Time_Start": 396.52000000000004,
      "Time_End": 402.0,
      "Text": " And they use PCIe to communicate with each other."
    },
    {
      "Time_Start": 402.0,
      "Time_End": 405.44,
      "Text": " So now to the firmware itself."
    },
    {
      "Time_Start": 405.44,
      "Time_End": 408.72,
      "Text": " As I said, it's Extensa-based firmware."
    },
    {
      "Time_Start": 408.72,
      "Time_End": 419.92,
      "Text": " Extensa was initially developed by Tensilica, but now it was bought by Cadence."
    },
    {
      "Time_Start": 419.92,
      "Time_End": 423.52000000000004,
      "Text": " And it's a little-endian firmware."
    },
    {
      "Time_Start": 423.52000000000004,
      "Time_End": 427.56,
      "Text": " It consists of a ROM part and a RAM part."
    },
    {
      "Time_Start": 427.56,
      "Time_End": 433.92,
      "Text": " The RAM part of this firmware is stored in the file system of the OpenWRT."
    },
    {
      "Time_Start": 433.92,
      "Time_End": 437.08000000000004,
      "Text": " And it contains multiple segments, more on that later."
    },
    {
      "Time_Start": 437.08,
      "Time_End": 439.8,
      "Text": " And it's LC77 compressed."
    },
    {
      "Time_Start": 439.8,
      "Time_End": 441.8,
      "Text": " The ROM can be patched."
    },
    {
      "Time_Start": 441.8,
      "Time_End": 450.44,
      "Text": " And there's also a code swap mechanism, which allows the Wi-Fi core to evict code from its"
    },
    {
      "Time_Start": 450.44,
      "Time_End": 453.32,
      "Text": " own memory space to the host memory space."
    },
    {
      "Time_Start": 453.32,
      "Time_End": 455.2,
      "Text": " And of course, there's no security enabled by default."
    },
    {
      "Time_Start": 455.2,
      "Time_End": 461.4,
      "Text": " So no secure boot, no stack can erase, no address randomization."
    },
    {
      "Time_Start": 461.40000000000003,
      "Time_End": 466.28000000000003,
      "Text": " What's also nice is that there is already, by default, there comes this debugfs, which"
    },
    {
      "Time_Start": 466.28000000000003,
      "Time_End": 469.08000000000004,
      "Text": " you can compile into your driver."
    },
    {
      "Time_Start": 469.08000000000004,
      "Time_End": 475.72,
      "Text": " And this allows you to get direct memory access via this memvalue file."
    },
    {
      "Time_Start": 475.72,
      "Time_End": 479.92,
      "Text": " So you can directly read and write memory directly into the chip."
    },
    {
      "Time_Start": 479.92,
      "Time_End": 486.32000000000005,
      "Text": " There's also a debugmask, which is very useful, which you can set, for example, during initialization"
    },
    {
      "Time_Start": 486.4,
      "Time_End": 491.4,
      "Text": " of the kernel module to increase the verbosity of the driver itself."
    },
    {
      "Time_Start": 491.4,
      "Time_End": 498.28,
      "Text": " Now, so the interfaces which are used between basically the application core and the Wi-Fi"
    },
    {
      "Time_Start": 498.28,
      "Time_End": 499.28,
      "Text": " core."
    },
    {
      "Time_Start": 499.28,
      "Time_End": 505.2,
      "Text": " So there are two interfaces, the PMI interface, the bootloader management and messaging interface"
    },
    {
      "Time_Start": 505.2,
      "Time_End": 506.76,
      "Text": " is used during bootup."
    },
    {
      "Time_Start": 506.76,
      "Time_End": 508.03999999999996,
      "Text": " And it's implemented in ROM."
    },
    {
      "Time_Start": 508.03999999999996,
      "Time_End": 512.2,
      "Text": " So basically during bootup, this is used to start up the chip."
    },
    {
      "Time_Start": 512.2,
      "Time_End": 518.36,
      "Text": " And then after bootup, the WMI is used to communicate with the chip."
    },
    {
      "Time_Start": 518.36,
      "Time_End": 524.1600000000001,
      "Text": " And this is mostly done to send commands like, please now start Wi-Fi scanning, do channel"
    },
    {
      "Time_Start": 524.1600000000001,
      "Time_End": 527.9200000000001,
      "Text": " configuration, stuff like that."
    },
    {
      "Time_Start": 527.9200000000001,
      "Time_End": 529.72,
      "Text": " So this is how the loading looks like."
    },
    {
      "Time_Start": 529.72,
      "Time_End": 538.32,
      "Text": " So the driver offers two methods for loading firmware, either via the BMI method or via"
    },
    {
      "Time_Start": 538.32,
      "Time_End": 540.12,
      "Text": " a copy engine."
    },
    {
      "Time_Start": 540.12,
      "Time_End": 545.88,
      "Text": " And because in our case we have a compressed firmware, we need to use the BMI method."
    },
    {
      "Time_Start": 545.88,
      "Time_End": 551.2,
      "Text": " And what's basically happening is that the firmware from the file system is passed through"
    },
    {
      "Time_Start": 551.2,
      "Time_End": 560.04,
      "Text": " the driver via BMI to the Wi-Fi core and is then uncompressed on the Wi-Fi core itself."
    },
    {
      "Time_Start": 560.04,
      "Time_End": 564.52,
      "Text": " So this is the file structure of the firmware file."
    },
    {
      "Time_Start": 564.52,
      "Time_End": 570.4399999999999,
      "Text": " So basically there are two big parts, like this upper one and this lower one."
    },
    {
      "Time_Start": 570.4399999999999,
      "Time_End": 573.4,
      "Text": " They are identified with an IE header."
    },
    {
      "Time_Start": 573.4,
      "Time_End": 577.4399999999999,
      "Text": " And then after this, there is the segment header."
    },
    {
      "Time_Start": 577.4399999999999,
      "Time_End": 581.0799999999999,
      "Text": " And this is identified with these metric values here."
    },
    {
      "Time_Start": 581.0799999999999,
      "Time_End": 585.84,
      "Text": " It will tell you if it's compressed or not, and on which address it should be loaded into"
    },
    {
      "Time_Start": 585.84,
      "Time_End": 586.84,
      "Text": " the chip."
    },
    {
      "Time_Start": 586.84,
      "Time_End": 591.1999999999999,
      "Text": " And it will also tell you what's the decompressed size of this segment."
    },
    {
      "Time_Start": 591.2,
      "Time_End": 599.0400000000001,
      "Text": " And if you notice already, in this case, the first part and the second part have the"
    },
    {
      "Time_Start": 599.0400000000001,
      "Time_End": 604.84,
      "Text": " same address, so this means that they get overwritten."
    },
    {
      "Time_Start": 604.84,
      "Time_End": 612.1600000000001,
      "Text": " And then, apart from the segment header, there's also some metadata, as I just explained."
    },
    {
      "Time_Start": 612.1600000000001,
      "Time_End": 615.32,
      "Text": " And after this, the real data starts, and then it's compressed."
    },
    {
      "Time_Start": 615.32,
      "Time_End": 620.44,
      "Text": " And after this, the next metadata starts in the next part, which is then also of the firmware"
    },
    {
      "Time_Start": 620.44,
      "Time_End": 623.7600000000001,
      "Text": " data, which is also compressed."
    },
    {
      "Time_Start": 623.7600000000001,
      "Time_End": 631.72,
      "Text": " So basically, why these two separate parts is, my assumption is that the first part is"
    },
    {
      "Time_Start": 631.72,
      "Time_End": 640.8000000000001,
      "Text": " just needed for boot up, and you can also see it's much smaller in size than the second"
    },
    {
      "Time_Start": 640.8000000000001,
      "Time_End": 641.8000000000001,
      "Text": " part."
    },
    {
      "Time_Start": 641.8000000000001,
      "Time_End": 647.48,
      "Text": " And after this, we can basically override it with the real firmware code."
    },
    {
      "Time_Start": 647.52,
      "Time_End": 653.6800000000001,
      "Text": " And if you look at the driver logs, you will see this whole process being done twice."
    },
    {
      "Time_Start": 653.6800000000001,
      "Time_End": 661.5600000000001,
      "Text": " And I assume this is done to load up the first Wi-Fi core and the second Wi-Fi core."
    },
    {
      "Time_Start": 661.5600000000001,
      "Time_End": 666.84,
      "Text": " If you look at the memory layout, we can see that it's repeating."
    },
    {
      "Time_Start": 666.84,
      "Time_End": 674.88,
      "Text": " So if you just do a long enough read of your address space, you will see these patterns."
    },
    {
      "Time_Start": 674.88,
      "Time_End": 682.12,
      "Text": " And my assumption is that this is used to realize different memory access rights."
    },
    {
      "Time_Start": 682.12,
      "Time_End": 687.8,
      "Text": " So you can have the same memory on different offsets, and depending on offset, you can"
    },
    {
      "Time_Start": 687.8,
      "Time_End": 691.28,
      "Text": " realize different access rights."
    },
    {
      "Time_Start": 691.28,
      "Time_End": 696.36,
      "Text": " Then to the extensor architecture."
    },
    {
      "Time_Start": 696.36,
      "Time_End": 703.76,
      "Text": " So there are two major things I want to point out about this architecture, which were new"
    },
    {
      "Time_Start": 703.84,
      "Time_End": 709.3199999999999,
      "Text": " to me and which also came with some problems."
    },
    {
      "Time_Start": 709.3199999999999,
      "Time_End": 712.28,
      "Text": " So the first one is the use of literal pools."
    },
    {
      "Time_Start": 712.28,
      "Time_End": 718.12,
      "Text": " So each load instruction, so this is just a load instruction, instead of being PC dependent,"
    },
    {
      "Time_Start": 718.12,
      "Time_End": 723.76,
      "Text": " it's basically independent of that, and you just calculate an offset to a fixed literal"
    },
    {
      "Time_Start": 723.76,
      "Time_End": 728.28,
      "Text": " base to get an immediate value."
    },
    {
      "Time_Start": 728.92,
      "Time_End": 741.0799999999999,
      "Text": " In addition to that, there is also windowed registers, and so this means that that way"
    },
    {
      "Time_Start": 741.0799999999999,
      "Time_End": 747.9599999999999,
      "Text": " I explained it in a second, but what it's used for is basically to not needing to store"
    },
    {
      "Time_Start": 747.9599999999999,
      "Time_End": 752.64,
      "Text": " and to save and restore your registers when you call a function."
    },
    {
      "Time_Start": 752.64,
      "Time_End": 760.28,
      "Text": " So here in this example, it's using call 8, so there can be different values here,"
    },
    {
      "Time_Start": 760.28,
      "Time_End": 769.64,
      "Text": " or 4 or 12 or whatever, but my firmware used call 8, and if you load a value in A10 and"
    },
    {
      "Time_Start": 769.64,
      "Time_End": 776.24,
      "Text": " you call a function, it will be available in A2 of the callee."
    },
    {
      "Time_Start": 776.24,
      "Time_End": 779.88,
      "Text": " So this is how these window registers look like."
    },
    {
      "Time_Start": 779.88,
      "Time_End": 787.2,
      "Text": " So basically you have these overlapping sections in your memory space, and you have way more"
    },
    {
      "Time_Start": 787.2,
      "Time_End": 793.56,
      "Text": " registers than you need for one function, and that way they can just shift the window"
    },
    {
      "Time_Start": 793.56,
      "Time_End": 802.76,
      "Text": " for each function call, if you have nested functions, and they can basically just rename"
    },
    {
      "Time_Start": 802.76,
      "Time_End": 809.2,
      "Text": " it and make it accessible to the next function."
    },
    {
      "Time_Start": 809.2,
      "Time_End": 816.12,
      "Text": " This is how literal pools work, so now the memory space is horizontal, so assume we have"
    },
    {
      "Time_Start": 816.12,
      "Time_End": 827.96,
      "Text": " a function myPatch which wants to call a function wlanMain, so the assembler for this will look"
    },
    {
      "Time_Start": 827.96,
      "Time_End": 833.2800000000001,
      "Text": " like there's first a load instruction which loads intermediate value into a register,"
    },
    {
      "Time_Start": 833.28,
      "Time_End": 840.76,
      "Text": " and then the call is just using this register to call the function, and if we want to get"
    },
    {
      "Time_Start": 840.76,
      "Time_End": 847.92,
      "Text": " this immediate value, we need to know the literal base, and then we can look up the"
    },
    {
      "Time_Start": 847.92,
      "Time_End": 853.72,
      "Text": " offset for this function we want to call, wlanMain in this case, and then we get the"
    },
    {
      "Time_Start": 853.72,
      "Time_End": 858.24,
      "Text": " actual address of the function, so for example here."
    },
    {
      "Time_Start": 858.24,
      "Time_End": 861.8,
      "Text": " And this is done for each load instruction."
    },
    {
      "Time_Start": 861.8000000000001,
      "Time_End": 868.6800000000001,
      "Text": " So what's also the case is that this literal base needs to be set up somewhere, and this"
    },
    {
      "Time_Start": 868.6800000000001,
      "Time_End": 874.08,
      "Text": " is usually done at the very beginning of the firmware, and this is a fixed value, so for"
    },
    {
      "Time_Start": 874.08,
      "Time_End": 884.1200000000001,
      "Text": " me it was 0x48001, and this is the code, how it looks like, so you basically have the start"
    },
    {
      "Time_Start": 884.1200000000001,
      "Time_End": 890.2800000000001,
      "Text": " of this literal pool and its size, and then you store it into A2 and write this to the"
    },
    {
      "Time_Start": 890.28,
      "Time_End": 896.92,
      "Text": " special register base, and so actually the offsets are negative, this is why you add"
    },
    {
      "Time_Start": 896.92,
      "Time_End": 905.1999999999999,
      "Text": " the whole size to it and then a load instruction later on will have a negative offset."
    },
    {
      "Time_Start": 905.1999999999999,
      "Time_End": 911.52,
      "Text": " So basically the existing firmware does expect that this literal pool is used, so if we want,"
    },
    {
      "Time_Start": 911.52,
      "Time_End": 918.9599999999999,
      "Text": " and this has some, this comes with some problems if you want to patch existing code."
    },
    {
      "Time_Start": 918.96,
      "Time_End": 924.8000000000001,
      "Text": " Another problem was that this lit base is not supported by disassemblers, so for example"
    },
    {
      "Time_Start": 924.8000000000001,
      "Time_End": 935.5600000000001,
      "Text": " IDA77 added support for Extensa but has ignored the lit base call, for JITRA there is an Extensa"
    },
    {
      "Time_Start": 935.5600000000001,
      "Time_End": 943.32,
      "Text": " plugin but it didn't support lit base either, RADAR2 ignored lit base, has support for Extensa,"
    },
    {
      "Time_Start": 943.32,
      "Time_End": 949.88,
      "Text": " and there's also a Binary Ninja plugin but it ignored lit base as well."
    },
    {
      "Time_Start": 949.88,
      "Time_End": 956.84,
      "Text": " So what I need to do is create some patches for Binary Ninja in this case, so in this"
    },
    {
      "Time_Start": 956.84,
      "Time_End": 965.4000000000001,
      "Text": " patch I just ignore the dependency of the program counter and directly use this fixed"
    },
    {
      "Time_Start": 965.4000000000001,
      "Time_End": 966.96,
      "Text": " lit base."
    },
    {
      "Time_Start": 966.96,
      "Time_End": 971.96,
      "Text": " And I have a similar, so this is the patch for Binary Ninja and there's also, this is"
    },
    {
      "Time_Start": 971.96,
      "Time_End": 981.12,
      "Text": " the patch for JITRA which works the same way, and I have a link to a Git repository"
    },
    {
      "Time_Start": 981.12,
      "Time_End": 985.8000000000001,
      "Text": " later on where you can find these patches."
    },
    {
      "Time_Start": 985.8000000000001,
      "Time_End": 992.0,
      "Text": " So now if you actually want to change some code in the firmware I decided to use the"
    },
    {
      "Time_Start": 992.0,
      "Time_End": 999.56,
      "Text": " Nexmon framework I have shown earlier and I wanted to basically modify it to support"
    },
    {
      "Time_Start": 999.56,
      "Time_End": 1004.52,
      "Text": " Qualcomm based WiFi chips."
    },
    {
      "Time_Start": 1004.52,
      "Time_End": 1014.58,
      "Text": " So this is how the framework looks like, it's pretty complicated but we only need a subset"
    },
    {
      "Time_Start": 1014.58,
      "Time_End": 1016.56,
      "Text": " of this to make it work."
    },
    {
      "Time_Start": 1016.56,
      "Time_End": 1021.92,
      "Text": " So what we could do with the original Nexmon was we could extract the ROM, flash patches,"
    },
    {
      "Time_Start": 1021.9200000000001,
      "Time_End": 1028.96,
      "Text": " the RAM, the U-code for Qualcomm based WiFi chips and we could use C to write our patches"
    },
    {
      "Time_Start": 1028.96,
      "Time_End": 1034.76,
      "Text": " and of course we could call existing firmware functions and then in the end with this whole"
    },
    {
      "Time_Start": 1034.76,
      "Time_End": 1039.8400000000001,
      "Text": " framework we were able to create a firmware file which we could then run on Qualcomm based"
    },
    {
      "Time_Start": 1039.8400000000001,
      "Time_End": 1042.48,
      "Text": " WiFi chips."
    },
    {
      "Time_Start": 1042.48,
      "Time_End": 1046.96,
      "Text": " So how does this Nexmon framework work on a high level?"
    },
    {
      "Time_Start": 1046.96,
      "Time_End": 1057.1200000000001,
      "Text": " So we have our own patches which are in patch.c, we have wrapper.c which is used to have some"
    },
    {
      "Time_Start": 1057.1200000000001,
      "Time_End": 1064.16,
      "Text": " stubs for the functions which are already existing in the firmware and we use GCC and"
    },
    {
      "Time_Start": 1064.16,
      "Time_End": 1073.52,
      "Text": " the GCC plugin to compile the .o files and also the plugin will help to create this Nexmon.pre"
    },
    {
      "Time_Start": 1073.52,
      "Time_End": 1080.92,
      "Text": " file and this Nexmon.pre file basically contains some metadata which we use later on and for"
    },
    {
      "Time_Start": 1080.92,
      "Time_End": 1086.2,
      "Text": " example we can use this file with an org script to create some linker scripts and then we"
    },
    {
      "Time_Start": 1086.2,
      "Time_End": 1090.96,
      "Text": " can use the linker scripts and the .o file to create an overall patch file."
    },
    {
      "Time_Start": 1090.96,
      "Time_End": 1095.04,
      "Text": " So this patch file basically includes everything which we need."
    },
    {
      "Time_Start": 1095.04,
      "Time_End": 1104.48,
      "Text": " And now after this we can use another make file and the elf file to create basically"
    },
    {
      "Time_Start": 1104.48,
      "Time_End": 1109.28,
      "Text": " a blueprint to copy out the relevant section of this elf file."
    },
    {
      "Time_Start": 1109.28,
      "Time_End": 1118.1599999999999,
      "Text": " So we might not need everything, just the patch we wanted to introduce and some stuff"
    },
    {
      "Time_Start": 1118.1599999999999,
      "Time_End": 1123.6399999999999,
      "Text": " we might want to override in the original function and the original firmware."
    },
    {
      "Time_Start": 1123.64,
      "Time_End": 1130.8000000000002,
      "Text": " So now we have this elf file and this make file which is basically the blueprint for"
    },
    {
      "Time_Start": 1130.8000000000002,
      "Time_End": 1131.8000000000002,
      "Text": " object copy."
    },
    {
      "Time_Start": 1131.8000000000002,
      "Time_End": 1139.3200000000002,
      "Text": " We can copy out the relevant sections and then we can DD them into the firmware binary."
    },
    {
      "Time_Start": 1139.3200000000002,
      "Time_End": 1142.4,
      "Text": " So this is how the original Nexmon worked."
    },
    {
      "Time_Start": 1142.4,
      "Time_End": 1146.5400000000002,
      "Text": " So I needed to do some changes to make it work for Qualcomm."
    },
    {
      "Time_Start": 1146.5400000000002,
      "Time_End": 1153.6200000000001,
      "Text": " So first of all there was no support for decompression, the Qualcomm based firmware had no compression"
    },
    {
      "Time_Start": 1153.6200000000001,
      "Time_End": 1162.3000000000002,
      "Text": " it was just the whole memory, the whole RAM of the chip basically uncompressed."
    },
    {
      "Time_Start": 1162.3000000000002,
      "Time_End": 1166.14,
      "Text": " It also needed to add support for multiple binaries."
    },
    {
      "Time_Start": 1166.14,
      "Time_End": 1173.7800000000002,
      "Text": " So as we have seen earlier the firmware consists of multiple segments and I needed to add support"
    },
    {
      "Time_Start": 1173.7800000000002,
      "Time_End": 1181.0600000000002,
      "Text": " for that and we also needed support for the LIT base I mentioned earlier."
    },
    {
      "Time_Start": 1181.06,
      "Time_End": 1186.1399999999999,
      "Text": " And then if we make this happen what we could do is compile and link our own patches, we"
    },
    {
      "Time_Start": 1186.1399999999999,
      "Time_End": 1193.78,
      "Text": " could patch the second segment I showed earlier and then we can compress it back into the"
    },
    {
      "Time_Start": 1193.78,
      "Time_End": 1201.5,
      "Text": " second segment, add some padding bytes and then write the firmware file basically."
    },
    {
      "Time_Start": 1201.5,
      "Time_End": 1204.22,
      "Text": " So this is the plan."
    },
    {
      "Time_Start": 1204.22,
      "Time_End": 1209.1399999999999,
      "Text": " So I will not explain the decompression, this is pretty straightforward to implement."
    },
    {
      "Time_Start": 1209.22,
      "Time_End": 1213.0200000000002,
      "Text": " I will start with the support for multiple binaries."
    },
    {
      "Time_Start": 1213.0200000000002,
      "Time_End": 1219.7,
      "Text": " So I needed to extend the GCC plugin which creates this metadata file, the Nexmon.pre"
    },
    {
      "Time_Start": 1219.7,
      "Time_End": 1221.98,
      "Text": " file."
    },
    {
      "Time_Start": 1221.98,
      "Time_End": 1228.3400000000001,
      "Text": " So basically what this GCC plugin does, it looks for this attribute in the source code"
    },
    {
      "Time_Start": 1228.3400000000001,
      "Time_End": 1236.5800000000002,
      "Text": " and this attribute tells basically where the code after this goes into the firmware in"
    },
    {
      "Time_Start": 1236.58,
      "Time_End": 1241.3,
      "Text": " which chip this is used and in which firmware version this is used."
    },
    {
      "Time_Start": 1241.3,
      "Time_End": 1247.78,
      "Text": " And I extended this basically to also include the target firmware file."
    },
    {
      "Time_Start": 1247.78,
      "Time_End": 1255.82,
      "Text": " So after compiling where should this go to and which segment of the firmware file should"
    },
    {
      "Time_Start": 1255.82,
      "Time_End": 1258.8999999999999,
      "Text": " this go into."
    },
    {
      "Time_Start": 1258.9,
      "Time_End": 1269.74,
      "Text": " So basically then after we compile everything we have this new Nexmon.pre file and it basically"
    },
    {
      "Time_Start": 1269.74,
      "Time_End": 1275.94,
      "Text": " contains the address which is here where our code should go, it has basically the type,"
    },
    {
      "Time_Start": 1275.94,
      "Time_End": 1280.5400000000002,
      "Text": " so here it's a patch, then if it's a dummy it's basically an existing function in the"
    },
    {
      "Time_Start": 1280.5400000000002,
      "Time_End": 1287.3400000000001,
      "Text": " firmware, the next column is the .o file that this will be compiled into, this is the name"
    },
    {
      "Time_Start": 1287.34,
      "Time_End": 1296.22,
      "Text": " of the text section in the .l file and now we also added the name of this bin file where"
    },
    {
      "Time_Start": 1296.22,
      "Time_End": 1301.58,
      "Text": " the compiled code should later on be copied into the RTD."
    },
    {
      "Time_Start": 1301.58,
      "Time_End": 1308.9399999999998,
      "Text": " So with this I already wanted to compile some patches, so my goal was to use this pretty"
    },
    {
      "Time_Start": 1308.9399999999998,
      "Time_End": 1316.3799999999999,
      "Text": " simple patch, so just jump into some code, into this function and then write 1, 2, 3,"
    },
    {
      "Time_Start": 1316.42,
      "Time_End": 1321.7,
      "Text": " 4 basically into this memory location and then jump to the original code which is WLAN"
    },
    {
      "Time_Start": 1321.7,
      "Time_End": 1323.98,
      "Text": " main in this case."
    },
    {
      "Time_Start": 1323.98,
      "Time_End": 1336.5400000000002,
      "Text": " I could use the ESP32 GCC compiler to compile my stuff and load it into the chip and I used"
    },
    {
      "Time_Start": 1336.5400000000002,
      "Time_End": 1343.2600000000002,
      "Text": " the debugfs which I have shown earlier to check basically after the chip was up if the"
    },
    {
      "Time_Start": 1343.26,
      "Time_End": 1346.94,
      "Text": " memory address has changed accordingly."
    },
    {
      "Time_Start": 1346.94,
      "Time_End": 1357.22,
      "Text": " But this didn't work and the reason is this libbase I explained earlier, so basically"
    },
    {
      "Time_Start": 1357.22,
      "Time_End": 1363.22,
      "Text": " all the load instructions expect this libbase to be set at the very beginning of the firmware"
    },
    {
      "Time_Start": 1363.22,
      "Time_End": 1371.02,
      "Text": " code and so this means like the chip which runs the existing firmware code expects a"
    },
    {
      "Time_Start": 1371.1,
      "Time_End": 1383.22,
      "Text": " load to honour this libbase and I need basically now some way to tell my code either like there"
    },
    {
      "Time_Start": 1383.22,
      "Time_End": 1388.86,
      "Text": " is this existing libbase, please use this and it's like already this filled up."
    },
    {
      "Time_Start": 1388.86,
      "Time_End": 1396.06,
      "Text": " But unfortunately there is like no such parameter existing in GCC so we need to do something"
    },
    {
      "Time_Start": 1396.06,
      "Time_End": 1401.54,
      "Text": " else and I just highlighted here all the load instructions which are problematic,"
    },
    {
      "Time_Start": 1401.54,
      "Time_End": 1410.46,
      "Text": " as I said the offsets are not right, they need to use this libbase."
    },
    {
      "Time_Start": 1410.46,
      "Time_End": 1415.1,
      "Text": " So what we could do as an alternative is just avoid load instructions and handcraft our"
    },
    {
      "Time_Start": 1415.1,
      "Time_End": 1421.3,
      "Text": " assembly ourselves, so we just avoid all the references and have basically no immediate"
    },
    {
      "Time_Start": 1421.3,
      "Time_End": 1427.98,
      "Text": " value so this is obviously not something we want to do in the long run."
    },
    {
      "Time_Start": 1427.98,
      "Time_End": 1433.54,
      "Text": " So I came up with two possible solutions, either as I said earlier we can tell the linker"
    },
    {
      "Time_Start": 1433.54,
      "Time_End": 1440.98,
      "Text": " somehow where the existing libbase is and how full it is or we can use our own libbase"
    },
    {
      "Time_Start": 1440.98,
      "Time_End": 1448.7,
      "Text": " value so I decided to go with the second option, I felt like this is more flexible in the long"
    },
    {
      "Time_Start": 1448.7,
      "Time_End": 1457.5,
      "Text": " run and what this implies is basically that I set the libbase to zero at the entry of"
    },
    {
      "Time_Start": 1457.5,
      "Time_End": 1463.26,
      "Text": " every function, this can be done using the GCC plugin and at the function exit I need"
    },
    {
      "Time_Start": 1463.26,
      "Time_End": 1466.5,
      "Text": " to reset it to its original value."
    },
    {
      "Time_Start": 1466.5,
      "Time_End": 1473.54,
      "Text": " And I needed to do this into the assembler itself because there is this target dependent"
    },
    {
      "Time_Start": 1473.54,
      "Time_End": 1480.02,
      "Text": " feature which is called relaxation, so if you have a call to a function this assembler"
    },
    {
      "Time_Start": 1480.02,
      "Time_End": 1484.8999999999999,
      "Text": " will basically relax this to a load and a call and then we have again a call which is"
    },
    {
      "Time_Start": 1484.8999999999999,
      "Time_End": 1488.34,
      "Text": " problematic."
    },
    {
      "Time_Start": 1488.34,
      "Time_End": 1494.62,
      "Text": " So how does this look like in the assembly, so as I said this relaxation is problematic"
    },
    {
      "Time_Start": 1494.62,
      "Time_End": 1501.3,
      "Text": " and after relaxation we basically have a call extended to two instructions, this load and"
    },
    {
      "Time_Start": 1501.3,
      "Time_End": 1510.22,
      "Text": " this call, and the thing is that in between those two basically we need to reset the libbase"
    },
    {
      "Time_Start": 1510.22,
      "Time_End": 1517.74,
      "Text": " to its original value so that then if I call the existing function that the remaining code"
    },
    {
      "Time_Start": 1517.74,
      "Time_End": 1521.02,
      "Text": " can run as intended."
    },
    {
      "Time_Start": 1521.02,
      "Time_End": 1527.3799999999999,
      "Text": " And it took me a while to find out that I cannot manipulate this behaviour in GCC, it"
    },
    {
      "Time_Start": 1527.38,
      "Time_End": 1532.5800000000002,
      "Text": " needs to be patched in the assembler directly because it's target dependent."
    },
    {
      "Time_Start": 1532.5800000000002,
      "Time_End": 1537.16,
      "Text": " So how does this relaxation look like in the assembler, so basically you have this sort"
    },
    {
      "Time_Start": 1537.16,
      "Time_End": 1543.0200000000002,
      "Text": " of lookup table, on the left hand side it's looking for a pattern like this, so here it's"
    },
    {
      "Time_Start": 1543.0200000000002,
      "Time_End": 1549.18,
      "Text": " looking for a call 8 and if it finds this kind of pattern it will be relaxed to a load"
    },
    {
      "Time_Start": 1549.18,
      "Time_End": 1552.5800000000002,
      "Text": " and a call x8."
    },
    {
      "Time_Start": 1552.98,
      "Time_End": 1562.3,
      "Text": " And what I basically need to do is find a place in the assembler where these built instructions,"
    },
    {
      "Time_Start": 1562.3,
      "Time_End": 1566.74,
      "Text": " so basically the right hand side here, these are called built instructions, where those"
    },
    {
      "Time_Start": 1566.74,
      "Time_End": 1575.1799999999998,
      "Text": " are iterated through and then they're applied and pushed on a stack."
    },
    {
      "Time_Start": 1575.1799999999998,
      "Time_End": 1582.26,
      "Text": " And all I did is basically to look like is the current opcode a call x and was the previous"
    },
    {
      "Time_Start": 1582.26,
      "Time_End": 1588.82,
      "Text": " opcode a load instruction and if this is the case then I can basically add an additional"
    },
    {
      "Time_Start": 1588.82,
      "Time_End": 1595.18,
      "Text": " instruction which will reset the lid base with a WSR instruction."
    },
    {
      "Time_Start": 1595.18,
      "Time_End": 1600.74,
      "Text": " So now that we know all of this and we have patched our assembler we can go back to our"
    },
    {
      "Time_Start": 1600.74,
      "Time_End": 1610.18,
      "Text": " original patching code and we can use this GCC plugin and the patched assembler to compile"
    },
    {
      "Time_Start": 1610.18,
      "Time_End": 1616.98,
      "Text": " this much easier to look at code, which is pretty nice."
    },
    {
      "Time_Start": 1616.98,
      "Time_End": 1620.5,
      "Text": " So this is how the assembly looks like basically."
    },
    {
      "Time_Start": 1620.5,
      "Time_End": 1630.3,
      "Text": " After we have saved our parameters we will save the current lid base into A15, we will"
    },
    {
      "Time_Start": 1630.3,
      "Time_End": 1637.9,
      "Text": " write 0 into A14 and write A14 into the lid base value and then we can do all of our load"
    },
    {
      "Time_Start": 1637.9,
      "Time_End": 1645.5400000000002,
      "Text": " instructions and at the end we reset or we copy back the value which we have stored"
    },
    {
      "Time_Start": 1645.5400000000002,
      "Time_End": 1651.5800000000002,
      "Text": " in A15 into the lid base value before we do the final call out."
    },
    {
      "Time_Start": 1651.5800000000002,
      "Time_End": 1657.02,
      "Text": " So there are still some open problems with this, so this implementation is not very good"
    },
    {
      "Time_Start": 1657.02,
      "Time_End": 1658.02,
      "Text": " obviously."
    },
    {
      "Time_Start": 1658.02,
      "Time_End": 1665.8600000000001,
      "Text": " I take away two registers for the assembler, it would be better to have this based on a"
    },
    {
      "Time_Start": 1665.8600000000001,
      "Time_End": 1669.7,
      "Text": " stack based implementation."
    },
    {
      "Time_Start": 1669.7,
      "Time_End": 1677.94,
      "Text": " Also there is this support of disassemblers which I mentioned earlier, so I have these"
    },
    {
      "Time_Start": 1677.94,
      "Time_End": 1685.3400000000001,
      "Text": " patches but still, for example you cannot use IDA if you want to and also there is no"
    },
    {
      "Time_Start": 1685.3400000000001,
      "Time_End": 1691.5000000000002,
      "Text": " support in this GCC I'm using for naked functions, so this is a problem."
    },
    {
      "Time_Start": 1691.5,
      "Time_End": 1702.46,
      "Text": " So what I do is, you need some way to overwrite an existing call to even get to your patch"
    },
    {
      "Time_Start": 1702.46,
      "Time_End": 1709.46,
      "Text": " and either you are lucky and they are using the literal pool, then you can just overwrite"
    },
    {
      "Time_Start": 1709.46,
      "Time_End": 1713.7,
      "Text": " the value in the literal pool, but if not, if it's a direct call, then you need some"
    },
    {
      "Time_Start": 1713.7,
      "Time_End": 1721.42,
      "Text": " way to compile a call to your own code and you could easily do this with naked functions"
    },
    {
      "Time_Start": 1721.46,
      "Time_End": 1729.74,
      "Text": " but this GCC version, or GCC for Xtensa at least, does not have this option for naked"
    },
    {
      "Time_Start": 1729.74,
      "Time_End": 1732.22,
      "Text": " functions."
    },
    {
      "Time_Start": 1732.22,
      "Time_End": 1739.1000000000001,
      "Text": " And also, what's also missing right now is that there is no text console, so you cannot"
    },
    {
      "Time_Start": 1739.1000000000001,
      "Time_End": 1746.7,
      "Text": " just do a printf and somehow dump this in your host system to do some basic debugging,"
    },
    {
      "Time_Start": 1746.7,
      "Time_End": 1750.18,
      "Text": " but we could implement this ourselves now."
    },
    {
      "Time_Start": 1750.18,
      "Time_End": 1756.46,
      "Text": " So basically, I have this very creative name now for my framework which is called QCAmon"
    },
    {
      "Time_Start": 1756.46,
      "Time_End": 1763.22,
      "Text": " instead of Nexmon, so this is how the folder structure looks like, at the very top you"
    },
    {
      "Time_Start": 1763.22,
      "Time_End": 1770.22,
      "Text": " have some build tools, then the disassembler patches which I mentioned earlier for Jitra"
    },
    {
      "Time_Start": 1770.22,
      "Time_End": 1776.38,
      "Text": " and Banner Ninja and then there is a folder for the original firmwares and a folder for"
    },
    {
      "Time_Start": 1776.38,
      "Time_End": 1779.6200000000001,
      "Text": " our patches which we want to apply."
    },
    {
      "Time_Start": 1779.6200000000001,
      "Time_End": 1788.66,
      "Text": " The build tools contain the patched assembler and GCC and also the GCC plugin."
    },
    {
      "Time_Start": 1788.66,
      "Time_End": 1796.38,
      "Text": " The firmware folder basically contains the original firmware and it already comes with"
    },
    {
      "Time_Start": 1796.38,
      "Time_End": 1802.3000000000002,
      "Text": " a structure which would allow different chips and different firmware versions and there"
    },
    {
      "Time_Start": 1802.3000000000002,
      "Time_End": 1809.42,
      "Text": " is also a makefile which already extracts the relevant parts and decompresses them."
    },
    {
      "Time_Start": 1809.42,
      "Time_End": 1815.14,
      "Text": " And then at the end we have our patch folder which we can use to store our source code"
    },
    {
      "Time_Start": 1815.14,
      "Time_End": 1818.3400000000001,
      "Text": " which we want to introduce into the firmware."
    },
    {
      "Time_Start": 1818.3400000000001,
      "Time_End": 1824.3400000000001,
      "Text": " So now to a brief demo."
    },
    {
      "Time_Start": 1824.3400000000001,
      "Time_End": 1829.98,
      "Text": " So this will basically show the code I had in my slides earlier."
    },
    {
      "Time_Start": 1829.98,
      "Time_End": 1839.8600000000001,
      "Text": " So we just want to set 1, 2, 3, 4 or store 1, 2, 3, 4 into this memory address and then"
    },
    {
      "Time_Start": 1839.8600000000001,
      "Time_End": 1844.7,
      "Text": " jump to the original code and in addition to what I've shown earlier we also need these"
    },
    {
      "Time_Start": 1844.7,
      "Time_End": 1851.14,
      "Text": " two lines to basically have an entry point into our firmware code."
    },
    {
      "Time_Start": 1851.14,
      "Time_End": 1858.8600000000001,
      "Text": " So all I'm doing here is creating basically overwriting stuff in the literal pool to point"
    },
    {
      "Time_Start": 1858.8600000000001,
      "Time_End": 1866.3400000000001,
      "Text": " to my code."
    },
    {
      "Time_Start": 1866.3400000000001,
      "Time_End": 1871.8600000000001,
      "Text": " So everything is prepared in the repository."
    },
    {
      "Time_Start": 1871.8600000000001,
      "Time_End": 1879.9,
      "Text": " You just need to run make and this will already compile the C files and .o files."
    },
    {
      "Time_Start": 1879.9,
      "Time_End": 1885.7400000000002,
      "Text": " It will also compile the wrapper, it will create the linker scripts and create the .elf"
    },
    {
      "Time_Start": 1886.34,
      "Time_End": 1894.5,
      "Text": " and then use this blueprint makefile I mentioned earlier to copy out the relevant parts."
    },
    {
      "Time_Start": 1894.5,
      "Time_End": 1901.54,
      "Text": " Then we can start reassembling the whole firmware file via compressing it, adding some padding"
    },
    {
      "Time_Start": 1901.54,
      "Time_End": 1911.5,
      "Text": " bytes and then basically creating the firmware file how it's expected by the Wi-Fi chip."
    },
    {
      "Time_Start": 1911.5,
      "Time_End": 1922.74,
      "Text": " So here it's called firmware-5.bin and I will now SSH into this board I've shown earlier"
    },
    {
      "Time_Start": 1922.74,
      "Time_End": 1929.46,
      "Text": " and in order to access the debug.fs we first need to set up the WLAN0 interface."
    },
    {
      "Time_Start": 1929.46,
      "Time_End": 1938.18,
      "Text": " Now we can go into the debug.fs and look at the memory location basically without any"
    },
    {
      "Time_Start": 1938.18,
      "Time_End": 1939.18,
      "Text": " modifications."
    },
    {
      "Time_Start": 1940.18,
      "Time_End": 1947.8200000000002,
      "Text": " So for this I can just use dd to copy out the relevant section and use hexdump to look"
    },
    {
      "Time_Start": 1947.8200000000002,
      "Time_End": 1949.94,
      "Text": " at it."
    },
    {
      "Time_Start": 1949.94,
      "Time_End": 1955.26,
      "Text": " So here we see that the first few bytes are not 1, 2, 3, 4."
    },
    {
      "Time_Start": 1955.26,
      "Time_End": 1959.78,
      "Text": " And now we install our modified firmware."
    },
    {
      "Time_Start": 1959.78,
      "Time_End": 1971.98,
      "Text": " Just copy it over via SCP and we will need to remove and add the PCIe driver to apply"
    },
    {
      "Time_Start": 1971.98,
      "Time_End": 1972.98,
      "Text": " the changes."
    },
    {
      "Time_Start": 1972.98,
      "Time_End": 1980.22,
      "Text": " Now we can SSH back into the router, just checking the kernel lock real quick."
    },
    {
      "Time_Start": 1980.22,
      "Time_End": 1984.58,
      "Text": " So here it's already setting up the regulatory domain so this looks quite good so it did"
    },
    {
      "Time_Start": 1984.58,
      "Time_End": 1986.66,
      "Text": " not crash on us."
    },
    {
      "Time_Start": 1986.66,
      "Time_End": 1998.98,
      "Text": " And we can go back into the debug.fs, set up the WLAN0 first, go back to the debug.fs."
    },
    {
      "Time_Start": 1998.98,
      "Time_End": 2006.42,
      "Text": " Then basically we can copy out the same memory location which we just did a second ago and"
    },
    {
      "Time_Start": 2006.42,
      "Time_End": 2010.5,
      "Text": " have a look at it via the hexdump."
    },
    {
      "Time_Start": 2011.5,
      "Time_End": 2022.5,
      "Text": " And as you can see here, we modified two whole bytes, thanks."
    },
    {
      "Time_Start": 2022.5,
      "Time_End": 2030.54,
      "Text": " So with this quick summary and future work, I was able to modify the next one framework"
    },
    {
      "Time_Start": 2030.54,
      "Time_End": 2036.22,
      "Text": " to make it work with the Qualcomm based firmwares."
    },
    {
      "Time_Start": 2036.42,
      "Time_End": 2044.98,
      "Text": " I have a demo patch I have shown, you can get it via this location."
    },
    {
      "Time_Start": 2044.98,
      "Time_End": 2051.7,
      "Text": " There's also the patches for Binary Ninja and GDraw in there, the GCC plugin and already"
    },
    {
      "Time_Start": 2051.7,
      "Time_End": 2060.54,
      "Text": " a pre-compiled version of GCC and also the patched Benutils file for the assembler."
    },
    {
      "Time_Start": 2060.58,
      "Time_End": 2068.86,
      "Text": " So this shows that it's possible to make modifications on Qualcomm based firmwares, there are still"
    },
    {
      "Time_Start": 2068.86,
      "Time_End": 2073.22,
      "Text": " some improvements which I need to do to make modifications even more easier."
    },
    {
      "Time_Start": 2073.22,
      "Time_End": 2080.3,
      "Text": " I also want to look at this production software driver thing I mentioned at the very beginning,"
    },
    {
      "Time_Start": 2080.3,
      "Time_End": 2089.34,
      "Text": " so this QCAC-LD, so this is basically using this QDAL software on a PC to communicate"
    },
    {
      "Time_Start": 2089.46,
      "Time_End": 2096.86,
      "Text": " and you can get it from some sketchy Chinese servers and then I want to see if I can maybe"
    },
    {
      "Time_Start": 2096.86,
      "Time_End": 2103.6600000000003,
      "Text": " enable some features which are used in this production software also by myself and I also"
    },
    {
      "Time_Start": 2103.6600000000003,
      "Time_End": 2108.42,
      "Text": " want to look into this code swap feature a little bit more."
    },
    {
      "Time_Start": 2108.42,
      "Time_End": 2114.98,
      "Text": " So I want to thank Martin Kort aka Problem Kaput, so he did some awesome Game Boy Advance"
    },
    {
      "Time_Start": 2115.1,
      "Time_End": 2121.46,
      "Text": " reverse engineering and he helped me out in some cases, so it turns out that he did not"
    },
    {
      "Time_Start": 2121.46,
      "Time_End": 2128.78,
      "Text": " even reverse engineer the main processor of the Game Boy Advance but also the Wi-Fi chip"
    },
    {
      "Time_Start": 2128.78,
      "Time_End": 2135.5,
      "Text": " used there and this turns out to be an older Atheros based Wi-Fi chip which he also reverse"
    },
    {
      "Time_Start": 2135.5,
      "Time_End": 2141.22,
      "Text": " engineered and Atheros later on was also bought by Qualcomm and I think lots of knowledge"
    },
    {
      "Time_Start": 2141.22,
      "Time_End": 2144.9,
      "Text": " from back there still went into their products."
    },
    {
      "Time_Start": 2144.9,
      "Time_End": 2152.62,
      "Text": " And I also want to thank Roku aka RKNibble, I used her script to do the unzipping of"
    },
    {
      "Time_Start": 2152.62,
      "Time_End": 2155.9,
      "Text": " the firmware file."
    },
    {
      "Time_Start": 2155.9,
      "Time_End": 2165.7000000000003,
      "Text": " That's it from my side, thanks everybody, if you want to reach out, here's my email address."
    },
    {
      "Time_Start": 2165.7000000000003,
      "Time_End": 2169.5,
      "Text": " If you have any questions, shoot."
    },
    {
      "Time_Start": 2169.5,
      "Time_End": 2176.82,
      "Text": " I have also one more note, I have found a firmware file which contains all debug symbols"
    },
    {
      "Time_Start": 2176.82,
      "Time_End": 2184.82,
      "Text": " for this IPQ4019 chip, I have no easy way to distribute this without the original repository"
    },
    {
      "Time_Start": 2184.82,
      "Time_End": 2191.82,
      "Text": " being taken down, but if you want to poke at it yourself, reach out to me, I will send"
    },
    {
      "Time_Start": 2191.82,
      "Time_End": 2197.82,
      "Text": " you the link."
    },
    {
      "Time_Start": 2198.1400000000003,
      "Time_End": 2202.1400000000003,
      "Text": " Any questions?"
    },
    {
      "Time_Start": 2202.1400000000003,
      "Time_End": 2204.1400000000003,
      "Text": " No?"
    },
    {
      "Time_Start": 2204.1400000000003,
      "Time_End": 2206.1400000000003,
      "Text": " Okay then, thanks everybody."
    },
    {
      "Time_Start": 2206.1400000000003,
      "Time_End": 2208.1400000000003,
      "Text": " APPLAUSE"
    }
  ]
}