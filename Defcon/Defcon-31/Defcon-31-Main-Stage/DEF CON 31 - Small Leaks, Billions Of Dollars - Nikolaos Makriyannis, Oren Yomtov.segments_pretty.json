{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 6.0,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Okay, hello. I'm Nikos. I'm a cryptography researcher at Fireblocks. This is Oren. He's a"
    },
    {
      "Time_Start": 12.3,
      "Time_End": 18.3,
      "Text": " security researcher at Fireblocks. And we're here to talk about hacking crypto wallets. So"
    },
    {
      "Time_Start": 20.080000000000002,
      "Time_End": 27.46,
      "Text": " what is a crypto wallet? So let's say you want to spend bitcoin. You need a wallet. That"
    },
    {
      "Time_Start": 27.46,
      "Time_End": 34.34,
      "Text": " wallet holds a key. That key allows you to sign transactions. Those transactions you can"
    },
    {
      "Time_Start": 34.34,
      "Time_End": 40.8,
      "Text": " broadcast to the blockchain and send crypto to your favorite people. There's a problem with"
    },
    {
      "Time_Start": 40.8,
      "Time_End": 46.3,
      "Text": " the setup because there's a single point of failure. The key is sitting in one place, ready"
    },
    {
      "Time_Start": 46.3,
      "Time_End": 52.88,
      "Text": " to be stolen. How can you minimize that risk? You can use multi-party computation, also"
    },
    {
      "Time_Start": 52.92,
      "Time_End": 58.92,
      "Text": " known as MPC. So what is MPC? So at a very high level, the idea is that instead of having one"
    },
    {
      "Time_Start": 60.580000000000005,
      "Time_End": 66.58,
      "Text": " key in one place, the key is split into shares. And those shares reside with different parties."
    },
    {
      "Time_Start": 69.54,
      "Time_End": 76.72,
      "Text": " Actually, MPC promises much more than what the picture suggests because the key is never"
    },
    {
      "Time_Start": 76.76,
      "Time_End": 83.06,
      "Text": " assembled in one place. The parties calculate their shares and the public key via an"
    },
    {
      "Time_Start": 83.06,
      "Time_End": 88.76,
      "Text": " interactive protocol. And then every time they want to sign a transaction, they run a different"
    },
    {
      "Time_Start": 88.76,
      "Time_End": 94.75999999999999,
      "Text": " interactive protocol for calculating the signature. So small aside, MPC is much bigger than"
    },
    {
      "Time_Start": 97.34,
      "Time_End": 103.72,
      "Text": " the use case I just described, which is threshold signatures. It is the crown jewel of modern"
    },
    {
      "Time_Start": 103.72,
      "Time_End": 110.34,
      "Text": " cryptography. Basically, anything you can do with a trusted centralized party, you can do"
    },
    {
      "Time_Start": 110.34,
      "Time_End": 116.34,
      "Text": " trustlessly with MPC. There are numerous examples. I'm not going to go into them. But what I"
    },
    {
      "Time_Start": 118.18,
      "Time_End": 122.92,
      "Text": " will say is that commercial adoption has been a bit slow. MPC has been around since the"
    },
    {
      "Time_Start": 122.92,
      "Time_End": 129.72,
      "Text": " 80s. And the most significant use case before blockchain was the famous Danish sugar beet"
    },
    {
      "Time_Start": 129.72,
      "Time_End": 136.92,
      "Text": " auction of 2008. And since the advent of blockchain, MPC is now protecting billions of"
    },
    {
      "Time_Start": 136.92,
      "Time_End": 143.22,
      "Text": " dollars in cryptocurrency wallets. But we're not here to talk about MPC in itself. We're here"
    },
    {
      "Time_Start": 143.22,
      "Time_End": 148.26,
      "Text": " to hack crypto wallets that are based on MPC. So what would that look like? One thing that"
    },
    {
      "Time_Start": 148.26,
      "Time_End": 152.68,
      "Text": " could happen is a denial of service. Let's say I'm able to freeze your wallet so you can't spend"
    },
    {
      "Time_Start": 152.68,
      "Time_End": 158.34,
      "Text": " your crypto. That's a problem. Something more severe would be signature forgery. Let's say"
    },
    {
      "Time_Start": 158.34,
      "Time_End": 163.5,
      "Text": " Nikos and I, we have an MPC wallet. So every time we want to sign, we sign together. So I"
    },
    {
      "Time_Start": 163.5,
      "Time_End": 169.46,
      "Text": " tell him let's sign this $10 transaction to your favorite charity. He signs it. But because I"
    },
    {
      "Time_Start": 169.46,
      "Time_End": 173.88,
      "Text": " took advantage of some flaw in the protocol, I actually made him sign a totally different"
    },
    {
      "Time_Start": 173.88,
      "Time_End": 178.54,
      "Text": " transaction without him knowing. That's bad. But what's even worse would be private key"
    },
    {
      "Time_Start": 178.54,
      "Time_End": 183.8,
      "Text": " exfiltration. Whereas by him signing that transaction, he leaked his key share to me. And"
    },
    {
      "Time_Start": 183.8,
      "Time_End": 188.42000000000002,
      "Text": " now I can sign whatever I want, whenever I want without his consent. Today's talk will be"
    },
    {
      "Time_Start": 188.42000000000002,
      "Time_End": 194.04000000000002,
      "Text": " focused on this. We're actually going to show you three different attacks that all end with"
    },
    {
      "Time_Start": 194.04000000000002,
      "Time_End": 199.62,
      "Text": " private key exfiltration. When we'll be talking about attacking crypto wallets, MPC crypto"
    },
    {
      "Time_Start": 199.62,
      "Time_End": 203.70000000000002,
      "Text": " wallets, I want you to have this threat model in mind. So these are a bunch of people"
    },
    {
      "Time_Start": 203.70000000000002,
      "Time_End": 207.62,
      "Text": " participating with an MPC wallet together. So each time they want to sign, they need to"
    },
    {
      "Time_Start": 207.62,
      "Time_End": 214.94,
      "Text": " collaborate. Now one of those participants, namely Alice, will be acting maliciously. Now"
    },
    {
      "Time_Start": 214.94,
      "Time_End": 220.20000000000002,
      "Text": " either she woke up one day, decided to be evil, or maybe she was compromised by an attacker"
    },
    {
      "Time_Start": 220.20000000000002,
      "Time_End": 226.32,
      "Text": " and now is using her identity to attack the other people. So whatever her motivation might"
    },
    {
      "Time_Start": 226.32,
      "Time_End": 230.78,
      "Text": " be, she wakes up in the morning, her only goal would be to exfiltrate the other counterparty's"
    },
    {
      "Time_Start": 230.78,
      "Time_End": 236.78,
      "Text": " key shares. And she will do that by signing normal looking transactions with them. So the"
    },
    {
      "Time_Start": 237.52,
      "Time_End": 242.4,
      "Text": " research findings that brought us here today were as followed. We have discovered four novel"
    },
    {
      "Time_Start": 242.4,
      "Time_End": 247.4,
      "Text": " attacks, including three zero days. These findings have affected over 16 different vendors and"
    },
    {
      "Time_Start": 251.06,
      "Time_End": 256.06,
      "Text": " our open source libraries. We'll be releasing at the last slide four fully working proof of"
    },
    {
      "Time_Start": 256.06,
      "Time_End": 261.4,
      "Text": " concept exploits for these attacks we'll be showing you. We actually used the very same"
    },
    {
      "Time_Start": 261.4,
      "Time_End": 266.36,
      "Text": " proof of concept exploits against two vendor production environments and got the private"
    },
    {
      "Time_Start": 266.36,
      "Time_End": 271.14,
      "Text": " keys. And the last thing I want to stress is most of our attacks are not implementation"
    },
    {
      "Time_Start": 271.14,
      "Time_End": 277.6,
      "Text": " specific. We'll be attacking MPC at the protocol level. So the affected parties were"
    },
    {
      "Time_Start": 277.6,
      "Time_End": 282.6,
      "Text": " numerous. Some of the biggest crypto wallets were affected, a number of crypto custodians"
    },
    {
      "Time_Start": 282.6,
      "Time_End": 288.76,
      "Text": " were affected, the most popular consumer MPC wallet was affected, as well as some of the most"
    },
    {
      "Time_Start": 288.76,
      "Time_End": 295.56,
      "Text": " popular open source MPC libraries. The attacks we'll be covering today will start with"
    },
    {
      "Time_Start": 295.88,
      "Time_End": 301.3,
      "Text": " attacking the most popular two party signing protocol. It's called Lindle 17. Carrying out the"
    },
    {
      "Time_Start": 301.3,
      "Time_End": 307.3,
      "Text": " attack will be somewhat high interactivity required. Then we'll go to a second attack. We'll"
    },
    {
      "Time_Start": 308.92,
      "Time_End": 315.42,
      "Text": " attack the most popular multiparty signing protocols, the GG18, GG20 family of protocols. And"
    },
    {
      "Time_Start": 315.42,
      "Time_End": 318.96,
      "Text": " last but not least we'll attack what we call a do it yourself protocol because it doesn't"
    },
    {
      "Time_Start": 318.96,
      "Time_End": 325.46,
      "Text": " really closely adhere to any academic paper. Okay, so before we have a look at the"
    },
    {
      "Time_Start": 326.08,
      "Time_End": 331.96,
      "Text": " exploits we need a few items of background material. The first item in the background is the"
    },
    {
      "Time_Start": 331.96,
      "Time_End": 339.5,
      "Text": " math. Thankfully no math, I mean no advanced math. The only thing, we're not going to be"
    },
    {
      "Time_Start": 339.5,
      "Time_End": 344.85999999999996,
      "Text": " talking about elliptic curves or abstract groups. The only thing you need to know for today"
    },
    {
      "Time_Start": 344.85999999999996,
      "Time_End": 350.2,
      "Text": " is the modulo operator. What is the modulo operator? Well, very simply X modulo N is the"
    },
    {
      "Time_Start": 350.2,
      "Time_End": 357.06,
      "Text": " remainder of X divided by N. For example, 5 modulo 5 is 0 because 5 is divisible by"
    },
    {
      "Time_Start": 357.06,
      "Time_End": 363.32,
      "Text": " itself and 6 modulo 5 is 1 because 6 is greater than 5 and there's overflow and yada yada"
    },
    {
      "Time_Start": 363.32,
      "Time_End": 369.82,
      "Text": " yada. Great. Second item in the background is homomorphic encryption. This is a cool thing. So"
    },
    {
      "Time_Start": 369.82,
      "Time_End": 376.74,
      "Text": " what is it? It is a special kind of encryption that allows computation on encrypted data."
    },
    {
      "Time_Start": 376.74,
      "Time_End": 382.2,
      "Text": " Without decrypting the cipher text, that's very important to note. So for example, let's"
    },
    {
      "Time_Start": 382.2,
      "Time_End": 387.94,
      "Text": " say Alice sends an encryption of the number 42 to Bob. So here and throughout the talk we"
    },
    {
      "Time_Start": 387.94,
      "Time_End": 394.28000000000003,
      "Text": " will be using color coding. Red for values that Alice knows, blue for values that only Bob"
    },
    {
      "Time_Start": 394.28000000000003,
      "Time_End": 400.1,
      "Text": " knows. So Bob receives this thing and he can operate on it. For example, he can multiply by"
    },
    {
      "Time_Start": 400.1,
      "Time_End": 405.90000000000003,
      "Text": " the number 2 and he can add the number 100. He does this obliviously without knowing what's"
    },
    {
      "Time_Start": 405.90000000000003,
      "Time_End": 413.78000000000003,
      "Text": " happening inside the cipher text. Alice, after receiving the resulting cipher text, can"
    },
    {
      "Time_Start": 413.78000000000003,
      "Time_End": 420.90000000000003,
      "Text": " decrypt it and learn the result without ever knowing what Bob exactly did to the cipher text."
    },
    {
      "Time_Start": 420.90000000000003,
      "Time_End": 425.32000000000005,
      "Text": " So there are many kinds of homomorphic encryption. I'm not going to dive into them today but"
    },
    {
      "Time_Start": 425.32000000000005,
      "Time_End": 432.32000000000005,
      "Text": " we will be looking at the most vanilla kind which is parameterized by a public key, N. This"
    },
    {
      "Time_Start": 432.32,
      "Time_End": 439.48,
      "Text": " is a number and it's the product of two big primes. This detail will become relevant later in"
    },
    {
      "Time_Start": 439.48,
      "Time_End": 445.82,
      "Text": " the talk. So the last item in the background is the ECDSA signature scheme. This is the most"
    },
    {
      "Time_Start": 445.82,
      "Time_End": 450.02,
      "Text": " important signature scheme in the blockchain space. It is used by Bitcoin, it is used by"
    },
    {
      "Time_Start": 450.02,
      "Time_End": 456.24,
      "Text": " Ethereum, among other blockchains. And the protocols we'll be looking at implement this"
    },
    {
      "Time_Start": 456.28000000000003,
      "Time_End": 462.2,
      "Text": " scheme. So how do you uh generate an ECDSA signature? It goes something like this. First you"
    },
    {
      "Time_Start": 462.2,
      "Time_End": 468.48,
      "Text": " sample a random number K. This is a secret and it is chosen afresh with each signature. It is"
    },
    {
      "Time_Start": 468.48,
      "Time_End": 474.7,
      "Text": " also called the ephemeral key. Then to calculate the signature, you simply compute a function of"
    },
    {
      "Time_Start": 474.7,
      "Time_End": 481.28000000000003,
      "Text": " the message to be signed, the ephemeral key, the private key, as well as an ECDSA constant that"
    },
    {
      "Time_Start": 481.28000000000003,
      "Time_End": 487.40000000000003,
      "Text": " everybody knows that we denote by L. So that's for one party. What about multi-party? What"
    },
    {
      "Time_Start": 487.40000000000003,
      "Time_End": 492.20000000000005,
      "Text": " about two parties? Well the idea that we've already alluded to at the beginning of the talk is"
    },
    {
      "Time_Start": 492.20000000000005,
      "Time_End": 497.24,
      "Text": " that instead of having the secret material residing in one place, the secret material will be"
    },
    {
      "Time_Start": 497.24,
      "Time_End": 503.32000000000005,
      "Text": " split between the parties. Okay so having covered the background, now we can move on to our"
    },
    {
      "Time_Start": 503.32000000000005,
      "Time_End": 509.44000000000005,
      "Text": " first exploit. We will show you how to compromise the LIDL 17 protocol implementations of the"
    },
    {
      "Time_Start": 509.44,
      "Time_End": 515.86,
      "Text": " LIDL 17 protocol. And uh in order to explain how to compromise it, I need to tell you what the"
    },
    {
      "Time_Start": 515.86,
      "Time_End": 521.32,
      "Text": " protocol is. So it goes something like this. So first there's a key generation phase where the"
    },
    {
      "Time_Start": 521.32,
      "Time_End": 526.32,
      "Text": " parties choose uh random key shares. So that would be X1 for Alice and X2 for Bob. The next step"
    },
    {
      "Time_Start": 529.16,
      "Time_End": 535.32,
      "Text": " in the key generation is for Bob to encrypt his share under a homomorphic scheme that he"
    },
    {
      "Time_Start": 535.36,
      "Time_End": 541.74,
      "Text": " controls. And he sends that encryption to Alice. So he sends an encryption of X2 to Alice. I"
    },
    {
      "Time_Start": 541.74,
      "Time_End": 547.36,
      "Text": " will remind you that only Bob can decrypt this thing but Alice can operate on it. And this is"
    },
    {
      "Time_Start": 547.36,
      "Time_End": 553.08,
      "Text": " going to be important for signing. So before we move on to signing, we need to address the"
    },
    {
      "Time_Start": 553.08,
      "Time_End": 560.12,
      "Text": " elephant in the room. This is a cryptography talk. So there's going to be formulas involved."
    },
    {
      "Time_Start": 560.12,
      "Time_End": 564.74,
      "Text": " But nothing bad is going to happen. Oren will take care of you. Okay so let's have a look at"
    },
    {
      "Time_Start": 564.74,
      "Time_End": 570.66,
      "Text": " signing. Signing goes something like this. So Alice uses the cipher text she receives from"
    },
    {
      "Time_Start": 570.66,
      "Time_End": 576.92,
      "Text": " Bob during the key generation to send an encrypted partial signature to Bob. The partial the"
    },
    {
      "Time_Start": 576.92,
      "Time_End": 582.04,
      "Text": " encrypted partial signature looks something like this. And the only reason I am displaying"
    },
    {
      "Time_Start": 582.04,
      "Time_End": 588.34,
      "Text": " this formula is to show you that we have almost all of the ingredients for the ECDSA signature"
    },
    {
      "Time_Start": 588.34,
      "Time_End": 594.8000000000001,
      "Text": " scheme. We have the X's, we have the message, we have K1, we have the ECDSA constant L. The"
    },
    {
      "Time_Start": 594.8000000000001,
      "Time_End": 599.76,
      "Text": " only thing that's missing is K2. So how do we, how does Bob finalize this thing? So he"
    },
    {
      "Time_Start": 599.76,
      "Time_End": 607.1,
      "Text": " simply decrypts this value, multiplies by his contribution to the ephemeral key, and reduces"
    },
    {
      "Time_Start": 607.1,
      "Time_End": 613.5600000000001,
      "Text": " everything modulo L. At this point, he checks whether this thing is a valid signature. Why"
    },
    {
      "Time_Start": 613.5600000000001,
      "Time_End": 619.32,
      "Text": " does he need to do that? Well he does this because you know, maybe Alice fell asleep while"
    },
    {
      "Time_Start": 619.32,
      "Time_End": 625.12,
      "Text": " during the signing process and she forgot to multiply by her K1. At this point, Bob will fail"
    },
    {
      "Time_Start": 625.12,
      "Time_End": 630.36,
      "Text": " to verify that the signature is valid and Alice will be notified of this either because Bob"
    },
    {
      "Time_Start": 630.36,
      "Time_End": 635.44,
      "Text": " tells her or because the signature never made it to the blockchain. So what happens in this"
    },
    {
      "Time_Start": 635.44,
      "Time_End": 641.5600000000001,
      "Text": " case? Well to answer this question, we consult with the paper the protocol is based on. And"
    },
    {
      "Time_Start": 641.5600000000001,
      "Time_End": 647.4000000000001,
      "Text": " the paper has a very interesting assumption, not assumption, instruction. It says any"
    },
    {
      "Time_Start": 647.4000000000001,
      "Time_End": 652.4000000000001,
      "Text": " abort will result in no, will imply no later execution. Which means that if Bob detects an"
    },
    {
      "Time_Start": 655.94,
      "Time_End": 662.6400000000001,
      "Text": " invalid signature, the wallet must be locked. Putting our adversarial hats on, we see this"
    },
    {
      "Time_Start": 662.6400000000001,
      "Time_End": 666.98,
      "Text": " and we think well, maybe we can leverage this into a denial of service attack. Maybe we can"
    },
    {
      "Time_Start": 666.98,
      "Time_End": 672.7,
      "Text": " act as Alice and send some garbage nonsense partial signature to Bob and now the wallet is"
    },
    {
      "Time_Start": 672.7,
      "Time_End": 677.32,
      "Text": " supposed to be locked, right? So we went on to code this. We found some open source"
    },
    {
      "Time_Start": 677.32,
      "Time_End": 683.32,
      "Text": " implementation of the Lienvendel 17 and we tried to do this. To our surprise, nothing happened."
    },
    {
      "Time_Start": 685.66,
      "Time_End": 691.48,
      "Text": " Basically we tried again and again and the wallet was never locked. So we were kind of"
    },
    {
      "Time_Start": 691.48,
      "Time_End": 696.16,
      "Text": " devastated by our failure to mount some denial of service attack and we went back to the"
    },
    {
      "Time_Start": 696.16,
      "Time_End": 702.3399999999999,
      "Text": " drawing board. We're trying to understand, wait, if this assumption, this instruction is part"
    },
    {
      "Time_Start": 702.3399999999999,
      "Time_End": 707.5,
      "Text": " of the paper, why is it there in the first place? So the paper is actually very clear about"
    },
    {
      "Time_Start": 707.5,
      "Time_End": 713.6999999999999,
      "Text": " why it's important. It says the only problem is that Alice may send an incorrect partial"
    },
    {
      "Time_Start": 713.6999999999999,
      "Time_End": 720.66,
      "Text": " signature to Bob in which case the mere fact that Bob aborts or not can leak a single bit"
    },
    {
      "Time_Start": 720.66,
      "Time_End": 727.04,
      "Text": " about Bob's private share of the key. Now taking this intuition and like taking it to its"
    },
    {
      "Time_Start": 727.04,
      "Time_End": 733.24,
      "Text": " logical conclusion, we might think of a hypothetical attack that looks something like this."
    },
    {
      "Time_Start": 733.24,
      "Time_End": 739.9599999999999,
      "Text": " First Alice would craft a malicious signature that would fail to verify depending on a single"
    },
    {
      "Time_Start": 739.9599999999999,
      "Time_End": 745.78,
      "Text": " bit of Bob's key share and then she will see if it verifies or not. Then she can do this again"
    },
    {
      "Time_Start": 745.78,
      "Time_End": 751.86,
      "Text": " and again and again every time by seeing if the signature verified successfully or not knowing"
    },
    {
      "Time_Start": 751.86,
      "Time_End": 760.16,
      "Text": " if that specific bit is 1 or 0. 256 signatures later, bam, she has the entire key share of"
    },
    {
      "Time_Start": 760.16,
      "Time_End": 766.24,
      "Text": " Bob. She can combine it with her own and sign away without his consent. So this is very easy"
    },
    {
      "Time_Start": 766.24,
      "Time_End": 770.8199999999999,
      "Text": " to do in PowerPoint with pictures but to actually get the math to do this you need a"
    },
    {
      "Time_Start": 770.82,
      "Time_End": 775.7800000000001,
      "Text": " cryptographer like Nikos. So that's where we stopped relying on the paper and we had to"
    },
    {
      "Time_Start": 775.7800000000001,
      "Time_End": 781.58,
      "Text": " think for ourselves. And what we did is we had a long hard look at the partial signature that"
    },
    {
      "Time_Start": 781.58,
      "Time_End": 786.86,
      "Text": " Alice sends to Bob. And we tried to mess around with it. We tried to like, you know, tinker"
    },
    {
      "Time_Start": 786.86,
      "Time_End": 791.44,
      "Text": " with the X. We tried to tinker with the message. Nothing happened. We tried to tinker with"
    },
    {
      "Time_Start": 791.44,
      "Time_End": 798.1600000000001,
      "Text": " the K. Again nothing happened. But then the crypto gods smiled on us because we had the"
    },
    {
      "Time_Start": 798.18,
      "Time_End": 804.12,
      "Text": " following uh, breakthrough. We realized that if Alice switches the modulus, so instead of"
    },
    {
      "Time_Start": 804.12,
      "Time_End": 810.52,
      "Text": " using the L parameter of ECDSA, she uses the N public key of the homomorphic encryption"
    },
    {
      "Time_Start": 810.52,
      "Time_End": 815.54,
      "Text": " scheme. These 2 values are equal after Bob decrypts if and only if X2 modulo K1 is equal to"
    },
    {
      "Time_Start": 818.9,
      "Time_End": 825.48,
      "Text": " 0. So I will spare you the mathematical mumbo jumbo and I will give it to you in a picture."
    },
    {
      "Time_Start": 825.48,
      "Time_End": 831.14,
      "Text": " Basically when Alice switches the modulus, the following thing happens. If the signature is"
    },
    {
      "Time_Start": 831.14,
      "Time_End": 836.38,
      "Text": " valid, X2 is divisible by K1. And I will remind you that K1 is the value that Alice controls"
    },
    {
      "Time_Start": 836.38,
      "Time_End": 841.38,
      "Text": " and she knows. If the signature is invalid, then X2 mod K1 is not equal to 0. And this is,"
    },
    {
      "Time_Start": 844.38,
      "Time_End": 848.64,
      "Text": " this is very good for the attacker because this already gives a way to learn the least"
    },
    {
      "Time_Start": 848.64,
      "Time_End": 854.82,
      "Text": " significant bit. Why? Because Alice can simply set K1 equals 2. In this case she mounts the"
    },
    {
      "Time_Start": 854.82,
      "Time_End": 860.9000000000001,
      "Text": " attack, she switches the modulus, and she obtains leakage X2 modulo 2 equals 0 or not. And"
    },
    {
      "Time_Start": 860.9000000000001,
      "Time_End": 866.2,
      "Text": " this is exactly Bob's least significant bit. Okay, so that's one bit, but what about the rest"
    },
    {
      "Time_Start": 866.2,
      "Time_End": 873.1400000000001,
      "Text": " of them? So for the next bit you can use the next power of 2, namely 4. When you mount the"
    },
    {
      "Time_Start": 873.1400000000001,
      "Time_End": 879.1800000000001,
      "Text": " attack, you obtain leakage whether 4 is, whether X2 is divisible by 4. So this is great"
    },
    {
      "Time_Start": 879.22,
      "Time_End": 884.84,
      "Text": " leakage if X2 is already divisible by 2. Because if not, then the leakage that you actually"
    },
    {
      "Time_Start": 884.84,
      "Time_End": 891.5000000000001,
      "Text": " want is X2 minus 1 is divisible by 4. And to obtain this leakage, well what you need to do"
    },
    {
      "Time_Start": 891.5000000000001,
      "Time_End": 896.2600000000001,
      "Text": " is you need to do some math. You need to massage the algebra. You need to add an offset to"
    },
    {
      "Time_Start": 896.2600000000001,
      "Time_End": 902.5000000000001,
      "Text": " the partial signature in order, an offset that depends on whatever you already know of Bob's"
    },
    {
      "Time_Start": 902.5000000000001,
      "Time_End": 908.6800000000001,
      "Text": " key. And this will give you the leakage that you actually want. So to summarize, in order to"
    },
    {
      "Time_Start": 909.5000000000001,
      "Time_End": 916.5000000000001,
      "Text": " exfiltrate the ith bit, you set K to be the ith power of 2. You offset the partial, Alice's"
    },
    {
      "Time_Start": 916.5000000000001,
      "Time_End": 922.3800000000001,
      "Text": " partial signature by a value that depends on whatever you already know about Bob's key. And"
    },
    {
      "Time_Start": 922.3800000000001,
      "Time_End": 927.6,
      "Text": " in the end, depending on whether the signature fails or not, you obtain leakage, the ith bit"
    },
    {
      "Time_Start": 927.6,
      "Time_End": 932.6400000000001,
      "Text": " of Bob's key share. We didn't leave it at this, and we wanted to see if it would actually"
    },
    {
      "Time_Start": 932.6400000000001,
      "Time_End": 937.1400000000001,
      "Text": " work. So we went out, we found the most popular open source implementation of the"
    },
    {
      "Time_Start": 937.56,
      "Time_End": 942.22,
      "Text": " Lindell 17 protocol. It was published by Zango. And we tried to see if we could make it"
    },
    {
      "Time_Start": 942.22,
      "Time_End": 947.18,
      "Text": " work. So this is how the POC looks when it's run. As you can see on the right hand side of"
    },
    {
      "Time_Start": 947.18,
      "Time_End": 952.9399999999999,
      "Text": " the screen, every signature leaks us a single bit of Bob's private key share. Depending"
    },
    {
      "Time_Start": 952.9399999999999,
      "Time_End": 958.06,
      "Text": " whether the signature failed or not, we know whether it's 1 or 0. We only need to do this"
    },
    {
      "Time_Start": 958.06,
      "Time_End": 964.9399999999999,
      "Text": " 256 times. Now it may sound a lot, but it only takes a couple of minutes. And bit by bit, we"
    },
    {
      "Time_Start": 964.94,
      "Time_End": 969.44,
      "Text": " leak his entire key. Now we can combine it with our share of the key, and we have the"
    },
    {
      "Time_Start": 969.44,
      "Time_End": 973.82,
      "Text": " entire private share. We can print it in hexadecimal format, load it to Metamask or your"
    },
    {
      "Time_Start": 973.82,
      "Time_End": 980.6,
      "Text": " favorite crypto wallet, and you're done. So we've disclosed this to all the affected vendors"
    },
    {
      "Time_Start": 980.6,
      "Time_End": 987.6400000000001,
      "Text": " and they've since mitigated it. How did they do that? Well, they simply followed the paper's"
    },
    {
      "Time_Start": 987.64,
      "Time_End": 995.4399999999999,
      "Text": " specification. So like after you see that there was a failed signature, just don't sign"
    },
    {
      "Time_Start": 995.4399999999999,
      "Time_End": 1002.64,
      "Text": " again. Now this works, right? It mitigates the attack. But there are also other ways that you"
    },
    {
      "Time_Start": 1002.64,
      "Time_End": 1008.52,
      "Text": " might want to do it where you don't get a possibility of a denial of service attack. And to"
    },
    {
      "Time_Start": 1008.52,
      "Time_End": 1013.52,
      "Text": " explain a possible way of doing that, we need to introduce a new cryptographic primitive. It's"
    },
    {
      "Time_Start": 1013.52,
      "Time_End": 1017.9399999999999,
      "Text": " called a zero-knowledge proof. What is a zero-knowledge proof? Basically it's a proof that"
    },
    {
      "Time_Start": 1017.9399999999999,
      "Time_End": 1023.86,
      "Text": " yields the validity of a statement and nothing else. So to illustrate with an example, let's"
    },
    {
      "Time_Start": 1023.86,
      "Time_End": 1031.44,
      "Text": " say Alice encrypts some number X along with a zero-knowledge proof that that number is within"
    },
    {
      "Time_Start": 1031.44,
      "Time_End": 1037.06,
      "Text": " some range, for example 1 to 42. Now Bob can receive this and verify the zero-knowledge proof"
    },
    {
      "Time_Start": 1037.06,
      "Time_End": 1042.98,
      "Text": " and be certain that what he has is indeed an encryption of a number between 1 and 42, but he"
    },
    {
      "Time_Start": 1042.98,
      "Time_End": 1048.2,
      "Text": " knows nothing else. Only what the zero-knowledge proof wanted him to know. So taking the"
    },
    {
      "Time_Start": 1048.2,
      "Time_End": 1055.24,
      "Text": " intuition of this thing, we could maybe add a zero-knowledge proof to the protocol in order to"
    },
    {
      "Time_Start": 1055.24,
      "Time_End": 1060.02,
      "Text": " make sure that Alice cannot deviate from calculating the partial signature in the way the"
    },
    {
      "Time_Start": 1060.02,
      "Time_End": 1065.56,
      "Text": " protocol says she needs to do. Well, congratulations. You've learned how to compromise"
    },
    {
      "Time_Start": 1065.56,
      "Time_End": 1070.3600000000001,
      "Text": " implementations of the most popular two-party signing protocol and also how to mitigate it."
    },
    {
      "Time_Start": 1070.3600000000001,
      "Time_End": 1077.6200000000001,
      "Text": " And we're on to our second attack of the day, which is attacking the most popular multi-party"
    },
    {
      "Time_Start": 1077.6200000000001,
      "Time_End": 1082.7800000000002,
      "Text": " signing protocol, meaning it can be two parties, three parties, or a hundred even. So this has"
    },
    {
      "Time_Start": 1082.7800000000002,
      "Time_End": 1090.0400000000002,
      "Text": " affected many vendors and open source projects. So when we talked about the Lindell 17"
    },
    {
      "Time_Start": 1090.0400000000002,
      "Time_End": 1095.0000000000002,
      "Text": " protocol, we actually explained how it works, like start to finish. But the Digi protocols, the"
    },
    {
      "Time_Start": 1095.0,
      "Time_End": 1099.76,
      "Text": " thing with them is they're very complicated. They actually, to sign, they require between"
    },
    {
      "Time_Start": 1099.76,
      "Time_End": 1104.76,
      "Text": " seven and nine rounds of communication. So we don't have time to explain all that, and"
    },
    {
      "Time_Start": 1104.76,
      "Time_End": 1109.72,
      "Text": " actually we don't even need to because the entire thing happens during the very first round."
    },
    {
      "Time_Start": 1109.72,
      "Time_End": 1114.3,
      "Text": " The very first round implements what's called a multiplication to addition. So let's dive into"
    },
    {
      "Time_Start": 1114.3,
      "Time_End": 1122.1,
      "Text": " that. What is it? It's a way to transform two multiplicative shares, K and X, into two"
    },
    {
      "Time_Start": 1122.1000000000001,
      "Time_End": 1128.7,
      "Text": " additive shares, alpha and beta, where this equation applies. So how does the paper say that"
    },
    {
      "Time_Start": 1128.7,
      "Time_End": 1134.8200000000002,
      "Text": " you could do that? It says that Alice needs to encrypt her multiplicative share, K, along with a"
    },
    {
      "Time_Start": 1134.8200000000002,
      "Time_End": 1140.94,
      "Text": " zero-knowledge proof for doing just that, and send it over to Bob. Bob now can operate on"
    },
    {
      "Time_Start": 1140.94,
      "Time_End": 1146.2400000000002,
      "Text": " this homomorphically encrypted value. He doesn't know what it is, but he can multiply his"
    },
    {
      "Time_Start": 1146.2400000000002,
      "Time_End": 1151.4,
      "Text": " multiplicative share, his X, his key share, and to make sure that Alice doesn't learn anything"
    },
    {
      "Time_Start": 1151.4,
      "Time_End": 1156.4,
      "Text": " about his X, because that would be terrible, he adds a mask to mask it. Now Alice decrypts"
    },
    {
      "Time_Start": 1156.4,
      "Time_End": 1162.74,
      "Text": " this, she gets alpha, Bob gets beta by being equal to minus mask, and as you can see, it so"
    },
    {
      "Time_Start": 1162.74,
      "Time_End": 1168.7,
      "Text": " happens that K times X is equal to alpha plus beta. There's one very important thing that we"
    },
    {
      "Time_Start": 1168.7,
      "Time_End": 1175.7,
      "Text": " need to know about this. In the case of ECDSA where X and K are 256 bits, the mask needs to be"
    },
    {
      "Time_Start": 1175.74,
      "Time_End": 1181.0,
      "Text": " sufficiently large. It needs to be bigger than 512. Now why is that? To give an intuition of"
    },
    {
      "Time_Start": 1181.0,
      "Time_End": 1186.6200000000001,
      "Text": " how this masking works, we're going to use some visualization of small numbers. Let's say we"
    },
    {
      "Time_Start": 1186.6200000000001,
      "Time_End": 1192.78,
      "Text": " didn't even use a mask. If Alice would decrypt and get this value, X times K, she knows K,"
    },
    {
      "Time_Start": 1192.78,
      "Time_End": 1197.46,
      "Text": " right? She could just divide it by the K she knows and get X in the clear. So that's why we"
    },
    {
      "Time_Start": 1197.46,
      "Time_End": 1203.24,
      "Text": " need that mask. Now adding the mask actually works. It masks it. Although she knows K, she"
    },
    {
      "Time_Start": 1203.24,
      "Time_End": 1209.6200000000001,
      "Text": " doesn't know the mask, so she can't learn anything about Bob's X. But what happens if that's"
    },
    {
      "Time_Start": 1209.6200000000001,
      "Time_End": 1216.2,
      "Text": " not the case? What happens, for example, if K is even larger than the mask itself? In this"
    },
    {
      "Time_Start": 1216.2,
      "Time_End": 1223.0,
      "Text": " case, we can see that adding the mask actually hides nothing. Like the most significant"
    },
    {
      "Time_Start": 1223.0,
      "Time_End": 1229.66,
      "Text": " bits leak X in the clear. Now this could be a really great attack, right? Like we could be"
    },
    {
      "Time_Start": 1229.66,
      "Time_End": 1235.28,
      "Text": " Alice, we could choose a really big K that's larger than the mask, send it over, decrypt this,"
    },
    {
      "Time_Start": 1235.28,
      "Time_End": 1241.0,
      "Text": " and get everyone's key share in one go. But remember that zero knowledge proof that I"
    },
    {
      "Time_Start": 1241.0,
      "Time_End": 1245.8400000000001,
      "Text": " mentioned that she's sending over, it actually also includes what's called a range proof. What"
    },
    {
      "Time_Start": 1245.8400000000001,
      "Time_End": 1252.0800000000002,
      "Text": " that is, it's a zero knowledge proof that ensures that the number K is no bigger than 256"
    },
    {
      "Time_Start": 1252.0800000000002,
      "Time_End": 1258.74,
      "Text": " bits, which kind of foils our entire plan of attack here. So we're going to get deeper into the"
    },
    {
      "Time_Start": 1258.74,
      "Time_End": 1263.78,
      "Text": " math of the zero knowledge proof. Hold on tight. How does it look like? Basically it's a"
    },
    {
      "Time_Start": 1263.78,
      "Time_End": 1267.94,
      "Text": " bunch of numbers. The number Z is the one that we'll be focused on, because that's the one"
    },
    {
      "Time_Start": 1267.94,
      "Time_End": 1274.16,
      "Text": " that relates to the range proof part of the proof. Now how is Z calculated? It's equal to W,"
    },
    {
      "Time_Start": 1274.16,
      "Time_End": 1278.98,
      "Text": " which is a small random number, plus K, which is the number Alice is trying to prove is"
    },
    {
      "Time_Start": 1278.98,
      "Time_End": 1284.6200000000001,
      "Text": " sufficiently small, times a hash that depends on W, everything modulo N. Now when Bob"
    },
    {
      "Time_Start": 1284.6200000000001,
      "Time_End": 1289.3600000000001,
      "Text": " receives this, he does a bunch of verifications over the other parts of the proof that we're"
    },
    {
      "Time_Start": 1289.3600000000001,
      "Time_End": 1295.2,
      "Text": " not going to touch on, and he makes sure that Z is small. Now as you can see, if K will be too"
    },
    {
      "Time_Start": 1295.2,
      "Time_End": 1300.3200000000002,
      "Text": " large, then Z will not be small enough and will fail the range proof part of the proof. Now I"
    },
    {
      "Time_Start": 1300.3200000000002,
      "Time_End": 1306.0800000000002,
      "Text": " just want to stress that Alice has to follow this specific formula for calculating Z, because"
    },
    {
      "Time_Start": 1306.0800000000002,
      "Time_End": 1312.9,
      "Text": " if she doesn't, some of the other verifications will fail. So how can we go about cheating in"
    },
    {
      "Time_Start": 1312.9,
      "Time_End": 1318.98,
      "Text": " this zero knowledge range proof while adhering to this formula of calculating Z? What we're"
    },
    {
      "Time_Start": 1318.98,
      "Time_End": 1322.9,
      "Text": " going to do is we're going to focus on this part of the equation, and we're actually going to"
    },
    {
      "Time_Start": 1322.9,
      "Time_End": 1328.4,
      "Text": " try and zero it out. If we somehow manage to zero it out, then it doesn't matter how big K"
    },
    {
      "Time_Start": 1328.4,
      "Time_End": 1333.6000000000001,
      "Text": " is, Z is only equals to W, which is a small number, and we can use whatever big K we want"
    },
    {
      "Time_Start": 1333.6000000000001,
      "Time_End": 1338.6000000000001,
      "Text": " and pass the verification. So how will we do that? We're going to use what's called the"
    },
    {
      "Time_Start": 1338.6000000000001,
      "Time_End": 1344.8400000000001,
      "Text": " Chinese remainder theorem. For this use case, because as Nikos mentioned earlier, N is a"
    },
    {
      "Time_Start": 1344.8400000000001,
      "Time_End": 1351.3000000000002,
      "Text": " product of two primes, P and Q, if this value we're trying to zero out, modulo P and modulo Q,"
    },
    {
      "Time_Start": 1351.3000000000002,
      "Time_End": 1357.8000000000002,
      "Text": " they both zero out, then it also implies that the value we're trying to zero out zeroes out. So"
    },
    {
      "Time_Start": 1357.8000000000002,
      "Time_End": 1362.6000000000001,
      "Text": " we're going to use this lens of looking at it, and we can try to zero out the left-hand equations"
    },
    {
      "Time_Start": 1362.6000000000001,
      "Time_End": 1369.7600000000002,
      "Text": " one by one, and by doing so, we'll achieve our goal of zeroing out the right-hand equation. So"
    },
    {
      "Time_Start": 1369.7600000000002,
      "Time_End": 1375.0600000000002,
      "Text": " one by one, we start with the first one. It's actually surprisingly simple, because Alice is"
    },
    {
      "Time_Start": 1375.0600000000002,
      "Time_End": 1380.88,
      "Text": " free to choose whatever K she wants. How about she chooses K to be equal to Q, right? Then by"
    },
    {
      "Time_Start": 1380.88,
      "Time_End": 1386.88,
      "Text": " definition, Q mod Q zeroes out, and we're halfway there. The easy half now. So how do we go"
    },
    {
      "Time_Start": 1386.88,
      "Time_End": 1394.3000000000002,
      "Text": " about the second part? How do we zero out this value modulo P? What happens if this hash that"
    },
    {
      "Time_Start": 1394.3000000000002,
      "Time_End": 1400.96,
      "Text": " depends on W happens to organically land on a multiple of P? Well, that would be fantastic,"
    },
    {
      "Time_Start": 1400.96,
      "Time_End": 1408.1200000000001,
      "Text": " right? So is it likely to happen? No, but what if we brute force W, such as the hash that"
    },
    {
      "Time_Start": 1408.1200000000001,
      "Time_End": 1414.0800000000002,
      "Text": " depends on it happens to be a multiple of P? Is this feasible, you might ask yourself. The"
    },
    {
      "Time_Start": 1414.08,
      "Time_End": 1419.6999999999998,
      "Text": " question is, no, it's not at all feasible, because the paper says that N needs to be 2,048"
    },
    {
      "Time_Start": 1419.6999999999998,
      "Time_End": 1425.32,
      "Text": " bits, which makes P and Q both over 1,000 bits. Now that's impossible to brute force, and if we"
    },
    {
      "Time_Start": 1425.32,
      "Time_End": 1430.08,
      "Text": " could brute force that, right, we might as well just brute force X, which is 256 bits. So what"
    },
    {
      "Time_Start": 1430.08,
      "Time_End": 1437.6999999999998,
      "Text": " can we do? How about during the key generation phase, which happens once per wallet, Alice,"
    },
    {
      "Time_Start": 1437.7,
      "Time_End": 1444.3600000000001,
      "Text": " instead of choosing N to be comprised of two equally sized prime numbers, she would choose N"
    },
    {
      "Time_Start": 1444.3600000000001,
      "Time_End": 1449.78,
      "Text": " to be comprised of two very asymmetrically sized prime numbers, whereas P can be as small as 16"
    },
    {
      "Time_Start": 1449.78,
      "Time_End": 1454.2,
      "Text": " bits, which is brute forcible in an instant, and we can have Q to be sufficiently large to make"
    },
    {
      "Time_Start": 1454.2,
      "Time_End": 1459.6200000000001,
      "Text": " up for the desired size of N. Now, some of you might be thinking, well, maybe the protocol"
    },
    {
      "Time_Start": 1459.6200000000001,
      "Time_End": 1464.4,
      "Text": " says that there's zero-knowledge proof to prevent us from choosing such an N. It turns out that"
    },
    {
      "Time_Start": 1464.44,
      "Time_End": 1470.48,
      "Text": " there is no zero-knowledge proof that prevents us from using such an N. There is no ZKP for no"
    },
    {
      "Time_Start": 1470.48,
      "Time_End": 1475.5600000000002,
      "Text": " small factors. The only thing that the parties check is whether N is square free, and I'm not"
    },
    {
      "Time_Start": 1475.5600000000002,
      "Time_End": 1481.18,
      "Text": " going to get into the technical definition of square freeness, but it sounds like, you know, we"
    },
    {
      "Time_Start": 1481.18,
      "Time_End": 1486.76,
      "Text": " have a way, we have a hook, we have a way to get the goods. We can inject this N with a very"
    },
    {
      "Time_Start": 1486.76,
      "Time_End": 1491.68,
      "Text": " small P, then we can choose K to be equal to Q, then we can cheat in the range proof, and then"
    },
    {
      "Time_Start": 1491.68,
      "Time_End": 1497.92,
      "Text": " when we receive the MTA response, we can get all the Xs in the clear. So, are we done? Not so"
    },
    {
      "Time_Start": 1497.92,
      "Time_End": 1505.92,
      "Text": " fast. Because, remember the MTA formula? So this is what Alice obtains during the MTA. Well, in"
    },
    {
      "Time_Start": 1505.92,
      "Time_End": 1513.0,
      "Text": " reality, there is a pesky modulo N operation happening there implicitly, and it's"
    },
    {
      "Time_Start": 1513.0,
      "Time_End": 1517.38,
      "Text": " unavoidable. I'm not going to get into why it's unavoidable, but it's unavoidable. And it's very"
    },
    {
      "Time_Start": 1517.42,
      "Time_End": 1523.0,
      "Text": " annoying for the following reason. K is now almost as big as N, and what happens to the"
    },
    {
      "Time_Start": 1523.0,
      "Time_End": 1529.0,
      "Text": " leakage when K is almost as big as N? So, let's have a look at K times X plus the mask. Here"
    },
    {
      "Time_Start": 1529.0,
      "Time_End": 1534.88,
      "Text": " we see the beautiful X and the most significant bits in the clear. However, as soon as you"
    },
    {
      "Time_Start": 1534.88,
      "Time_End": 1541.24,
      "Text": " apply the modulo operator, the most significant bits of X, they disappear, they jump off a"
    },
    {
      "Time_Start": 1541.24,
      "Time_End": 1547.94,
      "Text": " cliff, they go bye-bye. And the only thing that remains is a small leakage of X. How small?"
    },
    {
      "Time_Start": 1547.94,
      "Time_End": 1553.94,
      "Text": " What Alice obtains using this attack is X mod P, and P is a 16-bit prime. If only there were a"
    },
    {
      "Time_Start": 1555.94,
      "Time_End": 1563.2,
      "Text": " way to obtain X from such remainders. Worry not, Nikos. Once again, the Chinese remainder"
    },
    {
      "Time_Start": 1563.2,
      "Time_End": 1568.2,
      "Text": " theorem comes to our rescue. Now, let's explain how it works a bit more in depth. Let's say we"
    },
    {
      "Time_Start": 1568.2,
      "Time_End": 1573.44,
      "Text": " have this small number, X, which is 23, right? We can encode it in a myriad of ways. Like we"
    },
    {
      "Time_Start": 1573.44,
      "Time_End": 1577.6200000000001,
      "Text": " can all see on the screen, we can encode it decimally, we can also encode it hexadecimally. We"
    },
    {
      "Time_Start": 1577.6200000000001,
      "Time_End": 1584.0800000000002,
      "Text": " can actually also use CRT to encode a number. Now, how would one go about doing that? You"
    },
    {
      "Time_Start": 1584.0800000000002,
      "Time_End": 1590.0800000000002,
      "Text": " need to divide this number by a few small primes and save the remainder. Now, just using this"
    },
    {
      "Time_Start": 1592.24,
      "Time_End": 1597.3600000000001,
      "Text": " information, the primes and the remainders, you can feed them into CRT to reconstruct the"
    },
    {
      "Time_Start": 1597.3600000000001,
      "Time_End": 1602.94,
      "Text": " original number fully. Now, it looks a bit like magic, but it also has some limitations."
    },
    {
      "Time_Start": 1602.94,
      "Time_End": 1607.1000000000001,
      "Text": " Namely, it would only work to encode a number that is smaller than the product of the"
    },
    {
      "Time_Start": 1607.1000000000001,
      "Time_End": 1612.48,
      "Text": " primes. In this example, using the primes 3, 5, and 7, you could only encode a number as big as"
    },
    {
      "Time_Start": 1612.48,
      "Time_End": 1618.48,
      "Text": " 105. We're trying to encode a number as big as 256 bits. So to do that, we'll need 16 small"
    },
    {
      "Time_Start": 1619.48,
      "Time_End": 1625.48,
      "Text": " primes that are each 16 bits of size. So if we can get these 16 reminders by the leakage that"
    },
    {
      "Time_Start": 1627.48,
      "Time_End": 1634.06,
      "Text": " we explained earlier and feed them all into CRT, we have Bob's key share, right? That could"
    },
    {
      "Time_Start": 1634.06,
      "Time_End": 1640.06,
      "Text": " work. Anything stopping us? Yes. We only have one N. Remember, while K is chosen afresh"
    },
    {
      "Time_Start": 1640.84,
      "Time_End": 1648.1799999999998,
      "Text": " during every signature generation, N is chosen once per wallet during the key generation"
    },
    {
      "Time_Start": 1648.1799999999998,
      "Time_End": 1654.76,
      "Text": " phase. So we only have one P value, so we can only do this to achieve the very first leakage."
    },
    {
      "Time_Start": 1654.76,
      "Time_End": 1660.76,
      "Text": " So, bear with me. What if during the key generation phase, Alice, instead of choosing N to"
    },
    {
      "Time_Start": 1661.58,
      "Time_End": 1667.58,
      "Text": " be this handsome-looking value that is a product of two primes, she would choose N to be this"
    },
    {
      "Time_Start": 1670.62,
      "Time_End": 1677.5,
      "Text": " monstrosity that is a product of 16 small primes plus times a prime that is as big to make up"
    },
    {
      "Time_Start": 1677.5,
      "Time_End": 1682.84,
      "Text": " for the desired size of N. Well, some of you might be wondering, well, isn't there some zero"
    },
    {
      "Time_Start": 1682.84,
      "Time_End": 1686.54,
      "Text": " knowledge proof in the protocol to make sure that you can choose this monstrosity? It turns"
    },
    {
      "Time_Start": 1686.58,
      "Time_End": 1691.08,
      "Text": " out that there is no zero knowledge proof for checking the biprimality, because the only"
    },
    {
      "Time_Start": 1691.08,
      "Time_End": 1695.28,
      "Text": " thing that the parties check is whether N is square free, and I'm still not telling you what"
    },
    {
      "Time_Start": 1695.28,
      "Time_End": 1702.28,
      "Text": " square freeness is. So, we're at the finish line. We can extract all of these moduli by"
    },
    {
      "Time_Start": 1702.28,
      "Time_End": 1707.24,
      "Text": " injecting the N and then choosing the K and then cheating in the range proof and then obtaining"
    },
    {
      "Time_Start": 1707.24,
      "Time_End": 1714.12,
      "Text": " the leakage. So how does it work? Well, when we have the normal-looking N, we set K equals Q"
    },
    {
      "Time_Start": 1714.1200000000001,
      "Time_End": 1720.4,
      "Text": " and we obtain leakage X mod P. Now that we have the bizarro N, we set K equals N over P"
    },
    {
      "Time_Start": 1720.4,
      "Time_End": 1726.1200000000001,
      "Text": " I and we obtain leakage X mod P I, and we need to do this in 16 different signature"
    },
    {
      "Time_Start": 1726.1200000000001,
      "Time_End": 1731.8200000000002,
      "Text": " generations, 16 different signature sessions. In the first one, we're going to use the first"
    },
    {
      "Time_Start": 1731.8200000000002,
      "Time_End": 1735.9,
      "Text": " K. It's going to give us X mod P 1. In the second one, we're going to use the second K. It's"
    },
    {
      "Time_Start": 1735.9,
      "Time_End": 1742.16,
      "Text": " going to give us X mod P 2, and so on and so forth until we get the 16th leakage. We feed"
    },
    {
      "Time_Start": 1742.16,
      "Time_End": 1749.6200000000001,
      "Text": " everything into the CRT algorithm, and we obtain X in the clear. So, once again, we went to"
    },
    {
      "Time_Start": 1749.6200000000001,
      "Time_End": 1757.2,
      "Text": " see if this crazy idea would work. We found an open source implementation of the GG20 protocol,"
    },
    {
      "Time_Start": 1757.2,
      "Time_End": 1764.1200000000001,
      "Text": " and we gave it a try. So, we start by choosing 16 small primes to make our bizarro N, and then"
    },
    {
      "Time_Start": 1764.1200000000001,
      "Time_End": 1768.5400000000002,
      "Text": " we start signing. Each time we choose K, we cheat in the range proof, and we get the"
    },
    {
      "Time_Start": 1768.54,
      "Time_End": 1773.62,
      "Text": " desired leakage. Now, we need to do this. We need to sign 16 times, each time getting one"
    },
    {
      "Time_Start": 1773.62,
      "Time_End": 1780.58,
      "Text": " of those leakages, and then we can feed all of this information into CRT. Once again, combine"
    },
    {
      "Time_Start": 1780.58,
      "Time_End": 1785.0,
      "Text": " it with our own key share, and we can print the full private key in a beautiful hexadecimal"
    },
    {
      "Time_Start": 1785.0,
      "Time_End": 1792.74,
      "Text": " format, load it up, spend away, no need for consent of any of the other parties. Once again,"
    },
    {
      "Time_Start": 1792.74,
      "Time_End": 1798.32,
      "Text": " we've notified all the affected vendors. They've since mitigated this attack. How would you"
    },
    {
      "Time_Start": 1798.32,
      "Time_End": 1803.6200000000001,
      "Text": " go about mitigating such an attack? Well, you could add those zero-knowledge proofs for"
    },
    {
      "Time_Start": 1803.6200000000001,
      "Time_End": 1808.98,
      "Text": " making sure the well-formedness of N, so Alice can choose this bizarro N that is needed to"
    },
    {
      "Time_Start": 1808.98,
      "Time_End": 1815.44,
      "Text": " carry out the attack. Well, congratulations. We're done with the second attack. We're on to"
    },
    {
      "Time_Start": 1815.44,
      "Time_End": 1821.48,
      "Text": " the third and last. Great. So, in the last few minutes, we will show you how to compromise"
    },
    {
      "Time_Start": 1821.48,
      "Time_End": 1827.26,
      "Text": " what we call a do-it-yourself protocol that we found in the wild. For this protocol, we will"
    },
    {
      "Time_Start": 1827.26,
      "Time_End": 1832.6,
      "Text": " be exfiltrating the key in a single signature. Actually, we're going to do that in less than a"
    },
    {
      "Time_Start": 1832.6,
      "Time_End": 1836.9,
      "Text": " signature. We're going to do it in the first round of the first signature generation. So, what"
    },
    {
      "Time_Start": 1836.9,
      "Time_End": 1842.68,
      "Text": " does the protocol look like? So, it is also an MTA-based protocol. However, here, there are no"
    },
    {
      "Time_Start": 1842.68,
      "Time_End": 1847.22,
      "Text": " zero-knowledge proofs accompanying the ciphertext that the parties sent to each other."
    },
    {
      "Time_Start": 1847.26,
      "Time_End": 1853.84,
      "Text": " Furthermore, the mask now is chosen to be as big as N. And this is important because now our"
    },
    {
      "Time_Start": 1853.84,
      "Time_End": 1860.54,
      "Text": " previous attack is no longer relevant. Because it doesn't matter how big K is, what's inside"
    },
    {
      "Time_Start": 1860.54,
      "Time_End": 1866.76,
      "Text": " the encryption is always hiding the X. Okay, so what can we do about it? Well, we can do a lot"
    },
    {
      "Time_Start": 1866.76,
      "Time_End": 1871.68,
      "Text": " about it because without the zero-knowledge proof, Alice can send something that's not even a"
    },
    {
      "Time_Start": 1871.72,
      "Time_End": 1876.72,
      "Text": " ciphertext. She can send, for example, the value 4. In doing so, and by choosing a carefully"
    },
    {
      "Time_Start": 1880.38,
      "Time_End": 1887.64,
      "Text": " crafted N, specifically one that is not square free, Bob will inadvertently send back his X in"
    },
    {
      "Time_Start": 1887.64,
      "Time_End": 1892.14,
      "Text": " the clear. Actually, it's not exactly in the clear. You need to do some data processing and"
    },
    {
      "Time_Start": 1892.14,
      "Time_End": 1896.22,
      "Text": " there's a bunch of primes involved and you need to do CRT and then you need to brute force a"
    },
    {
      "Time_Start": 1896.22,
      "Time_End": 1902.64,
      "Text": " bit. But everything happens in seconds. All right, so you can think about this attack as a"
    },
    {
      "Time_Start": 1902.64,
      "Time_End": 1907.44,
      "Text": " condensed version of the previous one. Whereas instead of getting the 16 leakages in 16"
    },
    {
      "Time_Start": 1907.44,
      "Time_End": 1913.22,
      "Text": " signature, we get all of them in one signature, do the brute forcing offline and then use CRT"
    },
    {
      "Time_Start": 1913.22,
      "Time_End": 1918.6000000000001,
      "Text": " to reconstruct the key. Now, this demo is going to go fast so do not blink. We start the"
    },
    {
      "Time_Start": 1918.6000000000001,
      "Time_End": 1923.02,
      "Text": " signing, we do the MTA phase, we get the leakage, we do the brute forcing, we fit it all into"
    },
    {
      "Time_Start": 1923.06,
      "Time_End": 1928.06,
      "Text": " CRT and voila, we have the private key. To conclude, we've shown you a bunch of different"
    },
    {
      "Time_Start": 1941.06,
      "Time_End": 1946.9,
      "Text": " attacks on MPC protocol that all result in exfiltrating the private key which is bypassing the"
    },
    {
      "Time_Start": 1946.9,
      "Time_End": 1954.9,
      "Text": " basic promise, security promise of the MPC protocols. I hope that you might find this as"
    },
    {
      "Time_Start": 1954.9,
      "Time_End": 1959.98,
      "Text": " interesting, as exciting as we do because this is a new space. The cryptography is really"
    },
    {
      "Time_Start": 1959.98,
      "Time_End": 1964.4,
      "Text": " interesting and it could really use as many researchers, as many smart people's eyes looking"
    },
    {
      "Time_Start": 1964.4,
      "Time_End": 1968.8200000000002,
      "Text": " over making sure everyone is implementing this stuff correctly. Here you can find all the"
    },
    {
      "Time_Start": 1968.8200000000002,
      "Time_End": 1973.74,
      "Text": " proof of concept source codes that we've showed you today as well as a technical white paper"
    },
    {
      "Time_Start": 1973.74,
      "Time_End": 1980.08,
      "Text": " explaining the math in more depth than you could have ever dreamed of and thank you very"
    },
    {
      "Time_Start": 1980.08,
      "Time_End": 1981.7,
      "Text": " much for coming. Thank you."
    }
  ]
}