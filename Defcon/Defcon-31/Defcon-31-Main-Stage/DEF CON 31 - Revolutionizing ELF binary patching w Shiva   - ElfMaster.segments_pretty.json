{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 7.0,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Hey, guys. Thank you for coming to my talk. My name is Ryan O'Neill. My talk,"
    },
    {
      "Time_Start": 7.0,
      "Time_End": 13.34,
      "Text": " revolutionizing ELF binary patching with Shiva. So let me take a moment just to introduce"
    },
    {
      "Time_Start": 13.34,
      "Time_End": 19.22,
      "Text": " myself. My name is Ryan O'Neill. I'm also the author of the book Learning Linux Binary"
    },
    {
      "Time_Start": 19.22,
      "Time_End": 25.48,
      "Text": " Analysis, which is a book on ELF hacking and related topics. I've published in a lot of"
    },
    {
      "Time_Start": 25.48,
      "Time_End": 31.52,
      "Text": " journals over the years, different hacker journals, Frack, Pocker GTFO, VX Heaven, Temp"
    },
    {
      "Time_Start": 31.52,
      "Time_End": 37.44,
      "Text": " Out, and I'm also the founder of BitLackies.org, which is where I published a lot of my"
    },
    {
      "Time_Start": 37.44,
      "Time_End": 43.78,
      "Text": " independent research for many years, up until about 2019, still up. I'm also the founder of"
    },
    {
      "Time_Start": 43.78,
      "Time_End": 49.82,
      "Text": " Arcana Research, computer security research and development. This is actually this website"
    },
    {
      "Time_Start": 49.86,
      "Time_End": 55.82,
      "Text": " where you can read more about Shiva, arcanaresearch.io, and arcanatechnologies.io,"
    },
    {
      "Time_Start": 55.82,
      "Time_End": 62.32,
      "Text": " which is a Linux threat detection technology for detecting various types of threats within"
    },
    {
      "Time_Start": 62.32,
      "Time_End": 68.32,
      "Text": " ELF artifacts. Before I get too deep into the talk, I want to take a moment to talk about the"
    },
    {
      "Time_Start": 68.32,
      "Time_End": 74.36,
      "Text": " DARPA AMP program, since Shiva was in part born out of this program. This is a really unique"
    },
    {
      "Time_Start": 74.36,
      "Time_End": 81.48,
      "Text": " program created by Sergey Bratis. It's the Assured Micro-Patching Program by DARPA. This"
    },
    {
      "Time_Start": 81.48,
      "Time_End": 87.36,
      "Text": " program is really cool. It's all about taking some brilliant creative minds who want to"
    },
    {
      "Time_Start": 87.36,
      "Time_End": 93.62,
      "Text": " raise the state of the art in reverse engineering technologies and ELF binary patching"
    },
    {
      "Time_Start": 93.62,
      "Time_End": 99.94,
      "Text": " technologies. There's also an effort to be able to do formal verification of these patches,"
    },
    {
      "Time_Start": 99.94,
      "Time_End": 104.67999999999999,
      "Text": " so after the patch is installed, can it be called safe? There's a number of different"
    },
    {
      "Time_Start": 104.67999999999999,
      "Time_End": 109.36,
      "Text": " facets to the project, and throughout the number of different performers, there's quite a"
    },
    {
      "Time_Start": 109.36,
      "Time_End": 113.98,
      "Text": " number of CPU architectures that are being targeted right now, although I'm only"
    },
    {
      "Time_Start": 113.98,
      "Time_End": 119.52,
      "Text": " specifically talking about my project today. But just the AMP program as a whole is really"
    },
    {
      "Time_Start": 119.52,
      "Time_End": 126.47999999999999,
      "Text": " cool. What is Shiva? Shiva is a state of the art binary patching solution for ELF. It's"
    },
    {
      "Time_Start": 126.48,
      "Time_End": 131.48000000000002,
      "Text": " essentially a custom dynamic linker that's been highly specialized to load and relocate"
    },
    {
      "Time_Start": 131.48000000000002,
      "Time_End": 137.18,
      "Text": " object files and transform the program at runtime. I've written a lot of linkers and loaders"
    },
    {
      "Time_Start": 137.18,
      "Time_End": 142.76,
      "Text": " over the years, from computer viruses to kernel rootkits to all kinds of things, binary"
    },
    {
      "Time_Start": 142.76,
      "Time_End": 148.26,
      "Text": " protectors that require different types of custom linkers and loaders, and this is"
    },
    {
      "Time_Start": 148.26,
      "Time_End": 155.6,
      "Text": " definitely the pinnacle of my research after about 16 or 17 years of ELF binary hacking."
    },
    {
      "Time_Start": 155.72,
      "Time_End": 162.14,
      "Text": " What makes Shiva special? Shiva has innovated quite a number of different new linking"
    },
    {
      "Time_Start": 162.14,
      "Time_End": 168.56,
      "Text": " concepts, so the ELF ABI has been extended to support more advanced linking and relocation"
    },
    {
      "Time_Start": 168.56,
      "Time_End": 174.88,
      "Text": " operations that allow for program transformation at runtime. Shiva's one of its"
    },
    {
      "Time_Start": 174.88,
      "Time_End": 180.51999999999998,
      "Text": " primary goals is to make patching binaries approachable, meaning you can do it in C, almost"
    },
    {
      "Time_Start": 180.51999999999998,
      "Time_End": 185.01999999999998,
      "Text": " just like you'd program anything else, trying to bridge the gap between the developer and the"
    },
    {
      "Time_Start": 185.02,
      "Time_End": 189.9,
      "Text": " reverse engineer, because patching binaries is often clunky and difficult. Shiva allows"
    },
    {
      "Time_Start": 189.9,
      "Time_End": 196.52,
      "Text": " developers to write nuanced patches with quite a bit of ease. So how can Shiva help you? So if"
    },
    {
      "Time_Start": 196.52,
      "Time_End": 201.76000000000002,
      "Text": " you're an organization or a company, generally speaking there's usually legacy software"
    },
    {
      "Time_Start": 201.76000000000002,
      "Time_End": 206.60000000000002,
      "Text": " that no longer has source code, and a bug comes up, whether it's a security vulnerability or"
    },
    {
      "Time_Start": 206.60000000000002,
      "Time_End": 212.10000000000002,
      "Text": " some kind of other bug, how does one fix that if there's no longer source code? And"
    },
    {
      "Time_Start": 212.1,
      "Time_End": 217.14,
      "Text": " oftentimes a team of people might get together to try to fix a simple bug, and it's"
    },
    {
      "Time_Start": 217.14,
      "Time_End": 224.56,
      "Text": " clunky, and there's no development workflow for that that's really been put into our"
    },
    {
      "Time_Start": 224.56,
      "Time_End": 229.51999999999998,
      "Text": " industry yet. So from a hacker's perspective, Shiva can do all kinds of things as well. It's an"
    },
    {
      "Time_Start": 229.51999999999998,
      "Time_End": 234.4,
      "Text": " advanced instrumentation engine. You can use it to create black box fuzzing harnesses. I used"
    },
    {
      "Time_Start": 234.4,
      "Time_End": 240.64,
      "Text": " it to fuzz the dynamic linker. One dynamic linker fuzzing another dynamic linker. But I"
    },
    {
      "Time_Start": 240.64000000000001,
      "Time_End": 243.52,
      "Text": " can't really get through a lot of the stuff I want to get through today, so I'm going to blast"
    },
    {
      "Time_Start": 243.52,
      "Time_End": 247.9,
      "Text": " through these slides, unfortunately, a little quicker than I might want. So the origins of"
    },
    {
      "Time_Start": 247.9,
      "Time_End": 253.60000000000002,
      "Text": " Shiva. About three and a half, four years ago I had an itch to write a custom elf interpreter."
    },
    {
      "Time_Start": 253.60000000000002,
      "Time_End": 258.48,
      "Text": " Everybody here know what an elf interpreter is? Basically, usually the dynamic linker. But"
    },
    {
      "Time_Start": 258.48,
      "Time_End": 262.26,
      "Text": " writing an elf interpreter is an interesting thought, because, well, there's a lot of"
    },
    {
      "Time_Start": 262.26,
      "Time_End": 267.72,
      "Text": " innovative concepts that can be ignited through that. And so this led to a concept called"
    },
    {
      "Time_Start": 267.76000000000005,
      "Time_End": 272.48,
      "Text": " interpreter chaining, where I chained two dynamic linkers together into the same process"
    },
    {
      "Time_Start": 272.48,
      "Time_End": 277.18,
      "Text": " image, my custom dynamic linker, which was evil, and then the real dynamic linker. My"
    },
    {
      "Time_Start": 277.18,
      "Time_End": 283.48,
      "Text": " evil dynamic linker loaded a modular relocatable object virus into memory. So this was"
    },
    {
      "Time_Start": 283.48,
      "Time_End": 288.26000000000005,
      "Text": " actually my first implementation of a custom dynamic linker for elf or a custom elf"
    },
    {
      "Time_Start": 288.26000000000005,
      "Time_End": 292.64000000000004,
      "Text": " interpreter. And you can actually read that algorithm for interpreter chaining and the"
    },
    {
      "Time_Start": 292.64,
      "Time_End": 298.68,
      "Text": " whole virus and everything is published in temp out issue two, article six there. And"
    },
    {
      "Time_Start": 298.68,
      "Time_End": 305.64,
      "Text": " this modular elf virus loader interpreter ultimately morphed into the first version of"
    },
    {
      "Time_Start": 305.64,
      "Time_End": 311.32,
      "Text": " Shiva, which was originally for x86 64. I actually gave a talk about it a year ago, but"
    },
    {
      "Time_Start": 311.32,
      "Time_End": 315.06,
      "Text": " it's a completely different beast than what I'm talking about today. But just giving you a"
    },
    {
      "Time_Start": 315.06,
      "Time_End": 321.28,
      "Text": " little history there. And so the original Shiva was for loading elf micro programs. So it"
    },
    {
      "Time_Start": 321.32000000000005,
      "Time_End": 325.00000000000006,
      "Text": " was a custom dynamic linker that allowed you to load elf micro programs to implement"
    },
    {
      "Time_Start": 325.00000000000006,
      "Time_End": 328.74,
      "Text": " security features and such into the process address space, like control flow integrity"
    },
    {
      "Time_Start": 328.74,
      "Time_End": 334.70000000000005,
      "Text": " hardening or whatever. You can do a lot with it. It was an instrumentation dream toy for a"
    },
    {
      "Time_Start": 334.70000000000005,
      "Time_End": 339.12,
      "Text": " reverse engineer. And that's still available, actually just open source that today. We're"
    },
    {
      "Time_Start": 339.12,
      "Time_End": 343.46000000000004,
      "Text": " going to get into this in a moment here. But the current version of Shiva is Shiva alpha"
    },
    {
      "Time_Start": 343.46000000000004,
      "Time_End": 349.78000000000003,
      "Text": " version 0.11, and it was forked off that original version. So just to clarify. And it was"
    },
    {
      "Time_Start": 349.78000000000003,
      "Time_End": 355.74,
      "Text": " heavily modified to meet the requirements and needs of the DARPA AMP program,"
    },
    {
      "Time_Start": 355.74,
      "Time_End": 362.90000000000003,
      "Text": " specifically NASA. And so but with that said, it's I'm not going to get too far ahead"
    },
    {
      "Time_Start": 362.90000000000003,
      "Time_End": 369.04,
      "Text": " actually. So let me stick with the slide. So rewind 25 years. Who was originally trying to"
    },
    {
      "Time_Start": 369.04,
      "Time_End": 375.82000000000005,
      "Text": " patch elf binaries and for what purpose? And this brings us to the awesome era of early"
    },
    {
      "Time_Start": 375.86,
      "Time_End": 383.86,
      "Text": " Unix virus research. And Silvio Cesar, who is a good friend of mine and mentor, published"
    },
    {
      "Time_Start": 383.86,
      "Time_End": 390.48,
      "Text": " this research, you know, through about 97 to 99, this very early elf research, Unix and elf"
    },
    {
      "Time_Start": 390.48,
      "Time_End": 395.4,
      "Text": " parasites in 1998 and a number of other papers I could list. But you have to understand at"
    },
    {
      "Time_Start": 395.4,
      "Time_End": 400.15999999999997,
      "Text": " the time this was super esoteric stuff. Nobody was doing this in 98. Who the hell knew what"
    },
    {
      "Time_Start": 400.16,
      "Time_End": 407.54,
      "Text": " elf was? But I saw that paper when I was 15, and it definitely enamored me, compelled me"
    },
    {
      "Time_Start": 407.54,
      "Time_End": 413.74,
      "Text": " into wanting to work on that stuff. But yeah, just a ton of other research came after"
    },
    {
      "Time_Start": 413.74,
      "Time_End": 419.16,
      "Text": " this by various underground hackers and researchers, which we'll talk a little bit"
    },
    {
      "Time_Start": 419.16,
      "Time_End": 423.96000000000004,
      "Text": " about. But you know, it brings us to the concept of elf virus technology. It's really the"
    },
    {
      "Time_Start": 423.96000000000004,
      "Time_End": 428.12,
      "Text": " same thing as elf instrumentation coming from somebody who's written a number of"
    },
    {
      "Time_Start": 428.16,
      "Time_End": 434.24,
      "Text": " computer viruses for elf. The programmatic techniques that go into it are very much the"
    },
    {
      "Time_Start": 434.24,
      "Time_End": 439.0,
      "Text": " same as instrumenting a binary with any other code. Doesn't matter if it's a parasite or if"
    },
    {
      "Time_Start": 439.0,
      "Time_End": 444.5,
      "Text": " it's security code. Point is, you need to make room within the elf binary. Oftentimes the"
    },
    {
      "Time_Start": 444.5,
      "Time_End": 449.7,
      "Text": " techniques aren't trivial for restructuring a binary depending on the technique, you know,"
    },
    {
      "Time_Start": 449.7,
      "Time_End": 454.88,
      "Text": " text segment padding infection, reverse text infection. There's all kinds of ways. And then"
    },
    {
      "Time_Start": 454.88,
      "Time_End": 458.92,
      "Text": " that code has to be relinked in some way. Whether it's through PLT hooks, inline hooks,"
    },
    {
      "Time_Start": 458.92,
      "Time_End": 464.04,
      "Text": " relocation poisoning or some other means. Also we know that of course, you know, hackers"
    },
    {
      "Time_Start": 464.04,
      "Time_End": 469.84,
      "Text": " like to inject viruses into memory. So P-trace is often used. And it's often used for just"
    },
    {
      "Time_Start": 469.84,
      "Time_End": 473.76,
      "Text": " instrumentation in general. You look at many different technologies out there,"
    },
    {
      "Time_Start": 473.76,
      "Time_End": 480.34,
      "Text": " Dynamo Rio, a bunch of them use P-trace. I've used P-trace a bunch to instrument. But on the"
    },
    {
      "Time_Start": 480.34000000000003,
      "Time_End": 485.3,
      "Text": " same token, security technologies use this as well for injecting patches into memory or"
    },
    {
      "Time_Start": 485.3,
      "Time_End": 491.00000000000006,
      "Text": " instrumenting memory like Valgrind does. In ways it's similar to Valgrind in how it works in"
    },
    {
      "Time_Start": 491.00000000000006,
      "Time_End": 498.12,
      "Text": " terms of the just in time kind of aspect of it. Basically all the elf research was coming out"
    },
    {
      "Time_Start": 498.12,
      "Time_End": 505.42,
      "Text": " of the underground scene. In the late 90s and early 2000s, there were a few major players in"
    },
    {
      "Time_Start": 505.42,
      "Time_End": 510.58000000000004,
      "Text": " that area. One of them was the gruck. The gruck designed the user land exec implementation"
    },
    {
      "Time_Start": 510.58000000000004,
      "Time_End": 516.4200000000001,
      "Text": " which is a user land function that can execute another program. So you don't have to use the"
    },
    {
      "Time_Start": 516.4200000000001,
      "Time_End": 520.9200000000001,
      "Text": " exec v system call and drop into the kernel. One user land program can execute another user"
    },
    {
      "Time_Start": 520.9200000000001,
      "Time_End": 526.04,
      "Text": " land program. It has all kinds of insane uses. He was using it for anti\u2011forensics. I've used"
    },
    {
      "Time_Start": 526.04,
      "Time_End": 531.38,
      "Text": " it for binary protectors and now I'm using it for Shiva because it's a loader. So very, very"
    },
    {
      "Time_Start": 531.38,
      "Time_End": 536.26,
      "Text": " important research by the gruck. He did other cool stuff too. And of course we have Mayhem who"
    },
    {
      "Time_Start": 536.26,
      "Time_End": 541.3,
      "Text": " was the chief editor of frack around the time. And he had this incredible IRISI project, the elf"
    },
    {
      "Time_Start": 541.3,
      "Time_End": 546.76,
      "Text": " reverse engineering software interface which I really can't say enough about. Truly profound"
    },
    {
      "Time_Start": 546.76,
      "Time_End": 553.3,
      "Text": " work, especially in 2002. Just the sheer level of innovation and work that went into IRISI is"
    },
    {
      "Time_Start": 553.3,
      "Time_End": 559.8,
      "Text": " impressive. There's a number of other people that worked with Mayhem on that project, other"
    },
    {
      "Time_Start": 559.84,
      "Time_End": 564.9200000000001,
      "Text": " aspects of it. But very brilliant work and very influential. And then another really"
    },
    {
      "Time_Start": 564.9200000000001,
      "Time_End": 569.9200000000001,
      "Text": " influential piece of work that came from the early underground, probably 99, was Silvio's, he"
    },
    {
      "Time_Start": 569.9200000000001,
      "Time_End": 574.3000000000001,
      "Text": " wrote a version of insmod that could install a kernel module through dev KMM by handling all"
    },
    {
      "Time_Start": 574.3000000000001,
      "Time_End": 578.8000000000001,
      "Text": " the relocations and stuff manually. It was the first implementation I'd seen of a hacker"
    },
    {
      "Time_Start": 578.8000000000001,
      "Time_End": 583.8000000000001,
      "Text": " writing a linker or a loader at the time. But it really seemed very profound to me. And so"
    },
    {
      "Time_Start": 583.8000000000001,
      "Time_End": 588.0400000000001,
      "Text": " that's some really \u2011\u2011 these are some real formative pieces of work that definitely"
    },
    {
      "Time_Start": 588.04,
      "Time_End": 592.88,
      "Text": " inspired me over the years. And there's also some really interesting stuff that's come from"
    },
    {
      "Time_Start": 592.88,
      "Time_End": 598.5799999999999,
      "Text": " the academic space in terms of elf binary patching. Firstly what comes to mind is Katana,"
    },
    {
      "Time_Start": 598.5799999999999,
      "Time_End": 604.5799999999999,
      "Text": " which is a Dwarf aware patching framework for elf. And it was designed by Sergey Bratis and"
    },
    {
      "Time_Start": 604.5799999999999,
      "Time_End": 608.8399999999999,
      "Text": " James Oakley, I think it was about 13 years ago. And a couple of really good white papers came"
    },
    {
      "Time_Start": 608.8399999999999,
      "Time_End": 614.74,
      "Text": " out of it. Pebble, I don't know as much about but I've kind of paid attention to it over the"
    },
    {
      "Time_Start": 614.74,
      "Time_End": 619.44,
      "Text": " years on GitHub. And it's an elf instrumentation framework. I think it's primarily used for"
    },
    {
      "Time_Start": 619.44,
      "Time_End": 624.62,
      "Text": " software profiling but it does some degree of function relocation. And then we have this"
    },
    {
      "Time_Start": 624.62,
      "Time_End": 630.58,
      "Text": " really great research called weird machines in elf by Rebecca Shapiro and Sergey Bratis. And"
    },
    {
      "Time_Start": 630.58,
      "Time_End": 635.74,
      "Text": " this was \u2011\u2011 I think there was even a talk at DEF CON maybe in 2011. But it was all about"
    },
    {
      "Time_Start": 635.74,
      "Time_End": 641.0,
      "Text": " using the dynamic linker's relocation computations as a Turing complete machine. So you can"
    },
    {
      "Time_Start": 641.0,
      "Time_End": 645.38,
      "Text": " program the dynamic linker to do a lot. And just through metadata, you know, relocations,"
    },
    {
      "Time_Start": 645.38,
      "Time_End": 650.54,
      "Text": " whatever. And this is something Shiva does a lot. And so these are just \u2011\u2011 yeah, this is"
    },
    {
      "Time_Start": 650.54,
      "Time_End": 655.46,
      "Text": " great stuff here. Take a look at some of the research tied to it. So, you know, we could say"
    },
    {
      "Time_Start": 655.46,
      "Time_End": 659.46,
      "Text": " elf binary instrumentation is a double edged sword. There's a lot to be learned from the"
    },
    {
      "Time_Start": 659.46,
      "Time_End": 664.84,
      "Text": " hackers and the underground community who are first putting this information out before 25"
    },
    {
      "Time_Start": 664.84,
      "Time_End": 669.38,
      "Text": " years later rolls around and here we are needing to design advanced binary patching"
    },
    {
      "Time_Start": 669.38,
      "Time_End": 675.96,
      "Text": " technologies. And Shiva has done that. But it's very much based in knowledge that I've"
    },
    {
      "Time_Start": 675.96,
      "Time_End": 680.8,
      "Text": " had preexisting in the underground scene. And so we're like, okay, binary patching is"
    },
    {
      "Time_Start": 680.8,
      "Time_End": 685.96,
      "Text": " pretty old. It goes all the way back to computer viruses. But really it goes back to the"
    },
    {
      "Time_Start": 685.96,
      "Time_End": 692.22,
      "Text": " beginning of elf which became the Unix standard in 1995 executable format for Unix,"
    },
    {
      "Time_Start": 692.22,
      "Time_End": 697.22,
      "Text": " Linux. And, you know, having been somebody who has done a lot of elf binary hacking over"
    },
    {
      "Time_Start": 697.22,
      "Time_End": 702.3000000000001,
      "Text": " the years, I put a lot of thought into this project. And I started, you know, looking at elf"
    },
    {
      "Time_Start": 702.3000000000001,
      "Time_End": 708.02,
      "Text": " and saying really it's already equipped mostly with what it needs. It's already equipped to"
    },
    {
      "Time_Start": 708.02,
      "Time_End": 712.6,
      "Text": " do a lot of patching just with its own relocation symbol information. And I started"
    },
    {
      "Time_Start": 712.6,
      "Time_End": 718.4200000000001,
      "Text": " looking at, you know, say LD Linux.SO. It's already a JIT micro patching engine. It does"
    },
    {
      "Time_Start": 718.4200000000001,
      "Time_End": 724.02,
      "Text": " simple patches but it's still a hot patching system. And then we have LD. LD links"
    },
    {
      "Time_Start": 724.06,
      "Time_End": 731.52,
      "Text": " relocatable objects into an executable using really granular elf relocation metadata. And"
    },
    {
      "Time_Start": 731.52,
      "Time_End": 736.06,
      "Text": " so just kind of looking and meditating on these things, how can I take what's already done so"
    },
    {
      "Time_Start": 736.06,
      "Time_End": 741.06,
      "Text": " beautifully and well and extrapolate on that to make an advanced binary patching system"
    },
    {
      "Time_Start": 741.06,
      "Time_End": 747.02,
      "Text": " that allows people to patch binaries and see? So I started realizing there's a lot of"
    },
    {
      "Time_Start": 747.02,
      "Time_End": 751.18,
      "Text": " power in writing an interpreter and what you can do with it. Started out as writing a"
    },
    {
      "Time_Start": 751.1800000000001,
      "Time_End": 754.84,
      "Text": " modular virus just to be, you know, cool and creative. But I knew it was going to"
    },
    {
      "Time_Start": 754.84,
      "Time_End": 759.72,
      "Text": " extrapolate into something a little bit more formal. And so you guys, most of you"
    },
    {
      "Time_Start": 759.72,
      "Time_End": 764.4200000000001,
      "Text": " probably familiar with elf. The PT interp segment holds the path to LD Linux.SO or the"
    },
    {
      "Time_Start": 764.4200000000001,
      "Time_End": 770.4200000000001,
      "Text": " dynamic linker. That gets replaced with lib Shiva. And the interpreter, generally"
    },
    {
      "Time_Start": 770.4200000000001,
      "Time_End": 775.2600000000001,
      "Text": " speaking, sets up the finer details of the process image. And the interpreter has"
    },
    {
      "Time_Start": 775.3,
      "Time_End": 781.34,
      "Text": " instrumentation precedence because it runs before even the real dynamic linker. So"
    },
    {
      "Time_Start": 781.34,
      "Time_End": 785.96,
      "Text": " another strong aspect of it is, you know, patching memory with P trace is slow because"
    },
    {
      "Time_Start": 785.96,
      "Time_End": 788.96,
      "Text": " you're in another process and there's a lot of context switching and things that"
    },
    {
      "Time_Start": 788.96,
      "Time_End": 795.04,
      "Text": " happen. If the patching, you know, engine is in the same address space of the program"
    },
    {
      "Time_Start": 795.04,
      "Time_End": 801.88,
      "Text": " it's patching, it's much faster. And so this is something exploring a different time and"
    },
    {
      "Time_Start": 801.88,
      "Time_End": 806.42,
      "Text": " more depth. But essentially I started thinking, well, an elf relocatable objects have"
    },
    {
      "Time_Start": 806.42,
      "Time_End": 812.5,
      "Text": " really great metadata, enough relocation information to build a process image out of."
    },
    {
      "Time_Start": 812.5,
      "Time_End": 820.0,
      "Text": " And so really Shiva is somewhat of a hybrid between LD and LD Linux.SO. So it draws"
    },
    {
      "Time_Start": 820.0,
      "Time_End": 826.54,
      "Text": " wisdom from both linkers. It's flexible, it's modular, like the dynamic linker, LD"
    },
    {
      "Time_Start": 826.5799999999999,
      "Time_End": 833.4599999999999,
      "Text": " Linux.SO, but it has the nuance of LD because it uses that really granular relocation"
    },
    {
      "Time_Start": 833.4599999999999,
      "Time_End": 839.4599999999999,
      "Text": " information that's in those elf object files. So to kind of further just show how it fits"
    },
    {
      "Time_Start": 841.9599999999999,
      "Time_End": 846.5799999999999,
      "Text": " into the existing elf linking components, you've got LD, it's an elf linker. You've got LD"
    },
    {
      "Time_Start": 846.5799999999999,
      "Time_End": 850.62,
      "Text": " Linux.SO, that's a linker and a loader because it loads shared libraries and knows how to"
    },
    {
      "Time_Start": 850.62,
      "Time_End": 856.04,
      "Text": " load executables. And then you have LibShiva, which is an elf linker, loader and a"
    },
    {
      "Time_Start": 856.04,
      "Time_End": 860.46,
      "Text": " transformer. And we're going to get more into transformation, transforms, how they fit on"
    },
    {
      "Time_Start": 860.46,
      "Time_End": 868.46,
      "Text": " top of relocations a little bit later. But, or maybe right now. So Shiva's innovation in"
    },
    {
      "Time_Start": 868.46,
      "Time_End": 873.96,
      "Text": " linking concepts. Shiva, just in the research and development of it, you know, I created a"
    },
    {
      "Time_Start": 873.96,
      "Time_End": 879.54,
      "Text": " number of new techniques that are necessary to kind of bring this all together. One of them"
    },
    {
      "Time_Start": 879.5799999999999,
      "Time_End": 884.8,
      "Text": " I touched on briefly, interpreter chaining, elf transforms. In fact, I'm not even going to go"
    },
    {
      "Time_Start": 884.8,
      "Time_End": 891.4599999999999,
      "Text": " through the whole list right now. But each one of these is something that's either brand new"
    },
    {
      "Time_Start": 891.4599999999999,
      "Time_End": 897.5,
      "Text": " or being used in a new way. Generally this is all pretty new concepts that fit really nicely"
    },
    {
      "Time_Start": 897.5,
      "Time_End": 902.3,
      "Text": " into the existing elf ABI. And we're going to talk deeper about them. Shiva's built on top"
    },
    {
      "Time_Start": 902.3,
      "Time_End": 909.12,
      "Text": " of LibElfMaster. It's a library I wrote in like 2018. It forensically reconstructs broken"
    },
    {
      "Time_Start": 909.16,
      "Time_End": 913.62,
      "Text": " binaries under the hood. So if a binary has no section headers or symbol tables, it will"
    },
    {
      "Time_Start": 913.62,
      "Time_End": 918.62,
      "Text": " reconstruct those based on the EH frame, the dynamic segment, other things, and recreate the"
    },
    {
      "Time_Start": 918.62,
      "Time_End": 923.38,
      "Text": " symbol table internally. So even though Shiva is symbolically driven, it can still work on"
    },
    {
      "Time_Start": 923.38,
      "Time_End": 927.92,
      "Text": " stripped binaries because of that. So I thought that might be a question that comes up. So let's"
    },
    {
      "Time_Start": 927.92,
      "Time_End": 934.12,
      "Text": " take a look at Shiva's elf linking workflow. So on the very left we have just two object"
    },
    {
      "Time_Start": 934.12,
      "Time_End": 940.34,
      "Text": " files, main.o and foo.o being linked into a program, my program. In the middle we see that"
    },
    {
      "Time_Start": 940.34,
      "Time_End": 946.12,
      "Text": " that program is now being executed and it has the LD Linux interpreter loading libc.so into"
    },
    {
      "Time_Start": 946.12,
      "Time_End": 951.26,
      "Text": " memory. That's just the general kind of linking workflow. You move over to the very far right"
    },
    {
      "Time_Start": 951.26,
      "Time_End": 957.38,
      "Text": " and there's a diagram illustrating that Shiva and LD Linux.so are cooperating together in"
    },
    {
      "Time_Start": 957.38,
      "Time_End": 961.54,
      "Text": " the same address space to transform the program with both the patch and the shared"
    },
    {
      "Time_Start": 961.54,
      "Time_End": 967.8,
      "Text": " libraries. So the standard elf dynamic linking workflow essentially looks like this. The"
    },
    {
      "Time_Start": 967.8,
      "Time_End": 972.8399999999999,
      "Text": " kernel is trying to execute a program called test. But first it loads test interpreter, which"
    },
    {
      "Time_Start": 972.8399999999999,
      "Time_End": 979.0799999999999,
      "Text": " is LD Linux.so, passes control to it. The dynamic linker loads libc or whatever it's loading"
    },
    {
      "Time_Start": 979.0799999999999,
      "Time_End": 983.8399999999999,
      "Text": " and then passes control to bin test. Actually passes control to the underscore start"
    },
    {
      "Time_Start": 983.8399999999999,
      "Time_End": 990.0,
      "Text": " function. With linker chaining where you're linking multiple dynamic linkers into the same"
    },
    {
      "Time_Start": 990.04,
      "Time_End": 996.42,
      "Text": " address space, you have both lib Shiva and LD Linux.so cooperating together. The kernel"
    },
    {
      "Time_Start": 996.42,
      "Time_End": 1001.04,
      "Text": " loads Shiva since that's the interpreter. Passes control to it. Shiva loads, links and"
    },
    {
      "Time_Start": 1001.04,
      "Time_End": 1007.66,
      "Text": " transforms this patch and then it actually user land execs essentially LD Linux.so into"
    },
    {
      "Time_Start": 1007.66,
      "Time_End": 1011.84,
      "Text": " memory. Maps all the segments into memory. Passes control to the real dynamic linker just like"
    },
    {
      "Time_Start": 1011.84,
      "Time_End": 1016.22,
      "Text": " the kernel would. The dynamic linker then loads its shared libraries and then finally passes"
    },
    {
      "Time_Start": 1016.22,
      "Time_End": 1023.1,
      "Text": " control to test. That's actually a simple, simple workflow. We'll get deeper later. But I"
    },
    {
      "Time_Start": 1023.1,
      "Time_End": 1028.06,
      "Text": " mentioned elf patches are compiled as just regular relocatable objects. You can use clang"
    },
    {
      "Time_Start": 1028.06,
      "Time_End": 1034.48,
      "Text": " or GCC. In the future I plan to write a compiler wrapper. But essentially, you know,"
    },
    {
      "Time_Start": 1034.48,
      "Time_End": 1038.98,
      "Text": " relocatable objects are great for patches. They contain rich symbolic metadata for both"
    },
    {
      "Time_Start": 1038.98,
      "Time_End": 1045.8,
      "Text": " relocations, all the symbol names. And I have extended some of it, but generally speaking the"
    },
    {
      "Time_Start": 1045.84,
      "Time_End": 1050.56,
      "Text": " object files are really nice. You have to build them with a large code model. That way an"
    },
    {
      "Time_Start": 1050.56,
      "Time_End": 1055.02,
      "Text": " internal got is used for absolute addresses so that you don't run into a situation where you're"
    },
    {
      "Time_Start": 1055.02,
      "Time_End": 1060.18,
      "Text": " further than four gigabytes away from the executable that you need to relink with. So"
    },
    {
      "Time_Start": 1060.18,
      "Time_End": 1064.44,
      "Text": " there's that. But I definitely recommend checking out the Shiva module loader function in"
    },
    {
      "Time_Start": 1064.44,
      "Time_End": 1068.72,
      "Text": " Shiva underscore module dot C. It's definitely where all the most probably interesting code"
    },
    {
      "Time_Start": 1068.72,
      "Time_End": 1075.3,
      "Text": " is. Also, you know, after an elf relocatable object is, so an elf relocatable object basically"
    },
    {
      "Time_Start": 1075.34,
      "Time_End": 1080.3,
      "Text": " gets loaded into memory. Shiva creates a text segment, data segment, BSS for all the patch"
    },
    {
      "Time_Start": 1080.3,
      "Time_End": 1084.18,
      "Text": " information. All the sections are put in their appropriate places. All the relocations for"
    },
    {
      "Time_Start": 1084.18,
      "Time_End": 1089.3,
      "Text": " the patches are handled. But then the executable itself needs to be relinked to use the new"
    },
    {
      "Time_Start": 1089.3,
      "Time_End": 1094.72,
      "Text": " patch code and data. Well, that's a little difficult because elf executables don't have"
    },
    {
      "Time_Start": 1094.72,
      "Time_End": 1099.98,
      "Text": " relocation data that describe how to relocate their own text section. They have a little bit"
    },
    {
      "Time_Start": 1099.98,
      "Time_End": 1103.72,
      "Text": " of dynamic linking information, but that's different. They don't have the information that"
    },
    {
      "Time_Start": 1103.76,
      "Time_End": 1108.76,
      "Text": " was in the original elf object files because it's not needed anymore. It would be nice. But"
    },
    {
      "Time_Start": 1108.76,
      "Time_End": 1113.6000000000001,
      "Text": " what Shiva does is it generates a control flow graph and based off that it generates"
    },
    {
      "Time_Start": 1113.6000000000001,
      "Time_End": 1118.14,
      "Text": " relocations on the fly for the elf executable because there's a lot of relinking and"
    },
    {
      "Time_Start": 1118.14,
      "Time_End": 1123.02,
      "Text": " reencoding of instructions that has to be done if you splice new code in, for instance. All"
    },
    {
      "Time_Start": 1123.02,
      "Time_End": 1128.94,
      "Text": " the offsets change. Everything changes. And so we're able to handle all that pretty nicely,"
    },
    {
      "Time_Start": 1128.94,
      "Time_End": 1135.7,
      "Text": " fluently. So I mentioned briefly Shiva's userland exec functionality. This is just used"
    },
    {
      "Time_Start": 1135.7,
      "Time_End": 1140.8600000000001,
      "Text": " kind of like any interpreter with Python. You can call Python directly. Same with Shiva."
    },
    {
      "Time_Start": 1140.8600000000001,
      "Time_End": 1145.98,
      "Text": " This is really good for testing a patch. Let's say you want to make no metadata"
    },
    {
      "Time_Start": 1145.98,
      "Time_End": 1150.4,
      "Text": " modifications to the binary. Just leave the binary completely untouched. You just specify the"
    },
    {
      "Time_Start": 1150.4,
      "Time_End": 1155.02,
      "Text": " patch object in the Shiva module path environment variable and then you run Shiva and then"
    },
    {
      "Time_Start": 1155.02,
      "Time_End": 1158.82,
      "Text": " the program you're trying to execute. And it will load and install the patches all at"
    },
    {
      "Time_Start": 1158.82,
      "Time_End": 1165.02,
      "Text": " run time. If you want the program to be patched every time you run it without having to"
    },
    {
      "Time_Start": 1165.02,
      "Time_End": 1168.74,
      "Text": " execute Shiva, you have to use the Shiva prelinker. We'll get into that in a minute. But it"
    },
    {
      "Time_Start": 1168.74,
      "Time_End": 1173.56,
      "Text": " updates the PT interp segment with the correct interpreter and also adds a new dynamic"
    },
    {
      "Time_Start": 1173.56,
      "Time_End": 1178.66,
      "Text": " segment. A couple other little things. So can everybody see here the requesting program"
    },
    {
      "Time_Start": 1178.66,
      "Time_End": 1183.74,
      "Text": " interpreter is Lib Shiva in this program instead of LD Linux? So that's just kind of"
    },
    {
      "Time_Start": 1183.74,
      "Time_End": 1188.46,
      "Text": " illustrating for you what the program looks like after it's been prelinked. And then if the"
    },
    {
      "Time_Start": 1188.46,
      "Time_End": 1193.28,
      "Text": " dynamic segment here, we can see the last three entries towards the bottom here, Shiva"
    },
    {
      "Time_Start": 1193.28,
      "Time_End": 1199.08,
      "Text": " needed. And I don't know why you can't see that. Hold on here. There's like something in"
    },
    {
      "Time_Start": 1199.08,
      "Time_End": 1204.42,
      "Text": " front of it there. But that's the base name to the patch object Shiva needed. So the"
    },
    {
      "Time_Start": 1204.42,
      "Time_End": 1209.2,
      "Text": " needed patch objects. The search right here is the search path to where all the object files"
    },
    {
      "Time_Start": 1209.24,
      "Time_End": 1214.82,
      "Text": " are stored. Just like with the dynamic linker, they're usually stored in Lib. And then it"
    },
    {
      "Time_Start": 1214.82,
      "Time_End": 1220.1200000000001,
      "Text": " gives the path to the original ELF interpreter so that Shiva knows which path the"
    },
    {
      "Time_Start": 1220.1200000000001,
      "Time_End": 1223.54,
      "Text": " interpreter is to load and link into memory because it will map the dynamic linker into"
    },
    {
      "Time_Start": 1223.54,
      "Time_End": 1229.74,
      "Text": " memory once it's done. So I want to talk about ELF symbol interposition here for a"
    },
    {
      "Time_Start": 1229.74,
      "Time_End": 1235.16,
      "Text": " moment. So is anybody familiar with what that term means? ELF symbol interposition?"
    },
    {
      "Time_Start": 1235.2,
      "Time_End": 1240.2,
      "Text": " Okay, yeah. So essentially though, think LD preload. It's where you can overwrite one"
    },
    {
      "Time_Start": 1240.2,
      "Time_End": 1244.0400000000002,
      "Text": " symbol with another symbol because it has the same name based on the precedence of the"
    },
    {
      "Time_Start": 1244.0400000000002,
      "Time_End": 1250.1200000000001,
      "Text": " object that's loaded. So Shiva, one of its really strong features is that it allows you to"
    },
    {
      "Time_Start": 1250.1200000000001,
      "Time_End": 1255.46,
      "Text": " rewrite any code and data just by name. As long as there's symbolic data attached to it,"
    },
    {
      "Time_Start": 1255.46,
      "Time_End": 1259.96,
      "Text": " any global data, any global functions, even local functions, although it needs about two"
    },
    {
      "Time_Start": 1259.96,
      "Time_End": 1266.1200000000001,
      "Text": " days of work to do that. But essentially anything symbolically can be rewritten. It's"
    },
    {
      "Time_Start": 1266.1200000000001,
      "Time_End": 1270.54,
      "Text": " actually really easy. So instead of just rewriting functions like with LD preload, you"
    },
    {
      "Time_Start": 1270.54,
      "Time_End": 1275.88,
      "Text": " can rewrite anything by name essentially in the executable itself. I want to give just a"
    },
    {
      "Time_Start": 1275.88,
      "Time_End": 1281.3,
      "Text": " little example here. See we're running hello. It says hello world. Can you guys see that"
    },
    {
      "Time_Start": 1281.3,
      "Time_End": 1286.0,
      "Text": " okay? It's kind of small. And then I look at the symbol table and I see there's a string"
    },
    {
      "Time_Start": 1286.0,
      "Time_End": 1294.0,
      "Text": " called hello underscore string that lives in the RO data section. And if we, let's say we"
    },
    {
      "Time_Start": 1294.0,
      "Time_End": 1297.34,
      "Text": " want to change that program. The program's called hello. And we want to make it so that it"
    },
    {
      "Time_Start": 1297.34,
      "Time_End": 1302.42,
      "Text": " prints hello DEF CON 31. So we literally have a very simple patch. We just redefine that"
    },
    {
      "Time_Start": 1302.42,
      "Time_End": 1308.16,
      "Text": " constant string by name. We compile it into an ELF relocatable object with a large code"
    },
    {
      "Time_Start": 1308.16,
      "Time_End": 1314.16,
      "Text": " model. And then on this slide we're going to show you how it works. So running hello just"
    },
    {
      "Time_Start": 1314.16,
      "Time_End": 1320.3600000000001,
      "Text": " runs hello world. But if we set the Shiva module path to the patch object and then run"
    },
    {
      "Time_Start": 1320.3600000000001,
      "Time_End": 1325.24,
      "Text": " Shiva on hello, it installs the patch at run time. But then if you just run it without"
    },
    {
      "Time_Start": 1325.24,
      "Time_End": 1329.24,
      "Text": " Shiva it just goes back to normal. So this is a great way to test things or just if you"
    },
    {
      "Time_Start": 1329.24,
      "Time_End": 1333.3200000000002,
      "Text": " only want to do things once or dynamically. Generally speaking though, most people want"
    },
    {
      "Time_Start": 1333.3200000000002,
      "Time_End": 1337.3200000000002,
      "Text": " to patch their program permanently. So what you do is you use the Shiva prelinker. It's"
    },
    {
      "Time_Start": 1337.3200000000002,
      "Time_End": 1343.4,
      "Text": " called Shiva LD. And it essentially just installs the original interpreter information,"
    },
    {
      "Time_Start": 1343.4,
      "Time_End": 1348.44,
      "Text": " the patch metadata such as the location of the patch into the new data segment that it"
    },
    {
      "Time_Start": 1348.44,
      "Time_End": 1352.98,
      "Text": " creates in the binary. So the executable code and data isn't changed at all. It's just"
    },
    {
      "Time_Start": 1352.98,
      "Time_End": 1358.52,
      "Text": " metadata. So that the new binary uses the correct interpreter path and all that. So we"
    },
    {
      "Time_Start": 1358.52,
      "Time_End": 1364.68,
      "Text": " can see we run hello directly now that we prelinked it and it's printing hello DEF CON 31."
    },
    {
      "Time_Start": 1364.68,
      "Time_End": 1371.48,
      "Text": " So just a simple patch and see. So transformations. I mentioned these earlier. So this is"
    },
    {
      "Time_Start": 1371.8,
      "Time_End": 1377.72,
      "Text": " transformations begin where relocations leave off. I think the dynamic linker is just"
    },
    {
      "Time_Start": 1377.72,
      "Time_End": 1382.22,
      "Text": " brilliant. It's a brilliant hot patching mechanism. We can learn a lot from it. Why not take it"
    },
    {
      "Time_Start": 1382.22,
      "Time_End": 1387.76,
      "Text": " and utilize it for micro patching binaries. Something of that nature. The same concept."
    },
    {
      "Time_Start": 1387.76,
      "Time_End": 1394.6,
      "Text": " Extrapolating on it. So if ELF relocations are the metadata that describes simple patching"
    },
    {
      "Time_Start": 1394.6,
      "Time_End": 1399.22,
      "Text": " operations, then ELF transformations would be the metadata that describes complex patching"
    },
    {
      "Time_Start": 1399.26,
      "Time_End": 1405.88,
      "Text": " operations. Such as function splicing. Things of that nature. So function splicing is the"
    },
    {
      "Time_Start": 1405.88,
      "Time_End": 1412.34,
      "Text": " ability to splice C code into any function at any given point within the function. Fully"
    },
    {
      "Time_Start": 1412.34,
      "Time_End": 1416.76,
      "Text": " relocatable code, fully symbolically rich access to all the shared libraries, symbols,"
    },
    {
      "Time_Start": 1416.76,
      "Time_End": 1424.0,
      "Text": " functions. And this is very complicated. There's a lot of relinking. Many, many magical"
    },
    {
      "Time_Start": 1424.0,
      "Time_End": 1429.08,
      "Text": " things have to happen under the hood. But the end result is that we have these transform"
    },
    {
      "Time_Start": 1429.12,
      "Time_End": 1436.08,
      "Text": " macros that developers can use to splice code in and out of a function. So this is just"
    },
    {
      "Time_Start": 1436.08,
      "Time_End": 1442.58,
      "Text": " a kind of a crude example here. But essentially we have on the left a program that you"
    },
    {
      "Time_Start": 1442.58,
      "Time_End": 1448.1999999999998,
      "Text": " stir copy. And it's a function called copy string. And let's say we want to modify that"
    },
    {
      "Time_Start": 1448.1999999999998,
      "Time_End": 1454.28,
      "Text": " function so that it uses stern copy. Make sure the string buffer is null terminated. So on"
    },
    {
      "Time_Start": 1454.28,
      "Time_End": 1460.6,
      "Text": " the left you can see the code that's being removed from 7BC down to 7C8. Which will make"
    },
    {
      "Time_Start": 1460.6,
      "Time_End": 1467.6399999999999,
      "Text": " our stopping address 7CC by the way. But we want to splice this code which is larger into"
    },
    {
      "Time_Start": 1467.6399999999999,
      "Time_End": 1471.6399999999999,
      "Text": " this little area there. We want to make it look like this on the right. So how would we do"
    },
    {
      "Time_Start": 1471.6399999999999,
      "Time_End": 1477.86,
      "Text": " that? So this is actually a transformation patch right here. Giving an example. So up here we"
    },
    {
      "Time_Start": 1477.9,
      "Time_End": 1484.0600000000002,
      "Text": " have this macro. Shiva T splice function. Copy string. And remember I gave you the offset"
    },
    {
      "Time_Start": 1484.0600000000002,
      "Time_End": 1490.0600000000002,
      "Text": " 7BC to 7CC. Now these three lines of code are pretty simple. The first line because the"
    },
    {
      "Time_Start": 1490.0600000000002,
      "Time_End": 1494.8600000000001,
      "Text": " argument stored in the X zero register because it's ARM. We create a source pointer"
    },
    {
      "Time_Start": 1494.8600000000001,
      "Time_End": 1498.94,
      "Text": " variable because it's the argument of the function copy string. And then the destination"
    },
    {
      "Time_Start": 1498.94,
      "Time_End": 1504.2800000000002,
      "Text": " buffer was at base pointer plus 32. So Shiva gives you macros to access live variables and"
    },
    {
      "Time_Start": 1504.32,
      "Time_End": 1510.3999999999999,
      "Text": " registers as needed. And then it just does stern copy. This actually compiles into an"
    },
    {
      "Time_Start": 1510.3999999999999,
      "Time_End": 1516.8999999999999,
      "Text": " object file that looks like this. And unfortunately I don't have all the time I'd like to go"
    },
    {
      "Time_Start": 1516.8999999999999,
      "Time_End": 1522.3999999999999,
      "Text": " on that tangent. But generally speaking in the text section here we have this function."
    },
    {
      "Time_Start": 1522.3999999999999,
      "Time_End": 1528.6,
      "Text": " Shiva splice FN name copy string. That tells Shiva okay this function right here is actually"
    },
    {
      "Time_Start": 1528.6,
      "Time_End": 1532.78,
      "Text": " code that's going to be spliced into a function called copy string. By the way it won't"
    },
    {
      "Time_Start": 1532.78,
      "Time_End": 1537.18,
      "Text": " copy the procedure prologue and epilogue. That's not splice code. But ARM doesn't"
    },
    {
      "Time_Start": 1537.18,
      "Time_End": 1543.48,
      "Text": " respect the naked attribute apparently. So overflow crashes. Okay so this is a program"
    },
    {
      "Time_Start": 1543.48,
      "Time_End": 1547.02,
      "Text": " called overflow. It's the one that I showed you. It's vulnerable. It's got stern copy. We"
    },
    {
      "Time_Start": 1547.02,
      "Time_End": 1553.78,
      "Text": " can see that when we pass it four A's it works. When we pass it like over 16 A's it crashes."
    },
    {
      "Time_Start": 1553.78,
      "Time_End": 1557.98,
      "Text": " So we pre link our patch. This one I showed you right here that we compile into a"
    },
    {
      "Time_Start": 1557.98,
      "Time_End": 1562.76,
      "Text": " relocatable object. Pre link it to the vulnerable program overflow. And then we run"
    },
    {
      "Time_Start": 1562.76,
      "Time_End": 1568.56,
      "Text": " overflow and we can see that it works. It's not crashing anymore. That's because it's using"
    },
    {
      "Time_Start": 1568.56,
      "Time_End": 1573.6,
      "Text": " stern copy and properly null terminating the string. But just showing how that's a very"
    },
    {
      "Time_Start": 1573.6,
      "Time_End": 1579.18,
      "Text": " simple example. You can splice into any function. That's just to make it palatable in a talk."
    },
    {
      "Time_Start": 1579.18,
      "Time_End": 1583.14,
      "Text": " So spliceable code has some interesting characteristics. I kind of covered some of them."
    },
    {
      "Time_Start": 1583.14,
      "Time_End": 1589.0600000000002,
      "Text": " It's fully relocatable. A very rich symbolic access with natural C development. There's no"
    },
    {
      "Time_Start": 1589.0600000000002,
      "Time_End": 1596.22,
      "Text": " limit or size to the amount of code you can splice into an existing function. And yeah, I"
    },
    {
      "Time_Start": 1596.22,
      "Time_End": 1601.1000000000001,
      "Text": " mean you can \u2011\u2011 and then of course there's macros for gaining access to live variables and"
    },
    {
      "Time_Start": 1601.1000000000001,
      "Time_End": 1607.96,
      "Text": " registers on the stack and whatnot. So confluent linking technologies. This is a"
    },
    {
      "Time_Start": 1607.96,
      "Time_End": 1612.14,
      "Text": " terminology I've kind of coined which just means two dynamic linkers working together"
    },
    {
      "Time_Start": 1612.14,
      "Time_End": 1617.18,
      "Text": " coherently within one process image to build, transform and re\u2011link the program at run"
    },
    {
      "Time_Start": 1617.18,
      "Time_End": 1621.88,
      "Text": " time. And there are a lot of cases \u2011\u2011 so there's a couple new things here. Cross"
    },
    {
      "Time_Start": 1621.88,
      "Time_End": 1627.3400000000001,
      "Text": " relocations. This is actually where one dynamic linker relies on another dynamic linker to"
    },
    {
      "Time_Start": 1627.3400000000001,
      "Time_End": 1632.0200000000002,
      "Text": " solve its own relocation. So an example of this is let's say you write a patch that has a"
    },
    {
      "Time_Start": 1632.0200000000002,
      "Time_End": 1636.5200000000002,
      "Text": " new BSS variable. It's overwriting another BSS variable in the original program. This is"
    },
    {
      "Time_Start": 1636.5200000000002,
      "Time_End": 1640.1000000000001,
      "Text": " the new version of the variable that should be used. Maybe you had to extend a buffer size"
    },
    {
      "Time_Start": 1640.1000000000001,
      "Time_End": 1647.1000000000001,
      "Text": " or something. Those BSS variables are often accessed indirectly through the got. There's a"
    },
    {
      "Time_Start": 1647.1000000000001,
      "Time_End": 1652.72,
      "Text": " relative relocation, at least in pi executables, that fixes up the got to the correct BSS"
    },
    {
      "Time_Start": 1652.72,
      "Time_End": 1656.8400000000001,
      "Text": " address. So when Shiva \u2011\u2011 when somebody has a patch with a new BSS variable, for"
    },
    {
      "Time_Start": 1656.8400000000001,
      "Time_End": 1664.44,
      "Text": " instance, they will \u2011\u2011 sorry, I'm looking at the time here. They will \u2011\u2011 Shiva will"
    },
    {
      "Time_Start": 1664.44,
      "Time_End": 1670.3200000000002,
      "Text": " instruct the other dynamic linker to essentially patch it by modifying the relocation"
    },
    {
      "Time_Start": 1670.3200000000002,
      "Time_End": 1674.78,
      "Text": " metadata in memory. So you can basically tell the dynamic linker to do whatever you want. You"
    },
    {
      "Time_Start": 1674.78,
      "Time_End": 1680.8600000000001,
      "Text": " give it a script. The script is the ELF sections that \u2011\u2011 and the values in the dynamic"
    },
    {
      "Time_Start": 1680.8600000000001,
      "Time_End": 1685.44,
      "Text": " segment that are read by the dynamic linker. We also have delayed relocations, which we"
    },
    {
      "Time_Start": 1685.44,
      "Time_End": 1690.3200000000002,
      "Text": " therefore we have the Shiva post linker, which actually handles some relocations after"
    },
    {
      "Time_Start": 1690.32,
      "Time_End": 1696.08,
      "Text": " LDLinux.SO. So Shiva will load, link the patch, pass control to the dynamic linker. And"
    },
    {
      "Time_Start": 1696.08,
      "Time_End": 1700.28,
      "Text": " then when the dynamic linker is done, oftentimes it passes control back to a function called"
    },
    {
      "Time_Start": 1700.28,
      "Time_End": 1705.6599999999999,
      "Text": " Shiva post linker. We actually update the AT entry value in the auxiliary vector, which"
    },
    {
      "Time_Start": 1705.6599999999999,
      "Time_End": 1711.82,
      "Text": " normally points to the start function of the program, so that it jumps back to the Shiva"
    },
    {
      "Time_Start": 1711.82,
      "Time_End": 1716.1599999999999,
      "Text": " post linker. The Shiva post linker then finishes handling any delayed relocations and then"
    },
    {
      "Time_Start": 1716.2,
      "Time_End": 1722.2,
      "Text": " passes control forward. Shiva was just made open source today. I am excited, grateful to be"
    },
    {
      "Time_Start": 1727.0800000000002,
      "Time_End": 1732.28,
      "Text": " able to share it with everybody. Please \u2011\u2011 and there's a user manual. There's quite a bit of"
    },
    {
      "Time_Start": 1732.28,
      "Time_End": 1739.46,
      "Text": " documentation. But let's see. What time is it here? So let me go into this demo real quick for"
    },
    {
      "Time_Start": 1739.46,
      "Time_End": 1745.46,
      "Text": " you guys, okay? I want to \u2011\u2011 all right. I hope you like Chopin. All right. So I want to"
    },
    {
      "Time_Start": 1756.0,
      "Time_End": 1761.8400000000001,
      "Text": " illustrate an example of symbol interposition and how it can be used to rewrite global code"
    },
    {
      "Time_Start": 1761.8400000000001,
      "Time_End": 1767.96,
      "Text": " and data on the fly with Shiva in a way that's natural for C developers. So let's take a"
    },
    {
      "Time_Start": 1767.96,
      "Time_End": 1773.38,
      "Text": " look at this simple program test foo. And for the sake of illustrating the scenario, I'm"
    },
    {
      "Time_Start": 1773.38,
      "Time_End": 1780.42,
      "Text": " going to show you the original source code. So we can see that main simply calls foo and"
    },
    {
      "Time_Start": 1780.42,
      "Time_End": 1786.1200000000001,
      "Text": " then prints the return value. Foo prints I am the original foo function and then it prints"
    },
    {
      "Time_Start": 1786.1200000000001,
      "Time_End": 1790.72,
      "Text": " the value of lucky number. Lucky number is an initialized global variable, so it would"
    },
    {
      "Time_Start": 1790.72,
      "Time_End": 1796.72,
      "Text": " live in the data section. So let's say we wanted to rewrite this function and also print"
    },
    {
      "Time_Start": 1797.96,
      "Time_End": 1803.04,
      "Text": " and modify this variable. In fact, we actually want to redeclare this variable. Let's take a"
    },
    {
      "Time_Start": 1803.04,
      "Time_End": 1808.08,
      "Text": " look over here on the right side of the screen. And this is the actual patch code itself. So as"
    },
    {
      "Time_Start": 1808.08,
      "Time_End": 1814.08,
      "Text": " you can see, we've redeclared lucky number as an uninitialized global variable. In Shiva we"
    },
    {
      "Time_Start": 1815.46,
      "Time_End": 1821.46,
      "Text": " call this, you know, redefinition or redeclaration of storage type or storage type"
    },
    {
      "Time_Start": 1822.46,
      "Time_End": 1828.46,
      "Text": " redeclaration. And then down here we have rewritten foo. And this is showing how we can drive our"
    },
    {
      "Time_Start": 1832.54,
      "Time_End": 1838.5,
      "Text": " patching through symbolic references. So these symbols exist within the target binary and so"
    },
    {
      "Time_Start": 1838.5,
      "Time_End": 1844.5,
      "Text": " we're able to rewrite them using symbol interposition. Now, right here we set the value of"
    },
    {
      "Time_Start": 1845.2,
      "Time_End": 1851.2,
      "Text": " lucky number. It's now initialized to 31337. We print I am the new function foo. We print the"
    },
    {
      "Time_Start": 1853.88,
      "Time_End": 1859.3,
      "Text": " value of lucky number. And then right here we're demonstrating how Shiva patches are able to"
    },
    {
      "Time_Start": 1859.3,
      "Time_End": 1865.38,
      "Text": " resolve shared library functions that don't already have a PLT entry in the executable that"
    },
    {
      "Time_Start": 1865.38,
      "Time_End": 1871.54,
      "Text": " we're patching. And so right here we're calling system to cat this Shiva dot ANSI file and then"
    },
    {
      "Time_Start": 1871.54,
      "Time_End": 1877.8799999999999,
      "Text": " we return dead beef. So we have rewritten foo and we have redeclared lucky number as an"
    },
    {
      "Time_Start": 1877.8799999999999,
      "Time_End": 1883.8,
      "Text": " uninitialized variable. So let's say we want to take this patch and we want to compile it. So we"
    },
    {
      "Time_Start": 1883.8,
      "Time_End": 1889.8,
      "Text": " would, sorry, we would build it just like a relocatable object with a large code model, which"
    },
    {
      "Time_Start": 1893.5,
      "Time_End": 1899.5,
      "Text": " we have to use no pick and then, so we have a relocatable object and we have a large code"
    },
    {
      "Time_Start": 1901.54,
      "Time_End": 1907.54,
      "Text": " model. So this is the object now. You can see the locations in it. Symbol table. And if we want"
    },
    {
      "Time_Start": 1911.8799999999999,
      "Time_End": 1918.34,
      "Text": " to install this patch, there's two ways to do it. So firstly, in many cases we just want to try"
    },
    {
      "Time_Start": 1918.34,
      "Time_End": 1924.72,
      "Text": " the patch out or just test it once without making any modification at all to the target binary."
    },
    {
      "Time_Start": 1924.72,
      "Time_End": 1930.72,
      "Text": " And so test foo without a patch. And now test foo with a patch. We specify the Shiva module path"
    },
    {
      "Time_Start": 1932.9,
      "Time_End": 1938.9,
      "Text": " environment variable. Export it. And then we simply invoke Shiva directly. And now it runs the"
    },
    {
      "Time_Start": 1943.8600000000001,
      "Time_End": 1949.8600000000001,
      "Text": " patch version. So it has been, the executable has been relinked in memory to use the code and data"
    },
    {
      "Time_Start": 1950.66,
      "Time_End": 1956.66,
      "Text": " specified in our patch. Prints I am the new function foo. It then prints 31337 is the lucky"
    },
    {
      "Time_Start": 1957.8600000000001,
      "Time_End": 1963.8600000000001,
      "Text": " number. It prints the Shiva ANSI banner and then prints the return value of dead beef. Now if we"
    },
    {
      "Time_Start": 1964.7,
      "Time_End": 1968.7,
      "Text": " wanted to install this patch permanently, we would have to use the Shiva pre-linker, which installs"
    },
    {
      "Time_Start": 1968.7,
      "Time_End": 1974.7,
      "Text": " some metadata such as the path to Shiva into the insert segment and it updates the dynamic segment"
    },
    {
      "Time_Start": 1975.54,
      "Time_End": 1981.54,
      "Text": " of the executable and adds a few new entries. So let's take a look at that. Let me clear the"
    },
    {
      "Time_Start": 1981.54,
      "Time_End": 1987.54,
      "Text": " screen. Shiva LD works like this. And so I'll give an example. Dash E is the executable, which is"
    },
    {
      "Time_Start": 1988.54,
      "Time_End": 1994.54,
      "Text": " test foo. The patch base name is foopatch.o. The interpreter path is libshiva and the search path"
    },
    {
      "Time_Start": 1997.54,
      "Time_End": 2003.54,
      "Text": " is optshiva modules. And then we'll rename it the same name. So test foo with a patch. And then"
    },
    {
      "Time_Start": 2004.7,
      "Time_End": 2010.7,
      "Text": " if we were to look at the program segments of test foo, we can see that libshiva is now the"
    },
    {
      "Time_Start": 2010.7,
      "Time_End": 2015.7,
      "Text": " interpreter. We also see there's an extra load segment there and that's to make room for the new"
    },
    {
      "Time_Start": 2015.7,
      "Time_End": 2021.7,
      "Text": " dynamic segment. So let's take a look at the dynamic segment and how it's been modified. So the"
    },
    {
      "Time_Start": 2021.7,
      "Time_End": 2027.7,
      "Text": " dynamic segment is actually the same except it has three new entries at the bottom here, which a"
    },
    {
      "Time_Start": 2027.7,
      "Time_End": 2033.7,
      "Text": " readelf hasn't been modified to print what these are. But this is the addresses to the patch base"
    },
    {
      "Time_Start": 2033.7,
      "Time_End": 2039.7,
      "Text": " address to the patch search path, and then the address to the path of the original interpreter,"
    },
    {
      "Time_Start": 2039.7,
      "Time_End": 2045.7,
      "Text": " which is ldlinux.so. And we also have to move the patch or copy the patch into the optshiva"
    },
    {
      "Time_Start": 2048.7,
      "Time_End": 2054.7,
      "Text": " modules directory because that's the search path that we specified. So in any case, now when we"
    },
    {
      "Time_Start": 2054.7,
      "Time_End": 2060.7,
      "Text": " run test foo, it's patched every single time because of that metadata that's been installed. The"
    },
    {
      "Time_Start": 2060.7,
      "Time_End": 2066.7,
      "Text": " only difference between test foo now and before is that the dynamic segment's been updated and the"
    },
    {
      "Time_Start": 2066.7,
      "Time_End": 2072.7,
      "Text": " PT insert segment has been updated. And so another neat little feature is if you call shiva"
    },
    {
      "Time_Start": 2072.7,
      "Time_End": 2078.7,
      "Text": " directly again with the dash U flag on test foo, we'll actually run test foo and it will run it"
    },
    {
      "Time_Start": 2078.7,
      "Time_End": 2084.7,
      "Text": " without installing all the patches. So that's kind of a neat feature. And next we're going to"
    },
    {
      "Time_Start": 2085.7,
      "Time_End": 2091.7,
      "Text": " look at transformations with function splicing."
    },
    {
      "Time_Start": 2091.7,
      "Time_End": 2097.7,
      "Text": " Thank you. There's more. Appreciate it. Thank you. Okay. So I'm going to try to"
    },
    {
      "Time_Start": 2103.7,
      "Time_End": 2109.7,
      "Text": " demonstrate elf transformations as concisely as I can in this example with a program called"
    },
    {
      "Time_Start": 2110.7,
      "Time_End": 2116.7,
      "Text": " testprog. So let's take a quick look at the original source code. So we have this function"
    },
    {
      "Time_Start": 2118.7,
      "Time_End": 2124.7,
      "Text": " foo here. Foo is called down here in main. And foo says if this first argument num is equal to"
    },
    {
      "Time_Start": 2126.7,
      "Time_End": 2132.7,
      "Text": " seven, then go to done. Otherwise, copy banner, which is this const pointer to the string"
    },
    {
      "Time_Start": 2133.7,
      "Time_End": 2139.7,
      "Text": " elf master over into global buff. Global buff is a BSS buffer. And then it prints the value of"
    },
    {
      "Time_Start": 2142.7,
      "Time_End": 2148.7,
      "Text": " this argument string. And so what we want to do here is actually overwrite this function called"
    },
    {
      "Time_Start": 2151.7,
      "Time_End": 2157.7,
      "Text": " printf with some code that first checks to see if str is equal to null. And if it's not, then it"
    },
    {
      "Time_Start": 2158.7,
      "Time_End": 2164.7,
      "Text": " will print it. And then also we want our code, our patch code to print the value of global buff."
    },
    {
      "Time_Start": 2166.7,
      "Time_End": 2172.7,
      "Text": " And so let's take a look here. There's a number of things happening in this patch. So we're"
    },
    {
      "Time_Start": 2172.7,
      "Time_End": 2178.7,
      "Text": " actually going to start at the bottom. So firstly, over here on the left in the original source,"
    },
    {
      "Time_Start": 2178.7,
      "Time_End": 2184.7,
      "Text": " we have bar. And in our patch code, we rewrite bar. As we can see, it adds the value of two"
    },
    {
      "Time_Start": 2184.7000000000003,
      "Time_End": 2190.7000000000003,
      "Text": " variables that were added in this patch, this data val. It adds the variables together and then"
    },
    {
      "Time_Start": 2190.7000000000003,
      "Time_End": 2196.7000000000003,
      "Text": " prints the sum. And then up here, so bar is being completely rewritten with symbol interposition."
    },
    {
      "Time_Start": 2198.7000000000003,
      "Time_End": 2204.7000000000003,
      "Text": " And then moving up here, we have the actual splice code, the splice patch. This is how"
    },
    {
      "Time_Start": 2205.7000000000003,
      "Time_End": 2211.7000000000003,
      "Text": " transformations work when developing Sheba patches that need to splice code into an existing"
    },
    {
      "Time_Start": 2211.7000000000003,
      "Time_End": 2217.7000000000003,
      "Text": " function. And so this macro right here is used. So we are splicing into the function foo."
    },
    {
      "Time_Start": 2218.7000000000003,
      "Time_End": 2224.7000000000003,
      "Text": " The address to start patching at is 818, and the stop address is 828. And so coming down"
    },
    {
      "Time_Start": 2227.7000000000003,
      "Time_End": 2233.7000000000003,
      "Text": " into the actual splice code, let's start right here. We have if str is not equal to null,"
    },
    {
      "Time_Start": 2234.7000000000003,
      "Time_End": 2240.7000000000003,
      "Text": " then print the string. And if you notice, we're using fprintf instead of printf, which was in the"
    },
    {
      "Time_Start": 2240.7000000000003,
      "Time_End": 2246.7000000000003,
      "Text": " original program. And this is, again, just illustrating strong global symbol resolution. And then"
    },
    {
      "Time_Start": 2247.7000000000003,
      "Time_End": 2253.7000000000003,
      "Text": " after that, we use fprintf to print the value of global buff, which illustrates our patch ability to"
    },
    {
      "Time_Start": 2254.7000000000003,
      "Time_End": 2260.7000000000003,
      "Text": " use the extern keyword. So we're using the extern keyword to get a hold of global buff, which is a"
    },
    {
      "Time_Start": 2261.7000000000003,
      "Time_End": 2267.7000000000003,
      "Text": " global variable from the program that we're patching. And so after that, we call bar. And this is"
    },
    {
      "Time_Start": 2267.7000000000003,
      "Time_End": 2273.7000000000003,
      "Text": " where we'll link to the new function bar instead of the original function bar. And when main calls"
    },
    {
      "Time_Start": 2274.7000000000003,
      "Time_End": 2280.7000000000003,
      "Text": " bar, it will also link to our new function bar, of course. Anyhow, so back up to this transformation"
    },
    {
      "Time_Start": 2281.7000000000003,
      "Time_End": 2287.7000000000003,
      "Text": " macro, we want to patch at 818. Let's take a quick look at why. So we'll look at the program"
    },
    {
      "Time_Start": 2288.7000000000003,
      "Time_End": 2294.7000000000003,
      "Text": " assembly down here at function foo. We're going to be patching from here to here. Actually, to right"
    },
    {
      "Time_Start": 2295.7000000000003,
      "Time_End": 2301.7000000000003,
      "Text": " here. So our start address is 818. And the last address that we patch is 824, which makes our stop"
    },
    {
      "Time_Start": 2304.7000000000003,
      "Time_End": 2310.7000000000003,
      "Text": " address 828. And 828 and all of the code after it will be shifted forward as needed based on the size"
    },
    {
      "Time_Start": 2312.7000000000003,
      "Time_End": 2318.7000000000003,
      "Text": " of the code being spliced in. And in our case, we're splicing a larger amount of code in. Let's just"
    },
    {
      "Time_Start": 2319.7000000000003,
      "Time_End": 2325.7000000000003,
      "Text": " build our patch real quickly. And now we have a relocatable object called patch.o. These are the"
    },
    {
      "Time_Start": 2326.7000000000003,
      "Time_End": 2332.7000000000003,
      "Text": " relocations for it. And if we look at user object dump, you can see this is the splice code, this"
    },
    {
      "Time_Start": 2334.7000000000003,
      "Time_End": 2340.7000000000003,
      "Text": " whole function right here. And you can see it uses a special symbol name called Shiva splice FN name"
    },
    {
      "Time_Start": 2341.7000000000003,
      "Time_End": 2347.7000000000003,
      "Text": " and then the function that's being spliced as foo. This directs Shiva to use the function splicing"
    },
    {
      "Time_Start": 2348.7000000000003,
      "Time_End": 2354.7000000000003,
      "Text": " and so Shiva will splice all of this code in. The procedure prologue and epilogue won't be included."
    },
    {
      "Time_Start": 2357.7000000000003,
      "Time_End": 2363.7000000000003,
      "Text": " All of this code will be relocated and transformed essentially. It will be inserted and spliced into"
    },
    {
      "Time_Start": 2365.7000000000003,
      "Time_End": 2371.7000000000003,
      "Text": " the function foo again into this location right here. So we're actually adding quite a bit of code."
    },
    {
      "Time_Start": 2372.7000000000003,
      "Time_End": 2378.7000000000003,
      "Text": " And so this will rewrite the entire function foo. It will actually be rewritten from scratch in a"
    },
    {
      "Time_Start": 2381.7000000000003,
      "Time_End": 2387.7000000000003,
      "Text": " different area in memory. And the reason that in the source code I included this if num is equal to"
    },
    {
      "Time_Start": 2388.7000000000003,
      "Time_End": 2394.7000000000003,
      "Text": " seven, go to done, is to illustrate how it will have to be, the assembly code for that will have to"
    },
    {
      "Time_Start": 2394.7000000000003,
      "Time_End": 2400.7000000000003,
      "Text": " be relinked in the binary or in memory once our patch code is inserted here because the patch code"
    },
    {
      "Time_Start": 2402.7000000000003,
      "Time_End": 2408.7000000000003,
      "Text": " is much larger. And so for this to jump down to done, the offsets will change. So this also,"
    },
    {
      "Time_Start": 2409.7000000000003,
      "Time_End": 2415.7000000000003,
      "Text": " patching this program also illustrates Shiva's ability to relink the executable as needed when the"
    },
    {
      "Time_Start": 2417.7000000000003,
      "Time_End": 2423.7000000000003,
      "Text": " patch code extends the size of the function. And this works by Shiva generating on the fly"
    },
    {
      "Time_Start": 2423.7000000000003,
      "Time_End": 2429.7000000000003,
      "Text": " relocations for the executable by looking at a control flow graph. And so anyhow, let's just try to"
    },
    {
      "Time_Start": 2429.7000000000003,
      "Time_End": 2435.7000000000003,
      "Text": " install this patch and see how it works. So again, testprog looks like this when we run it."
    },
    {
      "Time_Start": 2436.7000000000003,
      "Time_End": 2442.7000000000003,
      "Text": " Now let's install the patch dynamically. We'll just run Shiva directly. The patch is patch.o."
    },
    {
      "Time_Start": 2445.7000000000003,
      "Time_End": 2451.7000000000003,
      "Text": " Patch.o and the Shiva will run Shiva directly and execute testprog."
    },
    {
      "Time_Start": 2453.7000000000003,
      "Time_End": 2459.7000000000003,
      "Text": " And now we see it's working as expected. It only prints the argument we pass it when we actually pass"
    },
    {
      "Time_Start": 2460.7000000000003,
      "Time_End": 2466.7000000000003,
      "Text": " it an argument. Let's see. And if we don't pass it an argument, it doesn't. And if we put seven"
    },
    {
      "Time_Start": 2471.7000000000003,
      "Time_End": 2477.7000000000003,
      "Text": " arguments, it jumps right down to done and doesn't print, doesn't do any of the other stuff that it"
    },
    {
      "Time_Start": 2478.7000000000003,
      "Time_End": 2484.7000000000003,
      "Text": " was doing. So it's actually working exactly how we modified the program to behave. Now again, if we"
    },
    {
      "Time_Start": 2486.7000000000003,
      "Time_End": 2492.7000000000003,
      "Text": " run testprog without Shiva, it still does the same old behavior. If we want to link the program"
    },
    {
      "Time_Start": 2492.7000000000003,
      "Time_End": 2498.7000000000003,
      "Text": " permanently, then we use the Shiva prelinker as demonstrated before. Shiva is the interpreter."
    },
    {
      "Time_Start": 2499.7000000000003,
      "Time_End": 2505.7000000000003,
      "Text": " The search path is opShivaModules. The output is testprog. We need to copy the patch into opShivaModules"
    },
    {
      "Time_Start": 2508.7000000000003,
      "Time_End": 2514.7000000000003,
      "Text": " just the same way we'd copy a shared object into the lib directory. So now when we run Shiva"
    },
    {
      "Time_Start": 2516.7000000000003,
      "Time_End": 2522.7000000000003,
      "Text": " directly, or I mean when we run the program directly, it works every time it's patched. And again,"
    },
    {
      "Time_Start": 2523.7000000000003,
      "Time_End": 2529.7000000000003,
      "Text": " the program's metadata has been modified. We can see libShiva is the interpreter, et cetera. So that"
    },
    {
      "Time_Start": 2535.7000000000003,
      "Time_End": 2541.7000000000003,
      "Text": " is function splicing. Yes. Thank you. What happened to my slides there? Oh, there we go."
    },
    {
      "Time_Start": 2553.7000000000003,
      "Time_End": 2559.7000000000003,
      "Text": " So I've got a couple of minutes left here. Let me pop the slides back up. I'm not real familiar"
    },
    {
      "Time_Start": 2564.7000000000003,
      "Time_End": 2570.7000000000003,
      "Text": " with Adobe. But whatever the case, let's see here. Sorry. I'm not familiar with Adobe. I'm"
    },
    {
      "Time_Start": 2583.7000000000003,
      "Time_End": 2589.7000000000003,
      "Text": " not familiar with Adobe. I don't know. Yeah, let me. I have a good idea here. Well, there"
    },
    {
      "Time_Start": 2592.7000000000003,
      "Time_End": 2598.7000000000003,
      "Text": " really wasn't. There's one last slide here. Give me just a moment. What's that? Control L."
    },
    {
      "Time_Start": 2613.7000000000003,
      "Time_End": 2619.7000000000003,
      "Text": " Well, yes. Thank you. Look at me. Here I am. Okay. There's one last slide that I would like to"
    },
    {
      "Time_Start": 2632.7000000000003,
      "Time_End": 2638.7000000000003,
      "Text": " just leave up for a moment if I could. So I guess you can specify the slides. I'm not familiar"
    },
    {
      "Time_Start": 2642.7000000000003,
      "Time_End": 2648.7000000000003,
      "Text": " with slide two. I think it's like slide 51 that I'm looking for. Ah, there you go. Okay."
    },
    {
      "Time_Start": 2650.7000000000003,
      "Time_End": 2656.7000000000003,
      "Text": " Up until 51. Just close your eyes. I don't want to cause any seizures. All right. Thank you."
    },
    {
      "Time_Start": 2659.7000000000003,
      "Time_End": 2663.7000000000003,
      "Text": " So firstly, I just want to say thank you to my son, Jayden, for helping me with the video"
    },
    {
      "Time_Start": 2663.7000000000003,
      "Time_End": 2669.7000000000003,
      "Text": " editing. It's not my strong suit for the demo. Thank you, Jayden. Appreciate that."
    },
    {
      "Time_Start": 2669.7000000000003,
      "Time_End": 2673.7000000000003,
      "Text": " He tries on YouTube. And I want to say thank you to my wife, Teresa O'Neill, for being such a"
    },
    {
      "Time_Start": 2673.7000000000003,
      "Time_End": 2679.7000000000003,
      "Text": " powerhouse behind me. Thank you, honey. And my mother. My mother bought me every book by"
    },
    {
      "Time_Start": 2679.7000000000003,
      "Time_End": 2685.7000000000003,
      "Text": " Richard Stevenson by the time I was about 16. I had them all. Unix Network Programming."
    },
    {
      "Time_Start": 2685.7000000000003,
      "Time_End": 2691.7000000000003,
      "Text": " She was on it to help me get educated on what I wanted to learn. So thanks, Mom. Love you."
    },
    {
      "Time_Start": 2691.7000000000003,
      "Time_End": 2697.7000000000003,
      "Text": " And thanks to my son, Mick, for being here. He just turned 18. So super grateful to have my"
    },
    {
      "Time_Start": 2697.7000000000003,
      "Time_End": 2703.7000000000003,
      "Text": " son with me. And super grateful to be able to share this with you guys. I have open sourced it"
    },
    {
      "Time_Start": 2703.7000000000003,
      "Time_End": 2711.7000000000003,
      "Text": " today. I'm sure email me if you have any problems. There's the Shiva user manual. It's still a"
    },
    {
      "Time_Start": 2711.7000000000003,
      "Time_End": 2717.7000000000003,
      "Text": " work in progress. But it gets deeper. There's also some design specifications that are in the"
    },
    {
      "Time_Start": 2717.7000000000003,
      "Time_End": 2723.7000000000003,
      "Text": " Shiva repository. They're a little behind date. But if you want to learn more about it, go to"
    },
    {
      "Time_Start": 2723.7000000000003,
      "Time_End": 2729.7000000000003,
      "Text": " the website, ArcanaResearch.io, Shiva. And feel free to reach out to me for any questions"
    },
    {
      "Time_Start": 2729.7000000000003,
      "Time_End": 2735.7000000000003,
      "Text": " about it. And thank you. Grateful for everybody being present. Is there any questions for 30"
    },
    {
      "Time_Start": 2735.7000000000003,
      "Time_End": 2743.7000000000003,
      "Text": " seconds? You got three seconds. All right."
    },
    {
      "Time_Start": 2743.7000000000003,
      "Time_End": 2747.7000000000003,
      "Text": " All right."
    }
  ]
}