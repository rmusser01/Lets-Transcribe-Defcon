{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 6.0,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Thanks for sticking with us today. It's Sunday, it's a bit more chill. Some of us are already"
    },
    {
      "Time_Start": 12.42,
      "Time_End": 19.26,
      "Text": " flying home. Some of us are recovering from hangover. And the last of us are here. Thanks for"
    },
    {
      "Time_Start": 19.26,
      "Time_End": 24.72,
      "Text": " sticking with us. There's also some zombies there. Okay. So today we are presenting the"
    },
    {
      "Time_Start": 24.72,
      "Time_End": 30.9,
      "Text": " results of our research. Which is and we present a new approach for stack spoofing"
    },
    {
      "Time_Start": 30.9,
      "Time_End": 36.9,
      "Text": " targeting Windows on like specifically 64 bit architecture of Windows. Who we are? We are"
    },
    {
      "Time_Start": 38.76,
      "Time_End": 44.86,
      "Text": " three friends. I'm Alessandro Magnosi. I'm a principal security consultant in BSI where I do"
    },
    {
      "Time_Start": 44.86,
      "Time_End": 50.4,
      "Text": " mostly red teaming, offensive tool development and white box assessments. So source code"
    },
    {
      "Time_Start": 50.4,
      "Time_End": 56.5,
      "Text": " review, fuzzing and stuff like that. In my free time I work for I maintain some tools, some"
    },
    {
      "Time_Start": 56.5,
      "Time_End": 62.5,
      "Text": " offensive tools in industry which is an initiative by Marcello Salvari to support open"
    },
    {
      "Time_Start": 65.08,
      "Time_End": 71.08,
      "Text": " source developers. And in the rest of my time I'm a bug hunter for CNET red team. And there's"
    },
    {
      "Time_Start": 73.03999999999999,
      "Time_End": 79.03999999999999,
      "Text": " my colleague. Hey, my name is Arash. I work at CyberArk. I have kind of a dual job. I'm"
    },
    {
      "Time_Start": 81.22,
      "Time_End": 85.86,
      "Text": " very fortunate. I get to do a lot of threat hunting, detection engineering and I also get to do"
    },
    {
      "Time_Start": 85.86,
      "Time_End": 93.14,
      "Text": " red teaming when time allows for it. And our friend Thanos unfortunately couldn't be here"
    },
    {
      "Time_Start": 93.14,
      "Time_End": 99.18,
      "Text": " today. He also contributed to this work. He's a red teamer at Netitude. He was also great and"
    },
    {
      "Time_Start": 99.18,
      "Time_End": 105.18,
      "Text": " he contributed a lot here. So we we want to make sure he's mentioned. So here we are. Um so a"
    },
    {
      "Time_Start": 105.94000000000001,
      "Time_End": 112.9,
      "Text": " bit of story about this. All of this started back in 2022 when uh Namazo, a security"
    },
    {
      "Time_Start": 112.9,
      "Time_End": 119.28,
      "Text": " researcher and developer uh released a pop on Twitter like an image uh where it was showing"
    },
    {
      "Time_Start": 119.28,
      "Time_End": 124.28,
      "Text": " like a technique which then we uh popularized and um fix also a bit. Um and um this"
    },
    {
      "Time_Start": 128.88,
      "Time_End": 133.36,
      "Text": " actually like we were very interested in this research, in his research, in his work. So we"
    },
    {
      "Time_Start": 133.4,
      "Time_End": 139.5,
      "Text": " reached down to it. We started developing this in house. Um of course we didn't know a lot"
    },
    {
      "Time_Start": 139.5,
      "Time_End": 144.38000000000002,
      "Text": " about about what was involved with the technique. So we started this uh research and"
    },
    {
      "Time_Start": 144.38000000000002,
      "Time_End": 151.38000000000002,
      "Text": " development uh project. Uh we developed our own like version of the um of the technique"
    },
    {
      "Time_Start": 151.38000000000002,
      "Time_End": 158.06,
      "Text": " shown by Namazo. And after that we um continue researching on this technique. We will uh"
    },
    {
      "Time_Start": 158.06,
      "Time_End": 163.06,
      "Text": " also present, indeed we will also present a like the detection part for this uh technique"
    },
    {
      "Time_Start": 163.06,
      "Time_End": 169.94,
      "Text": " and other additional uh research avenues that we researched. So just to give you a bit of"
    },
    {
      "Time_Start": 169.94,
      "Time_End": 174.3,
      "Text": " background, let's define what stack spoofing is. What we what we mean with stack spoofing."
    },
    {
      "Time_Start": 174.3,
      "Time_End": 179.42000000000002,
      "Text": " So of course you know that when you start a process on Windows, when you execute a binary,"
    },
    {
      "Time_Start": 179.42000000000002,
      "Time_End": 184.46,
      "Text": " you create a process in Windows which is a container and then one or more threads are tasked"
    },
    {
      "Time_Start": 184.48000000000002,
      "Time_End": 190.46,
      "Text": " with executing the real code of uh of the program. Every thread maintains a cold stack which"
    },
    {
      "Time_Start": 190.46,
      "Time_End": 195.4,
      "Text": " is an area of memory organized as a stack that maintains the information about all active"
    },
    {
      "Time_Start": 195.4,
      "Time_End": 200.60000000000002,
      "Text": " subroutines in a given time for a given thread. And what we do with spoofing is that we want"
    },
    {
      "Time_Start": 200.60000000000002,
      "Time_End": 205.60000000000002,
      "Text": " to um we want to create to substitute the frames with fake ones and this is usually never"
    },
    {
      "Time_Start": 206.22,
      "Time_End": 211.22,
      "Text": " done for non-malicious activity. This is always done for uh malware to hide the uh the"
    },
    {
      "Time_Start": 214.79999999999998,
      "Time_End": 219.79999999999998,
      "Text": " execution flow or similar stuff. So you will see here four different frames and why I put"
    },
    {
      "Time_Start": 222.6,
      "Time_End": 227.84,
      "Text": " this here is just to let you know what like to let you see what a cold stack is and you will"
    },
    {
      "Time_Start": 227.84,
      "Time_End": 233.28,
      "Text": " see that there are certain things that are like uh that appears that are common to uh to a"
    },
    {
      "Time_Start": 233.3,
      "Time_End": 239.34,
      "Text": " cold stack. For example we define this first two threads for this talk we will just talk about"
    },
    {
      "Time_Start": 239.34,
      "Time_End": 244.94,
      "Text": " this two frames as thread initialization frames which are usually at the bottom of the stack"
    },
    {
      "Time_Start": 244.94,
      "Time_End": 251.14,
      "Text": " of the cold stack. Uh like at the top actually of the cold stack. Then you have internal"
    },
    {
      "Time_Start": 251.14,
      "Time_End": 257.02,
      "Text": " frames of a specific programs that we will refer to this during the talk as a main modules"
    },
    {
      "Time_Start": 257.02,
      "Time_End": 262.02,
      "Text": " frames. And then you have the um the frames related to uh uh a cold stack. And then you have"
    },
    {
      "Time_Start": 263.6,
      "Time_End": 268.6,
      "Text": " a cold API uh an API cold. So why this is um how this is calculated by Windows. Um so the"
    },
    {
      "Time_Start": 272.46000000000004,
      "Time_End": 278.34000000000003,
      "Text": " stack is uh evaluated by Windows using an unwinding algorithm. An unwinding algorithm. And"
    },
    {
      "Time_Start": 278.34000000000003,
      "Time_End": 283.48,
      "Text": " this is this uses the information contained in the P data section of a binary or related"
    },
    {
      "Time_Start": 283.48,
      "Time_End": 289.24,
      "Text": " DLL. And in this P data section you usually have uh an exception directory. We contain all"
    },
    {
      "Time_Start": 289.24,
      "Time_End": 295.22,
      "Text": " the information about the functions. Specifically uh information about the um like every"
    },
    {
      "Time_Start": 295.22,
      "Time_End": 300.28000000000003,
      "Text": " every entry uh runtime function entry in this table contains information about the begin address"
    },
    {
      "Time_Start": 300.28000000000003,
      "Time_End": 304.42,
      "Text": " of a function, the end address. And a pointer to a structure which is the wind of a wind"
    },
    {
      "Time_Start": 304.42,
      "Time_End": 309.8,
      "Text": " infrastructure that contains um information about the size of the prologue, the count of"
    },
    {
      "Time_Start": 309.8,
      "Time_End": 315.8,
      "Text": " codes and all the in all the operations that were performed in a prologue of a specific"
    },
    {
      "Time_Start": 315.8,
      "Time_End": 323.14,
      "Text": " function. Um now why this is important. I mean this is used by uh by Windows to manage"
    },
    {
      "Time_Start": 323.14,
      "Time_End": 329.82,
      "Text": " exceptions. Uh but what we are interested in is the usage that this is done to calculate the"
    },
    {
      "Time_Start": 329.82,
      "Time_End": 334.42,
      "Text": " cold stack at runtime. And to calculate that what happens is that Windows evaluate the"
    },
    {
      "Time_Start": 334.42,
      "Time_End": 340.6,
      "Text": " frame um a cold a cold frame size a cold frame size uh dynamically using collecting the"
    },
    {
      "Time_Start": 340.6,
      "Time_End": 345.34000000000003,
      "Text": " information collecting the codes so the operation in the prologue that actually affected"
    },
    {
      "Time_Start": 345.78000000000003,
      "Time_End": 351.98,
      "Text": " the uh that impacted the frame size. And the operation are usually uh push of course. If you"
    },
    {
      "Time_Start": 351.98,
      "Time_End": 359.18,
      "Text": " push a register you're subbing eight on the stack. And if you unlock if you allocate memory"
    },
    {
      "Time_Start": 359.18,
      "Time_End": 364.86,
      "Text": " you're subbing from the uh from RSP. So you allocate state on the stack. So these two main"
    },
    {
      "Time_Start": 364.86,
      "Time_End": 370.34000000000003,
      "Text": " operation are what modify the the frame size. And then there is the push Mac frame which is"
    },
    {
      "Time_Start": 370.34000000000003,
      "Time_End": 374.84000000000003,
      "Text": " really not interesting for for our talk but yeah it's another it's another it's another"
    },
    {
      "Time_Start": 374.84000000000003,
      "Time_End": 380.58000000000004,
      "Text": " operation that impact the frame size. And this is important this is needed in in Windows"
    },
    {
      "Time_Start": 380.58000000000004,
      "Time_End": 385.56000000000006,
      "Text": " because if you remember 32 bit architecture um you in the prologue you always have like a"
    },
    {
      "Time_Start": 385.56000000000006,
      "Time_End": 391.1,
      "Text": " push EBP and then you uh you save the the base pointer so you have the base pointer pointed"
    },
    {
      "Time_Start": 391.1,
      "Time_End": 397.34000000000003,
      "Text": " to the um to the to the top of the to the top of the frame. And then you have the uh the ESP"
    },
    {
      "Time_Start": 397.34000000000003,
      "Time_End": 404.24,
      "Text": " pointing to the to the to the bottom of the stack. And this is useful um and like the the"
    },
    {
      "Time_Start": 404.24,
      "Time_End": 409.62,
      "Text": " contrary but yeah this is used to this is used for uh this is very useful to uh evaluate the"
    },
    {
      "Time_Start": 409.62,
      "Time_End": 415.02000000000004,
      "Text": " code stack because you can just navigate back the chain of EBP that are pushed on the stack."
    },
    {
      "Time_Start": 415.02000000000004,
      "Time_End": 419.52000000000004,
      "Text": " But in 64 bit this is not possible because RSP is used both as a base pointer and a stack"
    },
    {
      "Time_Start": 419.52000000000004,
      "Time_End": 426.26000000000005,
      "Text": " pointer so to evaluate the code stack we need to um recursively get the size of uh of a"
    },
    {
      "Time_Start": 426.28,
      "Time_End": 431.8,
      "Text": " stack frame and then recover the return address and then evaluate again the code stack"
    },
    {
      "Time_Start": 431.8,
      "Time_End": 437.06,
      "Text": " frame and then uh the return address and traverse it back like this. So why we are"
    },
    {
      "Time_Start": 437.06,
      "Time_End": 440.44,
      "Text": " interested in the code stack? We are interested in the code stack because when you execute"
    },
    {
      "Time_Start": 440.44,
      "Time_End": 445.24,
      "Text": " malware on Windows you can generate some anomalies that can help with detection. So we"
    },
    {
      "Time_Start": 445.24,
      "Time_End": 450.03999999999996,
      "Text": " have in memory execution can be detected eh because when you inject code in memory if you're"
    },
    {
      "Time_Start": 450.03999999999996,
      "Time_End": 455.68,
      "Text": " using especially a um to to to run a malware you uh do process injection for example or"
    },
    {
      "Time_Start": 455.7,
      "Time_End": 461.08,
      "Text": " code injection and you're using an executable section on the heap what happens is that that"
    },
    {
      "Time_Start": 461.08,
      "Time_End": 466.64,
      "Text": " section will not have uh module associated so it that that executable memory is not backed"
    },
    {
      "Time_Start": 466.64,
      "Time_End": 470.82,
      "Text": " by a file on disk. If there is no file there is no P data section. If there is no P data"
    },
    {
      "Time_Start": 470.82,
      "Time_End": 474.72,
      "Text": " section there is no exception directory. If there is no exception directory there are"
    },
    {
      "Time_Start": 474.72,
      "Time_End": 479.12,
      "Text": " none like there is no way there is no information that the unwinding algorithm unwinding"
    },
    {
      "Time_Start": 479.14,
      "Time_End": 486.24,
      "Text": " algorithm can use to um dynamically get the size of that specific code. So what you"
    },
    {
      "Time_Start": 486.24,
      "Time_End": 492.88,
      "Text": " happen what will happen is that oh too much sorry. Uh what will happen is that you will"
    },
    {
      "Time_Start": 492.88,
      "Time_End": 496.88,
      "Text": " have something like this. So you will have a frame at a certain point that is not"
    },
    {
      "Time_Start": 496.88,
      "Time_End": 503.76,
      "Text": " resolvable and this is associate associated with uh with an unbacked memory region. Uh the"
    },
    {
      "Time_Start": 503.76,
      "Time_End": 508.44,
      "Text": " other thing you can uh you can the other anomaly that you can detect from the code stack is"
    },
    {
      "Time_Start": 508.46,
      "Time_End": 514.32,
      "Text": " when you use uh directory in direct syscalls and we are referring to direct system calls"
    },
    {
      "Time_Start": 514.32,
      "Time_End": 519.5,
      "Text": " actually direct anti-function execution like get proc address, NTDLL, anti-function and"
    },
    {
      "Time_Start": 519.5,
      "Time_End": 523.76,
      "Text": " then execute the function pointer is calling directly the anti-function and this will"
    },
    {
      "Time_Start": 523.76,
      "Time_End": 528.78,
      "Text": " generate a call stack that misses the um uh that misses the um why? Sorry for that. Uh that"
    },
    {
      "Time_Start": 529.78,
      "Time_End": 534.78,
      "Text": " misses the um what we the the frames associated with high level API call. This stack frame is"
    },
    {
      "Time_Start": 542.66,
      "Time_End": 546.6999999999999,
      "Text": " also generated if you're using an indirect system call so if you're just locating the"
    },
    {
      "Time_Start": 546.6999999999999,
      "Time_End": 552.4399999999999,
      "Text": " syscall instruction in NTDLL and then you jump to it. So the frame the stack the stack is"
    },
    {
      "Time_Start": 552.44,
      "Time_End": 559.24,
      "Text": " pretty much the the same and it misses the high level API frames of course. But these are"
    },
    {
      "Time_Start": 559.24,
      "Time_End": 563.94,
      "Text": " the anomalies when you want to detect this well you can do a periodic scan so you have a"
    },
    {
      "Time_Start": 563.94,
      "Time_End": 569.98,
      "Text": " tool that stop the frames uh that stop the threads uh system wide. Get the context and"
    },
    {
      "Time_Start": 569.98,
      "Time_End": 574.9200000000001,
      "Text": " unlock the stack frame. You can have a conditional scan which is a periodic scan with another"
    },
    {
      "Time_Start": 574.9200000000001,
      "Time_End": 580.2600000000001,
      "Text": " filter to filter for specific kind of threads that are in specific wait states for example."
    },
    {
      "Time_Start": 580.28,
      "Time_End": 585.56,
      "Text": " Or you can use hooking or kernel tracing which is instead uh done dynamically when a system"
    },
    {
      "Time_Start": 585.56,
      "Time_End": 592.56,
      "Text": " call is involved you can use something like DWTI or another uh kind of uh driver to get the uh"
    },
    {
      "Time_Start": 592.56,
      "Time_End": 597.56,
      "Text": " to get the user mode uh call stack and and for detections. So to like S-tack spoofing uh"
    },
    {
      "Time_Start": 601.64,
      "Time_End": 607.8,
      "Text": " previous research on the topic uh lead to the development of techniques to defend from"
    },
    {
      "Time_Start": 607.82,
      "Time_End": 613.96,
      "Text": " specific scan, periodic scan, like stack truncation, stack cloning and stack hiding or uh to"
    },
    {
      "Time_Start": 613.96,
      "Time_End": 620.7600000000001,
      "Text": " defend against specific um specific specific rule based detection on the call stack when"
    },
    {
      "Time_Start": 620.7600000000001,
      "Time_End": 625.5400000000001,
      "Text": " executing a specific API. So stack truncation was probably the first one used and it's an"
    },
    {
      "Time_Start": 625.5400000000001,
      "Time_End": 630.5400000000001,
      "Text": " evolution it's a variation of normal return address spoofing where the where we replace the"
    },
    {
      "Time_Start": 631.02,
      "Time_End": 636.02,
      "Text": " malicious frame with a with a trampoline uh usually in a DLL or an executable and then we"
    },
    {
      "Time_Start": 640.3,
      "Time_End": 645.3,
      "Text": " nullify the return uh the return address prior to the um to the trampoline. This way we have a"
    },
    {
      "Time_Start": 648.3399999999999,
      "Time_End": 653.3399999999999,
      "Text": " cut call stack like this which is surely better than having garbage in the call stack but it's"
    },
    {
      "Time_Start": 653.72,
      "Time_End": 658.72,
      "Text": " still uh it still has a defect which is this this stack is not unwindable. So we still can have"
    },
    {
      "Time_Start": 663.46,
      "Time_End": 669.4,
      "Text": " a detection for this reason. Uh then we have stack crafting. Stack crafting instead is a"
    },
    {
      "Time_Start": 669.4,
      "Time_End": 674.0600000000001,
      "Text": " technique that is usually asynchronous like we have a system uh there is a specific"
    },
    {
      "Time_Start": 674.0600000000001,
      "Time_End": 680.6,
      "Text": " function that get called um and there are specific processes using that function in a"
    },
    {
      "Time_Start": 680.6,
      "Time_End": 685.5,
      "Text": " legitimate way. So what we do is that we record that execution that call stack at that"
    },
    {
      "Time_Start": 685.5,
      "Time_End": 692.6800000000001,
      "Text": " point and when we need to call our target function we just craft the same kind of uh of"
    },
    {
      "Time_Start": 692.6800000000001,
      "Time_End": 697.12,
      "Text": " call stack. So that we can in this way we can bypass detection like sysmon, antin for"
    },
    {
      "Time_Start": 697.12,
      "Time_End": 703.82,
      "Text": " specific call stack trace or uh similar similar detection. Then we have stack cloning. This"
    },
    {
      "Time_Start": 703.82,
      "Time_End": 708.9,
      "Text": " as well has been developed to defend from conditional scanning and the idea is simple."
    },
    {
      "Time_Start": 708.9399999999999,
      "Time_End": 714.24,
      "Text": " Usually our implants go to sleep for most of like usually sleep most of the time. So when I"
    },
    {
      "Time_Start": 714.24,
      "Time_End": 720.04,
      "Text": " want to sleep using uh a delay execution like rate delay execution using a sleep or using a"
    },
    {
      "Time_Start": 720.04,
      "Time_End": 724.54,
      "Text": " wait user request at wait state using uh wait for single object. Well what I need to do is"
    },
    {
      "Time_Start": 724.54,
      "Time_End": 728.88,
      "Text": " just ant for a thread that is already with that state that is sleeping with that state and"
    },
    {
      "Time_Start": 728.88,
      "Time_End": 735.36,
      "Text": " then clone is call stack. This will make the call stack perfect perfectly legitimate uh or"
    },
    {
      "Time_Start": 735.6800000000001,
      "Time_End": 741.5600000000001,
      "Text": " apparently legitimate so uh we will be defended by conditional scan that ant for sleeping"
    },
    {
      "Time_Start": 741.5600000000001,
      "Time_End": 748.8000000000001,
      "Text": " begins. Stack hiding is similar but it uses uh another another kind of uh approach. So the"
    },
    {
      "Time_Start": 748.8000000000001,
      "Time_End": 755.0,
      "Text": " approach is that I will transform my thread in a I have a malicious code executing in memory"
    },
    {
      "Time_Start": 755.0,
      "Time_End": 759.58,
      "Text": " uh I transform my thread in a fiber so I have a fiber thread now and then I create another"
    },
    {
      "Time_Start": 759.58,
      "Time_End": 763.6800000000001,
      "Text": " fiber with a legitimate call stack that I use just for sleeping. So when I need to sleep I"
    },
    {
      "Time_Start": 763.7,
      "Time_End": 769.24,
      "Text": " just switch to the fiber thread to the other fiber that I created for sleeping and then this"
    },
    {
      "Time_Start": 769.24,
      "Time_End": 774.6800000000001,
      "Text": " process gets repeated when I need to go back from sleep. And this is what you have like this"
    },
    {
      "Time_Start": 774.6800000000001,
      "Time_End": 781.1200000000001,
      "Text": " is the uh this is the fiber with the legitimate call stack and this is the code uh in in"
    },
    {
      "Time_Start": 781.1200000000001,
      "Time_End": 785.96,
      "Text": " memory. So they you can see that there are two different area two different memory area for"
    },
    {
      "Time_Start": 785.96,
      "Time_End": 792.36,
      "Text": " the stacks uh and just one is active at a time. So what is our token contribution? Today we"
    },
    {
      "Time_Start": 792.38,
      "Time_End": 797.32,
      "Text": " want to present two techniques uh full moon and half moon that are designed to uh"
    },
    {
      "Time_Start": 797.32,
      "Time_End": 802.32,
      "Text": " obfuscate the stack at run time uh to avoid detection kind of base detection uh mostly uh or"
    },
    {
      "Time_Start": 804.6,
      "Time_End": 809.0600000000001,
      "Text": " hooking detection. So stack moving has some properties like it hides the caller from"
    },
    {
      "Time_Start": 809.0600000000001,
      "Time_End": 813.6,
      "Text": " memory, it obfuscates the stack so it's difficult to understand which kind of uh call stack"
    },
    {
      "Time_Start": 813.6,
      "Time_End": 818.64,
      "Text": " was actually taken was actually generated when executing a specific ABI or system call and"
    },
    {
      "Time_Start": 818.66,
      "Time_End": 823.86,
      "Text": " then it has an auto restore an auto restore technique so usually we use ROP to restore the"
    },
    {
      "Time_Start": 823.86,
      "Time_End": 830.4,
      "Text": " stack. We will see this is not always possible but yeah. Uh most most of them uses like"
    },
    {
      "Time_Start": 830.4,
      "Time_End": 835.68,
      "Text": " most for most for the most part is used ROP to restore the stack. So full moon is the"
    },
    {
      "Time_Start": 835.68,
      "Time_End": 840.24,
      "Text": " first technique and it operates like that. We have a function that we want to spoof API or"
    },
    {
      "Time_Start": 840.24,
      "Time_End": 844.68,
      "Text": " whatever and what we do of course of course we are executing this from from our main"
    },
    {
      "Time_Start": 844.72,
      "Time_End": 850.0600000000001,
      "Text": " module that can be in memory or can be like in this case it seems like it it's a program but"
    },
    {
      "Time_Start": 850.0600000000001,
      "Time_End": 855.5600000000001,
      "Text": " it can be even injected in memory there is no there is no problem. Uh this is for main"
    },
    {
      "Time_Start": 855.5600000000001,
      "Time_End": 861.6800000000001,
      "Text": " module if you remember I'm I'm referring to all the frames generated by the main module so"
    },
    {
      "Time_Start": 861.6800000000001,
      "Time_End": 867.5200000000001,
      "Text": " it's the like I just backed all the uh all the internal frames for the main module and what"
    },
    {
      "Time_Start": 867.5200000000001,
      "Time_End": 874.1200000000001,
      "Text": " I do is I select three frames well actually four to be a bit more stealthy in our"
    },
    {
      "Time_Start": 874.12,
      "Time_End": 879.12,
      "Text": " intentions but the needed are three and um these are a set set set for FPRAG frame, a push"
    },
    {
      "Time_Start": 881.46,
      "Time_End": 886.16,
      "Text": " reg frame, other sync frame and then yeah we added a concealed frame just to be a bit more"
    },
    {
      "Time_Start": 886.16,
      "Time_End": 892.58,
      "Text": " stealthy. And what they do is just at a certain point in the set FPRAG frame what we are"
    },
    {
      "Time_Start": 892.58,
      "Time_End": 898.5,
      "Text": " doing is that we are restoring the base pointer again and so this happens through this kind"
    },
    {
      "Time_Start": 898.5,
      "Time_End": 903.5,
      "Text": " of call which is mob RBP RSP where we save our current RSP which contains the uh address on"
    },
    {
      "Time_Start": 905.7,
      "Time_End": 911.3,
      "Text": " the stack that can save the return address of this frame and then with the second frame the"
    },
    {
      "Time_Start": 911.3,
      "Time_End": 918.24,
      "Text": " push FPRAG frame the push reg frame we push RBP on the stack. Now what happens this"
    },
    {
      "Time_Start": 918.24,
      "Time_End": 925.16,
      "Text": " creates an opportunity for us to modify the address that was pushed in memory because that"
    },
    {
      "Time_Start": 925.18,
      "Time_End": 931.42,
      "Text": " RBP now is on the stack. If you modify it this will be evaluated by the unwinding"
    },
    {
      "Time_Start": 931.42,
      "Time_End": 937.12,
      "Text": " algorithm as the address that should be used to restore RSP. And this gives us an"
    },
    {
      "Time_Start": 937.12,
      "Time_End": 944.24,
      "Text": " opportunity to tamper with this so that if this RSP points back to our thread initialization"
    },
    {
      "Time_Start": 944.24,
      "Time_End": 950.24,
      "Text": " frame practically what happens is that the main module will completely disappear from the"
    },
    {
      "Time_Start": 950.24,
      "Time_End": 954.96,
      "Text": " call stack. Okay this doesn't solve the memory problem so if you have you know unbacked"
    },
    {
      "Time_Start": 954.96,
      "Time_End": 960.36,
      "Text": " memory section this will not resolve that okay. But from the call stack it's not visible"
    },
    {
      "Time_Start": 960.36,
      "Time_End": 966.74,
      "Text": " anymore. Because doing just this will of course corrupt the execute the return flow of the"
    },
    {
      "Time_Start": 966.74,
      "Time_End": 973.54,
      "Text": " program we use the same gadget which is a job gadget here a jump RBX to hijack the return"
    },
    {
      "Time_Start": 973.56,
      "Time_End": 979.56,
      "Text": " flow so that we can execute a restore function which is under our control and this restore"
    },
    {
      "Time_Start": 981.16,
      "Time_End": 988.26,
      "Text": " function will reset the main module to what it was and just remove the fake frames. So this"
    },
    {
      "Time_Start": 988.26,
      "Time_End": 994.26,
      "Text": " is the technique in a nutshell. And this is how the call stack is set up and as you can see"
    },
    {
      "Time_Start": 994.26,
      "Time_End": 1000.26,
      "Text": " there are the thread initialization frames and then there is no executable there is just"
    },
    {
      "Time_Start": 1003.34,
      "Time_End": 1011.34,
      "Text": " kernel base and these frames are all generated by our algorithm. Now these frames have some"
    },
    {
      "Time_Start": 1011.34,
      "Time_End": 1019.34,
      "Text": " logical inconsistencies that can be used for detection and my colleague will. Sure so I'll talk"
    },
    {
      "Time_Start": 1019.76,
      "Time_End": 1024.74,
      "Text": " to you guys a little bit about the IOCs and why this doesn't necessarily create a perfect"
    },
    {
      "Time_Start": 1024.74,
      "Time_End": 1031.08,
      "Text": " stack but does create a good looking stack. So if we look at the slide we have currently you"
    },
    {
      "Time_Start": 1031.08,
      "Time_End": 1037.52,
      "Text": " can see the spoofed frame the kernel base dot DLL open state explicit and you actually see a"
    },
    {
      "Time_Start": 1037.52,
      "Time_End": 1042.82,
      "Text": " location that plus zero X three nine D that's an offset. So what's going to happen is that's"
    },
    {
      "Time_Start": 1042.82,
      "Time_End": 1048.76,
      "Text": " the return address we would return to in order to continue execution within the stack. Now"
    },
    {
      "Time_Start": 1048.78,
      "Time_End": 1055.42,
      "Text": " why is this relevant and why is this in IOC? Because technically if we well let's talk about"
    },
    {
      "Time_Start": 1055.42,
      "Time_End": 1060.52,
      "Text": " what a call stack is. Based on the name a call stack is of course a series of calls. So you"
    },
    {
      "Time_Start": 1060.52,
      "Time_End": 1066.14,
      "Text": " will see an API call making another API call making another API call and this is often so you"
    },
    {
      "Time_Start": 1066.14,
      "Time_End": 1070.54,
      "Text": " can debug and you can see at what API you may have crashed at what section you may have"
    },
    {
      "Time_Start": 1070.54,
      "Time_End": 1076.18,
      "Text": " issues etc. So it is supposed to show a series of calls to other functions. Now if we look at"
    },
    {
      "Time_Start": 1076.2,
      "Time_End": 1082.0,
      "Text": " that spoofed frame the kernel base dot DLL open state explicit we go to the return address but"
    },
    {
      "Time_Start": 1082.0,
      "Time_End": 1086.14,
      "Text": " the return address isn't going to have a call because the return address is going to be after"
    },
    {
      "Time_Start": 1086.14,
      "Time_End": 1091.24,
      "Text": " the call. That's where we continue execution or we return. So what we do is we actually go"
    },
    {
      "Time_Start": 1091.24,
      "Time_End": 1097.38,
      "Text": " before the return address and we try to look at that little move byte pointer that we see"
    },
    {
      "Time_Start": 1097.38,
      "Time_End": 1103.3,
      "Text": " there for the open state explicit function. We can see that that is not a call and not only"
    },
    {
      "Time_Start": 1103.32,
      "Time_End": 1108.12,
      "Text": " is that not a call to another function it is certainly not a call to create private object"
    },
    {
      "Time_Start": 1108.12,
      "Time_End": 1113.96,
      "Text": " security with multiple inheritance. So immediately this becomes suspicious. And this isn't"
    },
    {
      "Time_Start": 1113.96,
      "Time_End": 1118.5,
      "Text": " something a legitimate dev would ever do because it would just hinder their debugging process."
    },
    {
      "Time_Start": 1118.5,
      "Time_End": 1123.6,
      "Text": " It would impact them negatively. So this is something we would only see an attacker wanting to"
    },
    {
      "Time_Start": 1123.6,
      "Time_End": 1130.34,
      "Text": " perform. Now while I say this is an IOC it's really kind of a difficult IOC. You know it's"
    },
    {
      "Time_Start": 1130.36,
      "Time_End": 1135.72,
      "Text": " hard to deploy at scale. It's not really something you can hunt in your EDRs and if you"
    },
    {
      "Time_Start": 1135.72,
      "Time_End": 1142.6999999999998,
      "Text": " observe this on every single function there would be very massive performance hits. So while"
    },
    {
      "Time_Start": 1142.6999999999998,
      "Time_End": 1148.3,
      "Text": " this is an IOC we're not necessarily sure there's a realistic detection method yet. Outside"
    },
    {
      "Time_Start": 1148.3,
      "Time_End": 1153.1,
      "Text": " of the possibility of a utility such as Intel pin tracer which does it a little lower level"
    },
    {
      "Time_Start": 1153.1,
      "Time_End": 1159.82,
      "Text": " than the operating system itself. So if we look here we can tell you what we're looking for."
    },
    {
      "Time_Start": 1159.82,
      "Time_End": 1165.0,
      "Text": " These are the call opcodes. This is basically the assembly that we're looking for in our"
    },
    {
      "Time_Start": 1165.0,
      "Time_End": 1172.4399999999998,
      "Text": " eclipse detector to observe full moonwalk. So we're looking for specific types of calls. Um that"
    },
    {
      "Time_Start": 1172.4399999999998,
      "Time_End": 1177.9399999999998,
      "Text": " mod rex w basically determines if it's like a long call or a short call for example. And then"
    },
    {
      "Time_Start": 1177.9399999999998,
      "Time_End": 1184.6799999999998,
      "Text": " we can see a relative 32 call. The call R64 calls a register. And then of course the"
    },
    {
      "Time_Start": 1184.68,
      "Time_End": 1190.42,
      "Text": " system call, the NTDLL lowest level call that you will often see because NTDLL often makes"
    },
    {
      "Time_Start": 1190.42,
      "Time_End": 1195.42,
      "Text": " the sys call for you. But if we were to observe there we would see a sys call instruction. So"
    },
    {
      "Time_Start": 1197.66,
      "Time_End": 1203.66,
      "Text": " this is the algorithm for all you PhD people out there. Um basically the idea is we're looking"
    },
    {
      "Time_Start": 1203.66,
      "Time_End": 1208.4,
      "Text": " for very specific things in our algorithm. Not just for stack spoofing but the detector is"
    },
    {
      "Time_Start": 1208.4,
      "Time_End": 1214.0,
      "Text": " looking for an invalid stack period. And not just by unwinding because as we know we can"
    },
    {
      "Time_Start": 1214.02,
      "Time_End": 1219.96,
      "Text": " actually fool the unwinder as previously shown. So what do we look for? We're looking for"
    },
    {
      "Time_Start": 1219.96,
      "Time_End": 1224.54,
      "Text": " unbacked memory regions. That's the reflective injection detected. Unbacked memory means"
    },
    {
      "Time_Start": 1224.54,
      "Time_End": 1229.54,
      "Text": " some injection was performed. A private RX commit memory region was created. This isn't"
    },
    {
      "Time_Start": 1229.54,
      "Time_End": 1235.38,
      "Text": " backed to any files on disk. No DLLs, no EXCs. So we consider this malicious often. We"
    },
    {
      "Time_Start": 1235.38,
      "Time_End": 1240.78,
      "Text": " consider some injection of some sort. There can be false positives with this to be clear. Um"
    },
    {
      "Time_Start": 1240.8,
      "Time_End": 1245.54,
      "Text": " JITs, browsers, you know C sharp you'll you'll see these private commit memory regions"
    },
    {
      "Time_Start": 1245.54,
      "Time_End": 1251.24,
      "Text": " getting created and executing code. So while this does help it's not foolproof to be clear."
    },
    {
      "Time_Start": 1251.24,
      "Time_End": 1255.68,
      "Text": " The next is we actually look for the desync gadget. Because what full moon walk actually"
    },
    {
      "Time_Start": 1255.68,
      "Time_End": 1259.96,
      "Text": " does is it desyncs the stack with basically a ROP gadget in order to be able to"
    },
    {
      "Time_Start": 1259.96,
      "Time_End": 1265.26,
      "Text": " effectively craft its own stack for restoration as well. So we can just look for that gadget"
    },
    {
      "Time_Start": 1265.26,
      "Time_End": 1270.06,
      "Text": " and often that can be an IOC as well. Additionally the call mismatch detected as"
    },
    {
      "Time_Start": 1270.08,
      "Time_End": 1276.06,
      "Text": " previously stated. Um message box A is going to make a very specific call to the next"
    },
    {
      "Time_Start": 1276.06,
      "Time_End": 1281.56,
      "Text": " function. If we look at message box A, we look at the previous instruction and it's not the"
    },
    {
      "Time_Start": 1281.56,
      "Time_End": 1286.56,
      "Text": " right call to the next function, that's an IOC. And the wrong address detected as well. If"
    },
    {
      "Time_Start": 1289.2,
      "Time_End": 1294.6,
      "Text": " the address is just not a call, if it's not strict, if it's not correct, you know it has to"
    },
    {
      "Time_Start": 1294.6200000000001,
      "Time_End": 1299.8200000000002,
      "Text": " be a call and it has to be a call in a in the correct order. I I actually think I uh mixed up"
    },
    {
      "Time_Start": 1299.8200000000002,
      "Time_End": 1304.0000000000002,
      "Text": " the mismatch and the wrong address but the idea is the same. In one we're basically looking"
    },
    {
      "Time_Start": 1304.0000000000002,
      "Time_End": 1309.1000000000001,
      "Text": " for a call that's not a call or we're basically looking is it actually calling the next"
    },
    {
      "Time_Start": 1309.1000000000001,
      "Time_End": 1312.5000000000002,
      "Text": " function because that's what a call stack is supposed to do. This function calls that"
    },
    {
      "Time_Start": 1312.5000000000002,
      "Time_End": 1317.5000000000002,
      "Text": " function, calls that function for investigation. So this is full moonwalk running. We have a"
    },
    {
      "Time_Start": 1317.52,
      "Time_End": 1322.52,
      "Text": " successfully spoofed message box A. We've been telling you we're spoofing this message"
    },
    {
      "Time_Start": 1326.22,
      "Time_End": 1331.22,
      "Text": " box A. Now we run our detector. On the left you can see our spore our four spoofed frames"
    },
    {
      "Time_Start": 1334.66,
      "Time_End": 1339.66,
      "Text": " frames 8, 9, 10 and 11. Our detector first catches create file internal as a spoofed call"
    },
    {
      "Time_Start": 1340.46,
      "Time_End": 1345.46,
      "Text": " because the previous address does not, the previous instruction is not a call. And here's"
    },
    {
      "Time_Start": 1348.0600000000002,
      "Time_End": 1354.68,
      "Text": " what's interesting. We also get PSS query snapshot. Now if you look at the addresses, as I"
    },
    {
      "Time_Start": 1354.68,
      "Time_End": 1359.68,
      "Text": " said before, this does unwind. If you look at the PC address for PSS query snapshot, it"
    },
    {
      "Time_Start": 1362.42,
      "Time_End": 1367.76,
      "Text": " matches the return address for the create file function. So an unwinder is going to think"
    },
    {
      "Time_Start": 1367.76,
      "Time_End": 1371.76,
      "Text": " this is legitimate. This is in fact what was called, this is in fact where it needs to"
    },
    {
      "Time_Start": 1371.76,
      "Time_End": 1377.26,
      "Text": " return. But our detector knows better. Our detector goes there and says not only is there"
    },
    {
      "Time_Start": 1377.26,
      "Time_End": 1382.28,
      "Text": " no call, there's absolutely no call to create file W. All we've done is fooled the Microsoft"
    },
    {
      "Time_Start": 1384.94,
      "Time_End": 1390.74,
      "Text": " unwinder into thinking this looks legitimate. So if you actually use Microsoft's built in"
    },
    {
      "Time_Start": 1390.74,
      "Time_End": 1396.02,
      "Text": " unwinding, this is what we did here, it looks legitimate. We only caught this because our"
    },
    {
      "Time_Start": 1396.02,
      "Time_End": 1401.02,
      "Text": " detector is looking for more. Now there are a few false positives as mentioned before. Um we"
    },
    {
      "Time_Start": 1403.8799999999999,
      "Time_End": 1409.36,
      "Text": " see this a lot with JITs specifically. We saw this in WinDBG. It seemed to be uh uh have a"
    },
    {
      "Time_Start": 1409.36,
      "Time_End": 1413.9,
      "Text": " lot of JITing going on. We can see right here one of the processes for WinDBG has just"
    },
    {
      "Time_Start": 1413.9,
      "Time_End": 1419.54,
      "Text": " these two entirely unbacked memory regions. Um for reasons unknown to us, it appears JITs"
    },
    {
      "Time_Start": 1419.54,
      "Time_End": 1424.1399999999999,
      "Text": " don't always fully unwind and that these memory regions just always exist. And so there"
    },
    {
      "Time_Start": 1424.16,
      "Time_End": 1429.16,
      "Text": " will be false positives with JIT processes as usual. So we did testing to see what the false"
    },
    {
      "Time_Start": 1432.4,
      "Time_End": 1437.5800000000002,
      "Text": " positive rate actually was. We wanted to determine is this feasible? Is this something we can"
    },
    {
      "Time_Start": 1437.5800000000002,
      "Time_End": 1443.5800000000002,
      "Text": " actually do without you know overloading a team? And we determined kind of you know it's"
    },
    {
      "Time_Start": 1443.5800000000002,
      "Time_End": 1449.6200000000001,
      "Text": " it's not too bad. So we'll see we we tested this on five different machines. Uh standard just"
    },
    {
      "Time_Start": 1449.64,
      "Time_End": 1455.0400000000002,
      "Text": " means it was a standard Windows user machine. This is not a developer. This is just a person"
    },
    {
      "Time_Start": 1455.0400000000002,
      "Time_End": 1461.0800000000002,
      "Text": " who logs on, watches video, does work on Word documents and that's it. Uh dev is actually a"
    },
    {
      "Time_Start": 1461.0800000000002,
      "Time_End": 1466.72,
      "Text": " developer. Somebody who installs Visual Studio, sets up Postman, installs WinDBG preview."
    },
    {
      "Time_Start": 1466.72,
      "Time_End": 1470.7600000000002,
      "Text": " And again you know it makes sense. The developer is going to have a higher false positive"
    },
    {
      "Time_Start": 1470.7600000000002,
      "Time_End": 1474.66,
      "Text": " rate, they have more JITs, they're developing more tools that are going to have weird"
    },
    {
      "Time_Start": 1474.66,
      "Time_End": 1478.74,
      "Text": " unbacked memory regions. You know no programming isn't really perfect and there's really no"
    },
    {
      "Time_Start": 1478.76,
      "Time_End": 1483.76,
      "Text": " catch all for this. We can see on Win10 the false positive rate is actually a little lower"
    },
    {
      "Time_Start": 1486.16,
      "Time_End": 1491.36,
      "Text": " than Win11 Enterprise. Um but you know we do see that for the dev machines it actually"
    },
    {
      "Time_Start": 1491.36,
      "Time_End": 1496.1,
      "Text": " decreased a bit. As far as Windows Server goes we see a pretty high false positive rate."
    },
    {
      "Time_Start": 1496.1,
      "Time_End": 1499.44,
      "Text": " That's likely associated with you know you're deploying your web servers on this, you're"
    },
    {
      "Time_Start": 1499.44,
      "Time_End": 1502.84,
      "Text": " deploying your dot net applications, you're you're deploying all sorts of stuff that's going"
    },
    {
      "Time_Start": 1502.84,
      "Time_End": 1508.32,
      "Text": " to sort of increase that rate of false positives. And and you know just to end this as far"
    },
    {
      "Time_Start": 1508.32,
      "Time_End": 1513.76,
      "Text": " as detecting all this goes it's like I said for a hunter behind an EDR this isn't really"
    },
    {
      "Time_Start": 1513.76,
      "Time_End": 1518.78,
      "Text": " telemetry we get. Um some EDR provide call stacks for very specific functions so as to not"
    },
    {
      "Time_Start": 1521.24,
      "Time_End": 1525.62,
      "Text": " be too intensive. And we can sort of hunt on that and look for unbacked memory regions. But"
    },
    {
      "Time_Start": 1525.62,
      "Time_End": 1530.3799999999999,
      "Text": " as far as it goes for full moonwalk we just don't really have an effective way to check"
    },
    {
      "Time_Start": 1530.3799999999999,
      "Time_End": 1535.48,
      "Text": " every single function call and ensure that this call is actually a valid call. So in a way"
    },
    {
      "Time_Start": 1535.48,
      "Time_End": 1540.5,
      "Text": " this unwind ability is pretty effective in today's age. So after after developing the"
    },
    {
      "Time_Start": 1545.16,
      "Time_End": 1550.64,
      "Text": " detection we actually talked about uh other kind of avenues that we could where we could"
    },
    {
      "Time_Start": 1550.64,
      "Time_End": 1555.64,
      "Text": " actually make use of um this uh kind of knowledge. And so as we've seen um except for the"
    },
    {
      "Time_Start": 1558.04,
      "Time_End": 1562.92,
      "Text": " execute like in memory execution there was another problem which was the correct stack"
    },
    {
      "Time_Start": 1562.92,
      "Time_End": 1569.0600000000002,
      "Text": " frames allocated when we execute an I level API instead of going with the indirect Cisco. So"
    },
    {
      "Time_Start": 1569.0600000000002,
      "Time_End": 1573.16,
      "Text": " we developed this additional technique which is an extension and it's half moonwalk. Half"
    },
    {
      "Time_Start": 1573.16,
      "Time_End": 1577.54,
      "Text": " moonwalk is because we're just doing half of the technique. We are just considering what"
    },
    {
      "Time_Start": 1577.54,
      "Time_End": 1583.04,
      "Text": " is half like what is what we are calling and not really the caller. And so what half moonwalk"
    },
    {
      "Time_Start": 1583.04,
      "Time_End": 1588.04,
      "Text": " does is that we can always go to like we can always match an I level API to a Cisco. Uh"
    },
    {
      "Time_Start": 1593.28,
      "Time_End": 1598.28,
      "Text": " so half moonwalk takes as input um an I level API name and it's relevant um Cisco"
    },
    {
      "Time_Start": 1601.1000000000001,
      "Time_End": 1606.1000000000001,
      "Text": " instruction. Uh and it will trace uh all like it will trace the execution flow from the I level"
    },
    {
      "Time_Start": 1611.5,
      "Time_End": 1616.5,
      "Text": " API until it finds the relevant uh anti function. And what we're doing is that doing this"
    },
    {
      "Time_Start": 1617.2,
      "Time_End": 1624.2,
      "Text": " tracing we also collect all the information all the exception information so all the"
    },
    {
      "Time_Start": 1624.2,
      "Time_End": 1629.14,
      "Text": " information in the P data section related to the prologue. And what we do is that we"
    },
    {
      "Time_Start": 1629.14,
      "Time_End": 1634.14,
      "Text": " recreate the frames of the I level APIs before executing an indirect Cisco. So how we do"
    },
    {
      "Time_Start": 1637.78,
      "Time_End": 1644.38,
      "Text": " that we just need to literally emulate the prologue of the API level API. And what happens"
    },
    {
      "Time_Start": 1644.4,
      "Time_End": 1649.4,
      "Text": " doing this is that we can recreate the same kind of uh call stack. Perfectly perfectly"
    },
    {
      "Time_Start": 1652.94,
      "Time_End": 1659.6200000000001,
      "Text": " legit this time. So we also respect the um the location of the return address which is"
    },
    {
      "Time_Start": 1659.6200000000001,
      "Time_End": 1665.42,
      "Text": " placed after the call. And the call is actually matching what is being called. But we never"
    },
    {
      "Time_Start": 1665.42,
      "Time_End": 1671.3000000000002,
      "Text": " call the I level API. So this is literally a sys whisper type of indirect system call just"
    },
    {
      "Time_Start": 1671.32,
      "Time_End": 1676.98,
      "Text": " with uh the spoofed frame for the I level API. So now we have a little problem that we will"
    },
    {
      "Time_Start": 1676.98,
      "Time_End": 1681.52,
      "Text": " solve afterward for the emulate system call which of course is a function that will do"
    },
    {
      "Time_Start": 1681.52,
      "Time_End": 1688.6399999999999,
      "Text": " this spoofing and it's visible as for now. So we will solve this later. But um so we are"
    },
    {
      "Time_Start": 1688.6399999999999,
      "Time_End": 1694.1399999999999,
      "Text": " concerned about the return flow though. If we have these frames they will return back to"
    },
    {
      "Time_Start": 1694.1399999999999,
      "Time_End": 1699.9199999999998,
      "Text": " where they are supposed to return. But we didn't actually execute the I level API we just"
    },
    {
      "Time_Start": 1699.92,
      "Time_End": 1706.1000000000001,
      "Text": " emulated the prologue. Would that be enough to actually ensure that the return flow is"
    },
    {
      "Time_Start": 1706.1000000000001,
      "Time_End": 1711.1000000000001,
      "Text": " correct? Well yes and no. Uh so there are 3 strategies we can use. Uh 1 is the return uh"
    },
    {
      "Time_Start": 1713.76,
      "Time_End": 1718.5600000000002,
      "Text": " place the return on a winding. So this is terribly worded. Uh what I mean is that we place"
    },
    {
      "Time_Start": 1718.5600000000002,
      "Time_End": 1723.5600000000002,
      "Text": " the return address of the epilogue. Uh which of course is just deallocating the prologue. It's"
    },
    {
      "Time_Start": 1723.78,
      "Time_End": 1728.78,
      "Text": " just like literally rolling back the prologue so that will work. But we will be detected by"
    },
    {
      "Time_Start": 1731.52,
      "Time_End": 1737.78,
      "Text": " eclipse again then because uh we need to move the return address not after the call but on the"
    },
    {
      "Time_Start": 1737.78,
      "Time_End": 1744.82,
      "Text": " epilogue itself. Uh the other and this is what it happens. Instead we have to call to uh anti"
    },
    {
      "Time_Start": 1744.82,
      "Time_End": 1749.1599999999999,
      "Text": " protected to memory in this case. Instead of placing the return here where it's supposed to"
    },
    {
      "Time_Start": 1749.16,
      "Time_End": 1754.16,
      "Text": " do because there are all these tests we just move it to the epilogue. And this works of"
    },
    {
      "Time_Start": 1757.0800000000002,
      "Time_End": 1762.76,
      "Text": " course but as I said we are we can be detected again by by eclipse with this because if we"
    },
    {
      "Time_Start": 1762.76,
      "Time_End": 1768.26,
      "Text": " analyze the instruction before this return address it won't be a call anymore. So we have a"
    },
    {
      "Time_Start": 1768.26,
      "Time_End": 1773.72,
      "Text": " second strategy which is the targeted setup that works even better but it doesn't scale. And"
    },
    {
      "Time_Start": 1773.72,
      "Time_End": 1779.72,
      "Text": " the targeted setup is just like I can analyze what are the post uh call checks. What I call"
    },
    {
      "Time_Start": 1779.72,
      "Time_End": 1785.6000000000001,
      "Text": " post call checks are literally all these checks all these if that are executed after the"
    },
    {
      "Time_Start": 1785.6000000000001,
      "Time_End": 1790.6000000000001,
      "Text": " call. Uh and to avoid them from you know branching. To avoid the branching I just say what I"
    },
    {
      "Time_Start": 1795.02,
      "Time_End": 1798.82,
      "Text": " need to patch. I just see what I need to patch and then I patch it before actually"
    },
    {
      "Time_Start": 1798.82,
      "Time_End": 1805.12,
      "Text": " executing the call. Now this is this is pretty much it works but you can't do it anytime and"
    },
    {
      "Time_Start": 1805.12,
      "Time_End": 1810.28,
      "Text": " honestly it doesn't scale at all because you would need to know what thing to patch every"
    },
    {
      "Time_Start": 1810.28,
      "Time_End": 1815.62,
      "Text": " time you execute an arbitrary function. This doesn't scale at all. So the last thing we can"
    },
    {
      "Time_Start": 1815.62,
      "Time_End": 1821.62,
      "Text": " do is I don't know what is happening I'm sorry. Another thing I can do is using our break"
    },
    {
      "Time_Start": 1822.5400000000002,
      "Time_End": 1828.5400000000002,
      "Text": " points. Um so what it happens is that I I place a break point on return and we actually say"
    },
    {
      "Time_Start": 1832.0000000000002,
      "Time_End": 1837.42,
      "Text": " sliding our break points because we don't know how many frames we need to emulate. So if"
    },
    {
      "Time_Start": 1837.42,
      "Time_End": 1843.0400000000002,
      "Text": " they are more than four of course I need a strategy to out update the other break points"
    },
    {
      "Time_Start": 1843.0400000000002,
      "Time_End": 1847.88,
      "Text": " otherwise I will I will miss some frame. Uh anyway what it happens is that I place a I place"
    },
    {
      "Time_Start": 1847.88,
      "Time_End": 1853.18,
      "Text": " another break point at the return address when the function returns back I just execute"
    },
    {
      "Time_Start": 1853.18,
      "Time_End": 1859.88,
      "Text": " an exception handler that just execute the epilogue emulate the epilogue and then force the"
    },
    {
      "Time_Start": 1859.88,
      "Time_End": 1867.38,
      "Text": " instruction pointers to return. And that this way this this this scales well but I need always"
    },
    {
      "Time_Start": 1867.38,
      "Time_End": 1873.5600000000002,
      "Text": " executable I I always need executable memory because I always need to make the um the"
    },
    {
      "Time_Start": 1873.5600000000002,
      "Time_End": 1877.1000000000001,
      "Text": " exception handler like somewhere. I need to store the exception handler somewhere so I"
    },
    {
      "Time_Start": 1877.14,
      "Time_End": 1882.14,
      "Text": " always need some executable memory around floating around. So um as I said before um the we"
    },
    {
      "Time_Start": 1885.8600000000001,
      "Time_End": 1891.14,
      "Text": " also had a sort of a problem with the emulate system call because we said well there is no"
    },
    {
      "Time_Start": 1891.14,
      "Time_End": 1896.14,
      "Text": " function if you remember before there is no like this thing is actually pushing this frame"
    },
    {
      "Time_Start": 1898.9,
      "Time_End": 1904.1000000000001,
      "Text": " and then jumping to the sys call instruction here so if someone is looking at this emulate"
    },
    {
      "Time_Start": 1904.1000000000001,
      "Time_End": 1910.68,
      "Text": " system call it can be problematic. So what we can create is an opaque architecture that"
    },
    {
      "Time_Start": 1910.68,
      "Time_End": 1915.68,
      "Text": " as this is a if but you can place a switch case for example um that just will when ex when"
    },
    {
      "Time_Start": 1918.64,
      "Time_End": 1924.1000000000001,
      "Text": " this is executed it will execute so now we are stepping through here okay to emulate system"
    },
    {
      "Time_Start": 1924.1000000000001,
      "Time_End": 1930.0200000000002,
      "Text": " call W this is a frameless function it will execute something on the stack it will corrupt"
    },
    {
      "Time_Start": 1930.02,
      "Time_End": 1936.1,
      "Text": " the stack doing this but it will grab the position of this frame function and it will just"
    },
    {
      "Time_Start": 1936.1,
      "Time_End": 1941.98,
      "Text": " swap itself swap the frame of the frame of function with the frame function this way it will"
    },
    {
      "Time_Start": 1941.98,
      "Time_End": 1947.9,
      "Text": " restore the stack the call stack that will appear legitimate and here we have what"
    },
    {
      "Time_Start": 1947.9,
      "Time_End": 1954.68,
      "Text": " legitimates this like sequence of call is that we have a jump here to the restore uh proc. Of"
    },
    {
      "Time_Start": 1954.68,
      "Time_End": 1959.26,
      "Text": " course this is opaque it's not that great but what we want what is really important about"
    },
    {
      "Time_Start": 1959.26,
      "Time_End": 1965.26,
      "Text": " this is that even if we have something with no frame information associated as long as the"
    },
    {
      "Time_Start": 1968.26,
      "Time_End": 1975.0,
      "Text": " stack size so the modification on the stack are equal to something that we are creating and"
    },
    {
      "Time_Start": 1975.0,
      "Time_End": 1981.0,
      "Text": " it's framed we can always replace it and fix the call stack. Why this is important? Because"
    },
    {
      "Time_Start": 1981.0,
      "Time_End": 1986.0,
      "Text": " there are ways we can do that using standard Windows DLLs. So we selected this in particular"
    },
    {
      "Time_Start": 1989.8,
      "Time_End": 1995.8,
      "Text": " because it's very um it was already abused in exploit development to bypass uh uh exploit"
    },
    {
      "Time_Start": 1997.3,
      "Time_End": 2002.3,
      "Text": " mitigation um uh it's part of the exploit mitigation developed by Windows and it's the call it's"
    },
    {
      "Time_Start": 2005.26,
      "Time_End": 2011.26,
      "Text": " the call to NDR server call to. So we can use this kind of architecture here to completely hide"
    },
    {
      "Time_Start": 2013.04,
      "Time_End": 2018.8799999999999,
      "Text": " our caller again. So how this may work so if we can enforce in our implant maybe a stage"
    },
    {
      "Time_Start": 2018.9,
      "Time_End": 2024.9,
      "Text": " zero. If we can enforce in our implant this constraint uh so we want the our implant at any"
    },
    {
      "Time_Start": 2028.74,
      "Time_End": 2035.22,
      "Text": " time the internal the sides of the frames of the internal frames of our implant they should"
    },
    {
      "Time_Start": 2035.22,
      "Time_End": 2041.22,
      "Text": " always match the sides of the NDR stub call to stack. As you can see here you have a lot of"
    },
    {
      "Time_Start": 2042.22,
      "Time_End": 2049.06,
      "Text": " space allocated on the spy on the stack for this function. If we can enforce this uh this"
    },
    {
      "Time_Start": 2049.06,
      "Time_End": 2055.06,
      "Text": " constraint uh we can start a thread pointing to our shell code in memory which is our implant."
    },
    {
      "Time_Start": 2057.02,
      "Time_End": 2063.02,
      "Text": " We can force these first two frames in the thread itself then we can start our implant and when"
    },
    {
      "Time_Start": 2063.24,
      "Time_End": 2069.24,
      "Text": " the implant needs to spoof a function what we can do is call the call at moon execute at moon"
    },
    {
      "Time_Start": 2073.66,
      "Time_End": 2079.66,
      "Text": " whereby the first frame spoofed is the invoke function which is an arbitrary call to anything"
    },
    {
      "Time_Start": 2083.0,
      "Time_End": 2088.82,
      "Text": " and then execute at moon with the rest of the AI level API frame and eventually call the spoof"
    },
    {
      "Time_Start": 2088.84,
      "Time_End": 2094.84,
      "Text": " function. So what this creates is a completely legitimate call stack where we have the frame in"
    },
    {
      "Time_Start": 2097.1000000000004,
      "Time_End": 2103.1000000000004,
      "Text": " the thread frame the thread initialization frames then we have the first two call to NDR stub"
    },
    {
      "Time_Start": 2103.1000000000004,
      "Time_End": 2109.94,
      "Text": " call uh NDR server call two and NDR stub call two then we have the execution of our implant we"
    },
    {
      "Time_Start": 2109.94,
      "Time_End": 2114.94,
      "Text": " have the return address spoofed with NDR stub call to stack which completely hides our implant"
    },
    {
      "Time_Start": 2115.28,
      "Time_End": 2121.28,
      "Text": " frames and then we have our phone executed with invoke and all the AI level all the remaining"
    },
    {
      "Time_Start": 2125.0,
      "Time_End": 2130.82,
      "Text": " uh AI level API frames. And then we have the system call again executed. This will hide"
    },
    {
      "Time_Start": 2130.82,
      "Time_End": 2137.28,
      "Text": " completely the um the caller as well so we are just we're just going back and try to you know"
    },
    {
      "Time_Start": 2137.28,
      "Time_End": 2144.66,
      "Text": " complete what our phone was not doing. So hiding the caller. Now the only drawback of this is"
    },
    {
      "Time_Start": 2144.68,
      "Time_End": 2150.3199999999997,
      "Text": " that you always in order to restore the functionality of the program on return you always"
    },
    {
      "Time_Start": 2150.3199999999997,
      "Time_End": 2156.3199999999997,
      "Text": " need uh another breakpoint placed on invoke. So you can handle these two frames as much as as"
    },
    {
      "Time_Start": 2157.8599999999997,
      "Time_End": 2163.8599999999997,
      "Text": " you want as we've shown before. So target that set up uh or um or uh return on epilogue or um or"
    },
    {
      "Time_Start": 2166.94,
      "Time_End": 2171.8999999999996,
      "Text": " exception or exception enders. But this invoke function you always need an exception"
    },
    {
      "Time_Start": 2171.92,
      "Time_End": 2176.92,
      "Text": " ender to actually restore the return address of the NDR stub call to stack and return to our"
    },
    {
      "Time_Start": 2179.3,
      "Time_End": 2184.3,
      "Text": " implant. Just a word about chat. Um we are starting a lot uh inter chat with shadow stack"
    },
    {
      "Time_Start": 2188.0,
      "Time_End": 2194.7400000000002,
      "Text": " mitigation and indirect branching tracing, indirect branch tracing and so far we didn't find"
    },
    {
      "Time_Start": 2194.7400000000002,
      "Time_End": 2199.94,
      "Text": " a way around chat. Uh it's not surprising. So what happens with chat is that there is a"
    },
    {
      "Time_Start": 2199.96,
      "Time_End": 2205.06,
      "Text": " shadow stack of course it clone like it maintains a list of all the return address uh that are"
    },
    {
      "Time_Start": 2205.06,
      "Time_End": 2211.84,
      "Text": " placed just after a call and when on return it will check if this return address is matches the"
    },
    {
      "Time_Start": 2211.84,
      "Time_End": 2218.94,
      "Text": " user mode um like the user mode the uh writable normal call stack and if they don't match"
    },
    {
      "Time_Start": 2218.94,
      "Time_End": 2225.78,
      "Text": " there will be a CP fault uh that will crash the program that will exit the program. Um there"
    },
    {
      "Time_Start": 2225.8,
      "Time_End": 2230.26,
      "Text": " is another another thing that is concerning about inter chat is that uh with indirect"
    },
    {
      "Time_Start": 2230.26,
      "Time_End": 2236.1400000000003,
      "Text": " branch tracing there is no easy way to modify the instruction pointer as well. We can't just"
    },
    {
      "Time_Start": 2236.1400000000003,
      "Time_End": 2241.1400000000003,
      "Text": " use exception ender as as much as we do now. Uh but the good thing is that even in uh machine"
    },
    {
      "Time_Start": 2244.2400000000002,
      "Time_End": 2249.82,
      "Text": " supporting chat so far uh there will there are always uh processes that are not chat enabled"
    },
    {
      "Time_Start": 2249.82,
      "Time_End": 2254.82,
      "Text": " like browsers and stuff like that that we can still abuse for executing this technique."
    },
    {
      "Time_Start": 2256.1200000000003,
      "Time_End": 2261.8,
      "Text": " So key takeaways you will you always have the public block available here uh this will be"
    },
    {
      "Time_Start": 2261.8,
      "Time_End": 2266.8,
      "Text": " enhanced with additional uh box after this talk so in the coming days. Um this block of"
    },
    {
      "Time_Start": 2269.26,
      "Time_End": 2274.44,
      "Text": " course is uh like both of the techniques are usually like uh have been developed and"
    },
    {
      "Time_Start": 2274.44,
      "Time_End": 2279.6400000000003,
      "Text": " designed to obfuscate the stack at run time so if you're planning to obfuscate the stack"
    },
    {
      "Time_Start": 2279.6400000000003,
      "Time_End": 2284.5800000000004,
      "Text": " when you're going on sleep probably I'd rather use the stack cloning or the stack hiding"
    },
    {
      "Time_Start": 2284.58,
      "Time_End": 2290.52,
      "Text": " reason is well as you see there are certain logical inconsistencies in the stack so if you"
    },
    {
      "Time_Start": 2290.52,
      "Time_End": 2295.12,
      "Text": " leave it there for a long period of time you're increasing the chance of being detected by"
    },
    {
      "Time_Start": 2295.12,
      "Time_End": 2301.5,
      "Text": " eclipse etcetera or the denuncer is just just go there and see it and do a bit more um"
    },
    {
      "Time_Start": 2301.5,
      "Time_End": 2306.5,
      "Text": " analysis manual analysis on on the thread call stack. Um of course another another another"
    },
    {
      "Time_Start": 2309.0,
      "Time_End": 2313.3199999999997,
      "Text": " point is that this technique uh can be used wherever you use return address proofing as"
    },
    {
      "Time_Start": 2313.32,
      "Time_End": 2319.26,
      "Text": " an arrangement you can use sleep encryption I released a book uh not not long ago about"
    },
    {
      "Time_Start": 2319.26,
      "Time_End": 2325.96,
      "Text": " how to you can integrate uh sleep encryption technique to to to this to this um to this"
    },
    {
      "Time_Start": 2325.96,
      "Time_End": 2330.96,
      "Text": " technique to this stack proofing technique uh but it does a layer of complexity which is"
    },
    {
      "Time_Start": 2333.44,
      "Time_End": 2339.54,
      "Text": " not uh always easy to manage so a word of caution if you are trying to integrate this in your"
    },
    {
      "Time_Start": 2339.6,
      "Time_End": 2344.6,
      "Text": " own implant. And yeah I think pretty much it's it's everything um thanks a lot for joining"
    },
    {
      "Time_Start": 2347.94,
      "Time_End": 2352.94,
      "Text": " us and if you have any questions. Thank you. If you want we are at the start one sorry. So uh if"
    },
    {
      "Time_Start": 2364.72,
      "Time_End": 2368.06,
      "Text": " there's time we're happy to take questions but I think he's also saying if you want to meet up"
    },
    {
      "Time_Start": 2368.08,
      "Time_End": 2371.62,
      "Text": " with us after the talk we'll be happy to talk to anyone who wants to ask any questions."
    },
    {
      "Time_Start": 2371.62,
      "Time_End": 2376.62,
      "Text": " Excellent. Yeah. Thanks man. Thanks guys. Thanks a lot."
    }
  ]
}