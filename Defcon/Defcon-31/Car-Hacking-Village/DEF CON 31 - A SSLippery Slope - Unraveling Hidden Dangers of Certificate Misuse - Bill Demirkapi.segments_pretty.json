{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 10.6,
      "Text": "This text was transcribed using whisper model: large-v2\n\n All right, everyone. Thanks for coming out. I really appreciate everyone being here. Let's"
    },
    {
      "Time_Start": 10.6,
      "Time_End": 20.76,
      "Text": " get started. Hey, everyone. Thanks for coming out. Although this is not my first Black Hat"
    },
    {
      "Time_Start": 20.76,
      "Time_End": 26.12,
      "Text": " talk, it is the first time I'm speaking in person. I'm really, really, really excited"
    },
    {
      "Time_Start": 26.12,
      "Time_End": 48.2,
      "Text": " to be here. Let's get started. Hold on. All right. Just kidding. Of course. I'm really"
    },
    {
      "Time_Start": 48.2,
      "Time_End": 54.120000000000005,
      "Text": " honored to be here. It's my third time at DEF CON. Unfortunately, I was under the age"
    },
    {
      "Time_Start": 54.120000000000005,
      "Time_End": 61.28,
      "Text": " of 21, so I wasn't able to partake in the shot celebration for speakers, but I was this"
    },
    {
      "Time_Start": 61.28,
      "Time_End": 69.12,
      "Text": " year. So, a bit of background. My name is Bill Demerkapa, and I'm a researcher for the"
    },
    {
      "Time_Start": 69.12,
      "Time_End": 74.92,
      "Text": " Microsoft Security Response Center. While working full-time, I'm also a full-time student"
    },
    {
      "Time_Start": 74.92,
      "Time_End": 79.48,
      "Text": " at the Rochester Institute of Technology. I have a relatively diverse background in"
    },
    {
      "Time_Start": 79.48,
      "Time_End": 84.32000000000001,
      "Text": " offensive and defensive security, but my specialization is low-level operating system"
    },
    {
      "Time_Start": 84.32000000000001,
      "Time_End": 94.04,
      "Text": " internals with a focus on Windows. In this talk, we'll be exploring my work into digital"
    },
    {
      "Time_Start": 94.04,
      "Time_End": 99.60000000000001,
      "Text": " signatures, specifically the implementation issues I found with them. We'll start with some"
    },
    {
      "Time_Start": 99.60000000000001,
      "Time_End": 105.68,
      "Text": " background on how digital signatures are validated, approaches for attacking them, which"
    },
    {
      "Time_Start": 105.68,
      "Time_End": 111.64,
      "Text": " will tie into the systemic flaw I found and its impact on the broader ecosystem. A quick"
    },
    {
      "Time_Start": 111.64,
      "Time_End": 117.48,
      "Text": " disclaimer. We'll be discussing several first and third party vulnerabilities in this talk."
    },
    {
      "Time_Start": 117.48,
      "Time_End": 125.56,
      "Text": " Everything you see here today is patched. We will not be dropping zero days, unfortunately."
    },
    {
      "Time_Start": 125.56,
      "Time_End": 134.08,
      "Text": " All right. So, how are digital signatures validated in the real world? A digital signature is"
    },
    {
      "Time_Start": 134.12,
      "Time_End": 140.8,
      "Text": " used to verify that a message, document, or software comes from a specific sender and hasn't"
    },
    {
      "Time_Start": 140.8,
      "Time_End": 146.44,
      "Text": " been altered during transmission. This is done by creating a hash of the message and then"
    },
    {
      "Time_Start": 146.44,
      "Time_End": 152.68,
      "Text": " encrypting that hash with the sender's private key. A digital certificate, on the other hand,"
    },
    {
      "Time_Start": 152.68,
      "Time_End": 159.76000000000002,
      "Text": " is a digital document issued by a trusted third party, known as a certificate authority or CA."
    },
    {
      "Time_Start": 159.76,
      "Time_End": 165.39999999999998,
      "Text": " It contains the public key corresponding to the sender's private key, as well as information"
    },
    {
      "Time_Start": 165.39999999999998,
      "Time_End": 172.12,
      "Text": " about the identity of the sender. In order to validate a digital signature, the recipient"
    },
    {
      "Time_Start": 172.12,
      "Time_End": 177.64,
      "Text": " needs to have the sender's public key. The problem is, if the sender simply sent their public"
    },
    {
      "Time_Start": 177.64,
      "Time_End": 184.39999999999998,
      "Text": " key along with their message, there's no way for the recipient to know for sure that the public"
    },
    {
      "Time_Start": 184.4,
      "Time_End": 190.84,
      "Text": " key really belongs to the sender. By containing the sender's public key and being digitally"
    },
    {
      "Time_Start": 190.84,
      "Time_End": 197.32,
      "Text": " signed by a trusted third party CA, a digital certificate confirms that the public key really"
    },
    {
      "Time_Start": 197.32,
      "Time_End": 205.32,
      "Text": " does belong to that sender. Root certificate authorities are responsible for identity"
    },
    {
      "Time_Start": 207.04000000000002,
      "Time_End": 214.12,
      "Text": " verification of individuals and organizations requesting a certificate. For digital"
    },
    {
      "Time_Start": 214.12,
      "Time_End": 219.96,
      "Text": " signatures to work in practice, we need these organizations that we can rely on in order to"
    },
    {
      "Time_Start": 219.96,
      "Time_End": 227.68,
      "Text": " establish a chain of trust for digital certificates. Who verifies the root CAs? They come"
    },
    {
      "Time_Start": 227.68,
      "Time_End": 234.08,
      "Text": " pre-installed. They're responsible for identity verification, but, for example, in the"
    },
    {
      "Time_Start": 234.08,
      "Time_End": 239.52,
      "Text": " screenshot below, you can see the Windows Trusted Root Store. These are the authorities that"
    },
    {
      "Time_Start": 239.52,
      "Time_End": 243.56,
      "Text": " come with the operating system and provide a reference point for digital signature"
    },
    {
      "Time_Start": 243.56,
      "Time_End": 250.56,
      "Text": " validation. So, how is a digital certificate verified? Through the chain of trust. Remember"
    },
    {
      "Time_Start": 257.04,
      "Time_End": 263.12,
      "Text": " the trusted root CAs that come with your machine? We can verify if a digital certificate is"
    },
    {
      "Time_Start": 263.12,
      "Time_End": 269.92,
      "Text": " legitimate by checking if it chains up to one of these trusted CAs. In practice, the root"
    },
    {
      "Time_Start": 269.92,
      "Time_End": 277.44,
      "Text": " CAs verify the intermediate CAs, which then verify your end entity or server certificate and"
    },
    {
      "Time_Start": 277.44,
      "Time_End": 282.44,
      "Text": " allow us to determine the legitimacy of a signed digital message. So, let's go through a"
    },
    {
      "Time_Start": 282.44,
      "Time_End": 288.44,
      "Text": " simplified example of what verifying an executable looks like on Windows under the"
    },
    {
      "Time_Start": 294.62,
      "Time_End": 300.62,
      "Text": " Authenticode specification. First, we need to generate an Authenticode hash or digest. We"
    },
    {
      "Time_Start": 303.0,
      "Time_End": 309.6,
      "Text": " start by hashing the PE headers of the executable. Note that some fields, like the security"
    },
    {
      "Time_Start": 309.6,
      "Time_End": 315.6,
      "Text": " directory entry and checksum, are intentionally excluded. Next, we sort every PE section by"
    },
    {
      "Time_Start": 317.5,
      "Time_End": 324.44,
      "Text": " their file offset in ascending order and hash their contents. If there's any extra data after"
    },
    {
      "Time_Start": 324.44,
      "Time_End": 329.44,
      "Text": " the PE sections and before the security directory, this is added to the hash as well. Once we"
    },
    {
      "Time_Start": 331.98,
      "Time_End": 338.02000000000004,
      "Text": " calculate the hash, we can extract the encrypted digest from the security directory, which"
    },
    {
      "Time_Start": 338.03999999999996,
      "Time_End": 343.94,
      "Text": " contains the Authenticode signature. We decrypt and compare this hash with the one we"
    },
    {
      "Time_Start": 343.94,
      "Time_End": 350.15999999999997,
      "Text": " calculated and at this point, we have validated that the Authenticode signature is valid and"
    },
    {
      "Time_Start": 350.15999999999997,
      "Time_End": 355.79999999999995,
      "Text": " the last thing we need to do is verify the certificate and the chain of trust. Does the"
    },
    {
      "Time_Start": 355.79999999999995,
      "Time_End": 361.84,
      "Text": " certificate link to a certificate authority we know about? And that's about it, at least from a"
    },
    {
      "Time_Start": 361.86,
      "Time_End": 367.86,
      "Text": " high level. Let's talk a little bit about how one can go about attacking digital signatures. So"
    },
    {
      "Time_Start": 372.78000000000003,
      "Time_End": 378.78000000000003,
      "Text": " a quick history recap. Since 1996, MD5, the use of the MD5 algorithm has been discouraged due"
    },
    {
      "Time_Start": 381.04,
      "Time_End": 387.72,
      "Text": " to its inherent weaknesses. For example, in 2004, we saw the first publication of an MD5"
    },
    {
      "Time_Start": 387.74,
      "Time_End": 394.68,
      "Text": " collision. Researchers were able to generate two distinct files that resulted in the same MD5"
    },
    {
      "Time_Start": 394.68,
      "Time_End": 400.68,
      "Text": " hash. In 2008, the researchers abused known MD5 weaknesses to generate a malicious"
    },
    {
      "Time_Start": 402.52000000000004,
      "Time_End": 409.62,
      "Text": " certificate authority with a valid chain of trust. And using a chosen prefix collision, they"
    },
    {
      "Time_Start": 409.62,
      "Time_End": 416.44000000000005,
      "Text": " were able to create a rogue intermediate CA with the same MD5 hash as an end entity"
    },
    {
      "Time_Start": 416.46,
      "Time_End": 422.46,
      "Text": " certificate. In other words, something like an SSL certificate. In 2011, we saw a breach of the"
    },
    {
      "Time_Start": 424.0,
      "Time_End": 430.0,
      "Text": " DigiNoter CA and in 2012, the Flame malware abused chosen prefixes like the 2008 rogue CA"
    },
    {
      "Time_Start": 432.94,
      "Time_End": 438.94,
      "Text": " attack that let them generate a fake Microsoft CA. So, what type of attacks are relevant for"
    },
    {
      "Time_Start": 439.94,
      "Time_End": 445.94,
      "Text": " digital signatures? Well, we have three broad categories that are generally applicable to a"
    },
    {
      "Time_Start": 450.7,
      "Time_End": 456.48,
      "Text": " lot more than just signatures. Let's break these down. First, we have memory corruption"
    },
    {
      "Time_Start": 456.48,
      "Time_End": 462.18,
      "Text": " issues. These are your classic out of bounds read, write, or stack overflow vulnerabilities"
    },
    {
      "Time_Start": 462.18,
      "Time_End": 468.76,
      "Text": " that can often arise from the mishandling of untrusted data. How do we find them? Typically,"
    },
    {
      "Time_Start": 468.78,
      "Time_End": 475.88,
      "Text": " manual or guided analysis as well as fuzzing are good strategies. How do we fix them? Well,"
    },
    {
      "Time_Start": 475.88,
      "Time_End": 481.56,
      "Text": " one of the best advice I can give is to minimize your attack surface. Limit the code that"
    },
    {
      "Time_Start": 481.56,
      "Time_End": 488.46,
      "Text": " processes untrusted data. You can also use various mitigations or memory safe programming"
    },
    {
      "Time_Start": 488.46,
      "Time_End": 496.46,
      "Text": " languages like Rust to substantially reduce your risk to these issues. Next, we have logic"
    },
    {
      "Time_Start": 496.46000000000004,
      "Time_End": 504.16,
      "Text": " flaws. These are highly context specific issues that vary by application. How do we find"
    },
    {
      "Time_Start": 504.16,
      "Time_End": 509.46000000000004,
      "Text": " them? Manual or guided analysis. These issues require a decent understanding of the"
    },
    {
      "Time_Start": 509.46000000000004,
      "Time_End": 515.46,
      "Text": " application's design and intended usage. For example, look for differences in logic and"
    },
    {
      "Time_Start": 518.0400000000001,
      "Time_End": 523.88,
      "Text": " between a design document and the actual implementation. How do we prevent them? Well,"
    },
    {
      "Time_Start": 523.92,
      "Time_End": 530.3,
      "Text": " again, minimizing the code that processes the untrusted data is a good place to start."
    },
    {
      "Time_Start": 530.3,
      "Time_End": 536.04,
      "Text": " Having a test suite of expected outcomes are another good way to prevent regressions and"
    },
    {
      "Time_Start": 536.04,
      "Time_End": 541.8,
      "Text": " validate design assumptions. We also have cryptographic flaws. These are different than"
    },
    {
      "Time_Start": 541.8,
      "Time_End": 546.38,
      "Text": " the implementation issues we just discussed in that they exist in a cryptographic"
    },
    {
      "Time_Start": 546.38,
      "Time_End": 551.5,
      "Text": " algorithm. How do we find them? Typically, this involves mathematical analysis of"
    },
    {
      "Time_Start": 551.5,
      "Time_End": 556.42,
      "Text": " algorithms to ensure things like pre-image resistance, second pre-image resistance, and"
    },
    {
      "Time_Start": 556.42,
      "Time_End": 562.42,
      "Text": " strong collision resistance. How do we prevent them? Well, for most, the golden rule is just"
    },
    {
      "Time_Start": 562.42,
      "Time_End": 568.42,
      "Text": " don't rule your own crypto. Don't deviate from the specification that you're implementing."
    },
    {
      "Time_Start": 574.66,
      "Time_End": 580.34,
      "Text": " So writing cryptographic systems is challenging due to their inherent complexity."
    },
    {
      "Time_Start": 580.38,
      "Time_End": 584.96,
      "Text": " Cryptographic implementations aren't isolated. They interact with a multitude of other"
    },
    {
      "Time_Start": 584.96,
      "Time_End": 591.34,
      "Text": " systems, protocols, and software. Patching implementation issues can get complicated as"
    },
    {
      "Time_Start": 591.34,
      "Time_End": 598.8000000000001,
      "Text": " well. For example, like one reason why XYZ insecure future, let's say MD5, is difficult to"
    },
    {
      "Time_Start": 598.8000000000001,
      "Time_End": 604.5,
      "Text": " get rid of is because if you simply prevented its use entirely, you may break legacy"
    },
    {
      "Time_Start": 604.54,
      "Time_End": 611.3,
      "Text": " systems and applications. Memory corruption is better understood. Logic flaws are much"
    },
    {
      "Time_Start": 611.3,
      "Time_End": 617.3,
      "Text": " harder to prevent as they are context specific. Let's review the different types of signing"
    },
    {
      "Time_Start": 622.3,
      "Time_End": 627.96,
      "Text": " certificates and the minimum requirements for obtaining them. First, we have regular SSL"
    },
    {
      "Time_Start": 627.96,
      "Time_End": 633.84,
      "Text": " certificates used to secure your connection with a web server. At a minimum, you need to"
    },
    {
      "Time_Start": 633.88,
      "Time_End": 639.8000000000001,
      "Text": " prove that you own the domain that you are requesting the certificate for. This can"
    },
    {
      "Time_Start": 639.8000000000001,
      "Time_End": 647.1,
      "Text": " involve adding a DNS record or serving a provided file over HTTP. SMIME certificates are"
    },
    {
      "Time_Start": 647.1,
      "Time_End": 652.14,
      "Text": " used for securing email communications like SSL certificates. You need to prove that you"
    },
    {
      "Time_Start": 652.14,
      "Time_End": 656.52,
      "Text": " own the email address that you're requesting a certificate for, which can include the"
    },
    {
      "Time_Start": 656.52,
      "Time_End": 662.52,
      "Text": " identity of yourself or your organization. The second type of signing certificates are"
    },
    {
      "Time_Start": 664.84,
      "Time_End": 669.48,
      "Text": " documents. We also have code signing certificates. These are used to maintain the"
    },
    {
      "Time_Start": 669.48,
      "Time_End": 675.1800000000001,
      "Text": " integrity of your software. Unlike SMIME certificates, the bar for obtaining one is"
    },
    {
      "Time_Start": 675.1800000000001,
      "Time_End": 681.94,
      "Text": " substantially higher. As we'll soon discuss, you will almost always need to verify your"
    },
    {
      "Time_Start": 681.94,
      "Time_End": 688.76,
      "Text": " identity or the legitimacy of your organization. Finally, we also have document signing"
    },
    {
      "Time_Start": 688.76,
      "Time_End": 693.34,
      "Text": " certificates. These are in a bit of a gray area as they're frequently interchangeable with"
    },
    {
      "Time_Start": 693.5600000000001,
      "Time_End": 699.5600000000001,
      "Text": " SMIME or SSL certificates and have similar requirements. The requirements for different"
    },
    {
      "Time_Start": 702.5600000000001,
      "Time_End": 707.1,
      "Text": " types of certificates can greatly vary. Let's break down the different types of validation"
    },
    {
      "Time_Start": 707.1,
      "Time_End": 713.44,
      "Text": " that certificate authorities can perform. With domain validation or DV, you need to prove"
    },
    {
      "Time_Start": 713.44,
      "Time_End": 719.44,
      "Text": " that you control a given domain. This is a pretty low bar for verification because there's a"
    },
    {
      "Time_Start": 719.48,
      "Time_End": 725.7800000000001,
      "Text": " higher risk of abuse. All you need to do is put up a file on your web server. Organization"
    },
    {
      "Time_Start": 725.7800000000001,
      "Time_End": 731.32,
      "Text": " validation is where we get into the moderate level of verification. During this process,"
    },
    {
      "Time_Start": 731.32,
      "Time_End": 736.5200000000001,
      "Text": " you need to prove the legal and physical existence of your organization. This is the bare"
    },
    {
      "Time_Start": 736.5200000000001,
      "Time_End": 742.74,
      "Text": " minimum for code signing certificates and other sensitive digital use cases. Extended"
    },
    {
      "Time_Start": 742.74,
      "Time_End": 748.12,
      "Text": " validation is one of the highest levels of validation that a CA can perform. It's"
    },
    {
      "Time_Start": 748.12,
      "Time_End": 753.72,
      "Text": " everything you need for organization validation but more. For example, you often need to"
    },
    {
      "Time_Start": 753.72,
      "Time_End": 758.34,
      "Text": " show that your business is legitimate and not a shell company. This can include face to"
    },
    {
      "Time_Start": 758.34,
      "Time_End": 764.34,
      "Text": " face verification. When I started my research into digital signature implementations, the"
    },
    {
      "Time_Start": 768.34,
      "Time_End": 774.54,
      "Text": " differences between certificate requirements caught my eye. For example, in our context,"
    },
    {
      "Time_Start": 774.54,
      "Time_End": 780.3,
      "Text": " having a digital signature alone is not sufficient. We not only need to be able to verify"
    },
    {
      "Time_Start": 780.3,
      "Time_End": 784.92,
      "Text": " that a signature is cryptographically valid, but also that it originates from a trusted"
    },
    {
      "Time_Start": 784.92,
      "Time_End": 790.92,
      "Text": " source. These two diagrams overview the extended validation versus domain validation process."
    },
    {
      "Time_Start": 794.4599999999999,
      "Time_End": 801.38,
      "Text": " The question I had was, what prevents an attacker from abusing a certificate that has only"
    },
    {
      "Time_Start": 801.38,
      "Time_End": 807.26,
      "Text": " proven domain ownership for purposes that require a higher level of verification, like"
    },
    {
      "Time_Start": 807.26,
      "Time_End": 813.26,
      "Text": " code signing? Now, let's get into the fun stuff. What defines a certificate's purpose? What"
    },
    {
      "Time_Start": 821.14,
      "Time_End": 827.1,
      "Text": " distinguishes an SSL certificate from a code signing certificate? Often, it's the extended"
    },
    {
      "Time_Start": 827.1,
      "Time_End": 833.74,
      "Text": " key usage field present in most end entity certificates. EKUs can specify what a"
    },
    {
      "Time_Start": 833.74,
      "Time_End": 839.78,
      "Text": " certificate is allowed to be used for. As an example, the image on the right shows this field"
    },
    {
      "Time_Start": 839.78,
      "Time_End": 845.48,
      "Text": " from an SSL certificate. The server and client authentication usages mean that the"
    },
    {
      "Time_Start": 845.48,
      "Time_End": 851.48,
      "Text": " certificate is allowed to authenticate to a remote server or client. But what actually"
    },
    {
      "Time_Start": 852.32,
      "Time_End": 858.32,
      "Text": " verifies these EKUs in practice? When you sign digital data, the utility you use can impose"
    },
    {
      "Time_Start": 864.78,
      "Time_End": 869.58,
      "Text": " restrictions. For example, if you're signing an executable, you may receive an error if you"
    },
    {
      "Time_Start": 869.58,
      "Time_End": 874.9,
      "Text": " try to sign an executable without the code signing EKU present on the certificate you're"
    },
    {
      "Time_Start": 874.9,
      "Time_End": 881.04,
      "Text": " using. But the restrictions these tools impose are not what matters, because they run"
    },
    {
      "Time_Start": 881.54,
      "Time_End": 887.54,
      "Text": " before the attack is actually performed. As we'll soon see, if I, as an attacker, got an"
    },
    {
      "Time_Start": 887.54,
      "Time_End": 892.88,
      "Text": " error related to the intended purpose of my certificate, there's nothing stopping me from"
    },
    {
      "Time_Start": 892.88,
      "Time_End": 898.88,
      "Text": " modifying the tool to bypass this check. So, how do we identify vulnerable implementations"
    },
    {
      "Time_Start": 902.14,
      "Time_End": 908.14,
      "Text": " that fail to validate a certificate's intended purpose? First, we started by identifying"
    },
    {
      "Time_Start": 908.64,
      "Time_End": 914.64,
      "Text": " some basic criteria. The Microsoft Security Response Center is interested in protecting the"
    },
    {
      "Time_Start": 916.64,
      "Time_End": 922.76,
      "Text": " entire ecosystem, not just first party implementations. We ended up looking at a variety"
    },
    {
      "Time_Start": 922.76,
      "Time_End": 928.22,
      "Text": " of file formats that leverage digital signatures. Most frequently, this included code"
    },
    {
      "Time_Start": 928.22,
      "Time_End": 934.22,
      "Text": " signing, because of the bare minimum organization validation requirement. For testing,"
    },
    {
      "Time_Start": 938.26,
      "Time_End": 945.68,
      "Text": " we also generated an SSL certificate, which only required proof of domain control. In the"
    },
    {
      "Time_Start": 945.68,
      "Time_End": 950.68,
      "Text": " next few slides, we'll review the signing tools relevant to the file formats we're interested"
    },
    {
      "Time_Start": 950.68,
      "Time_End": 957.14,
      "Text": " in and modify them to remove any client side checks. Remember, modifying our signing tools"
    },
    {
      "Time_Start": 957.14,
      "Time_End": 963.3,
      "Text": " comes before any attack on our environment. What matters is the receiving end and how it"
    },
    {
      "Time_Start": 963.3000000000001,
      "Time_End": 969.3000000000001,
      "Text": " handles EKUs. To start with, I looked at Microsoft's sign tool, which lets you sign over"
    },
    {
      "Time_Start": 971.5000000000001,
      "Time_End": 976.6800000000001,
      "Text": " 25 unique file extensions. This utility is most often used for authentic code and is"
    },
    {
      "Time_Start": 976.6800000000001,
      "Time_End": 982.6800000000001,
      "Text": " included with Windows SDK. First, I performed a sanity check and tried to sign an SSL"
    },
    {
      "Time_Start": 984.5000000000001,
      "Time_End": 991.1,
      "Text": " certificate, sorry, tried to sign an executable with an SSL certificate. As you can see, sign"
    },
    {
      "Time_Start": 991.14,
      "Time_End": 996.36,
      "Text": " tool by default does validate the EKUs of your code signing certificate. We need to get"
    },
    {
      "Time_Start": 996.36,
      "Time_End": 1002.5600000000001,
      "Text": " around this. Using IDA Pro, I was able to quickly find the function responsible for the"
    },
    {
      "Time_Start": 1002.5600000000001,
      "Time_End": 1009.1,
      "Text": " check by looking for the EKU filter error string. The function was conveniently named"
    },
    {
      "Time_Start": 1009.1,
      "Time_End": 1014.86,
      "Text": " filter certificates. I patched the function to immediately return and avoid filtering"
    },
    {
      "Time_Start": 1014.86,
      "Time_End": 1020.86,
      "Text": " entirely. Next time I tried signing my executable, it worked without a problem. Sign"
    },
    {
      "Time_Start": 1028.2,
      "Time_End": 1033.3600000000001,
      "Text": " tool isn't the only utility relevant to this project. The manifest generation and"
    },
    {
      "Time_Start": 1033.3600000000001,
      "Time_End": 1039.4,
      "Text": " editing tool is used to create and modify application and deployment manifests. Part of"
    },
    {
      "Time_Start": 1039.4,
      "Time_End": 1044.3600000000001,
      "Text": " this tool includes the ability to sign manifests. We'll discuss how these manifests are"
    },
    {
      "Time_Start": 1044.3600000000001,
      "Time_End": 1050.3600000000001,
      "Text": " used in a later slide. Like sign tool, mage performs EKU verification when signing a"
    },
    {
      "Time_Start": 1053.98,
      "Time_End": 1059.98,
      "Text": " manifest. Unlike sign tool, mage is written in C sharp. How can we patch this EKU check? I"
    },
    {
      "Time_Start": 1062.7,
      "Time_End": 1068.44,
      "Text": " use DN spot, an older .NET assembly editor that allows you to both decompile and modify C"
    },
    {
      "Time_Start": 1068.52,
      "Time_End": 1074.52,
      "Text": " sharp applications. I found a responsible method can sign with by looking for the relevant"
    },
    {
      "Time_Start": 1079.6000000000001,
      "Time_End": 1085.6000000000001,
      "Text": " error message. Using DN spy, I modified this method to always return bypassing the EKU"
    },
    {
      "Time_Start": 1087.6000000000001,
      "Time_End": 1093.6000000000001,
      "Text": " check. And as expected, this modification allows you to sign manifests with an open"
    },
    {
      "Time_Start": 1098.44,
      "Time_End": 1106.06,
      "Text": " unrelated certificate. Now that we've prepared our test data, signed with our SSL"
    },
    {
      "Time_Start": 1106.06,
      "Time_End": 1112.06,
      "Text": " certificate, let's try it against real world authentic code implementations. All right. Some"
    },
    {
      "Time_Start": 1114.06,
      "Time_End": 1119.6000000000001,
      "Text": " background. On Windows, the primary API commonly used to verify the trust of supported"
    },
    {
      "Time_Start": 1119.6000000000001,
      "Time_End": 1126.18,
      "Text": " objects is win verify trust. This function abstracts the job of signature validation to"
    },
    {
      "Time_Start": 1126.18,
      "Time_End": 1132.8400000000001,
      "Text": " subject interface packages and trust providers. Sips are responsible for the format"
    },
    {
      "Time_Start": 1132.8400000000001,
      "Time_End": 1139.18,
      "Text": " specific verification of digital signatures. For example, a portable executable will store"
    },
    {
      "Time_Start": 1139.18,
      "Time_End": 1145.68,
      "Text": " digital signatures in a different format compared to a power shell script. The key is that"
    },
    {
      "Time_Start": 1145.68,
      "Time_End": 1151.64,
      "Text": " there's a sip for both to handle both formats. In this talk, we'll briefly review this"
    },
    {
      "Time_Start": 1151.64,
      "Time_End": 1156.3400000000001,
      "Text": " architecture. But if you're interested in understanding this design in detail, I would"
    },
    {
      "Time_Start": 1156.3400000000001,
      "Time_End": 1162.3400000000001,
      "Text": " strongly recommend that you read subverting trust in Windows by Matt Graber. Trust"
    },
    {
      "Time_Start": 1166.96,
      "Time_End": 1174.0,
      "Text": " providers don't care about the sip you use. They are designed to perform format agnostic"
    },
    {
      "Time_Start": 1174.0,
      "Time_End": 1180.18,
      "Text": " trust verification actions. Common providers include generic cert verify, which will verify"
    },
    {
      "Time_Start": 1180.18,
      "Time_End": 1187.8,
      "Text": " a certificate. Generic chain verify, which will verify a certificate's chain of trust. And"
    },
    {
      "Time_Start": 1187.8,
      "Time_End": 1192.64,
      "Text": " generic verify alone will verify a file or object according to the authentic code"
    },
    {
      "Time_Start": 1192.64,
      "Time_End": 1199.42,
      "Text": " specification. The generic verify provider is most commonly used for verifying authentic"
    },
    {
      "Time_Start": 1199.42,
      "Time_End": 1205.42,
      "Text": " code formats. As a simple test, I wrote a small test application to verify an executable"
    },
    {
      "Time_Start": 1206.42,
      "Time_End": 1212.42,
      "Text": " signature using win verify trust. Unfortunately, or fortunately, depending on how you look"
    },
    {
      "Time_Start": 1215.2,
      "Time_End": 1220.78,
      "Text": " at it, it didn't work. I received an error stating this certificate is not valid for the"
    },
    {
      "Time_Start": 1220.78,
      "Time_End": 1226.78,
      "Text": " requested usage. Remember the generic verify trust provider? Unfortunately, it turns out"
    },
    {
      "Time_Start": 1229.74,
      "Time_End": 1233.8200000000002,
      "Text": " that one of the basic requirements for this provider, which is used in almost all"
    },
    {
      "Time_Start": 1233.82,
      "Time_End": 1239.82,
      "Text": " authentic code formats, is that the code signing EKU is present. This meant that most"
    },
    {
      "Time_Start": 1242.52,
      "Time_End": 1248.52,
      "Text": " of these formats that are verified through this architecture by default are protected."
    },
    {
      "Time_Start": 1253.06,
      "Time_End": 1257.4399999999998,
      "Text": " Although Windows may have gotten it right, I was curious about other libraries that"
    },
    {
      "Time_Start": 1257.4399999999998,
      "Time_End": 1262.6399999999999,
      "Text": " validated the authenticity of authentic code applications. What about workloads that"
    },
    {
      "Time_Start": 1262.68,
      "Time_End": 1267.3000000000002,
      "Text": " needed to verify these signatures on other operating systems? Unfortunately, as we'll"
    },
    {
      "Time_Start": 1267.3000000000002,
      "Time_End": 1272.76,
      "Text": " soon see, several authentic code implementations outside of Windows itself were vulnerable"
    },
    {
      "Time_Start": 1272.76,
      "Time_End": 1278.76,
      "Text": " to this attack. So, the Mono project is an open source equivalent to Microsoft's dot net"
    },
    {
      "Time_Start": 1283.22,
      "Time_End": 1289.88,
      "Text": " framework. Microsoft sponsors the project and Mono is frequently used in cross platform"
    },
    {
      "Time_Start": 1289.88,
      "Time_End": 1295.88,
      "Text": " applications that want to use dot net. Mono supports authentic code signing and"
    },
    {
      "Time_Start": 1299.22,
      "Time_End": 1305.7600000000002,
      "Text": " verification with its authentic code deformatter and authentic code formatter classes. How"
    },
    {
      "Time_Start": 1305.7600000000002,
      "Time_End": 1309.8000000000002,
      "Text": " can we test Mono's authentic code implementation? Well, fortunately, it comes with a"
    },
    {
      "Time_Start": 1309.8000000000002,
      "Time_End": 1315.8000000000002,
      "Text": " check trust tool that allows us to verify the signature of an executable. Unfortunately,"
    },
    {
      "Time_Start": 1316.8,
      "Time_End": 1322.8,
      "Text": " due to a lack of EKU validation, Mono's authentic code deformatter class is vulnerable to"
    },
    {
      "Time_Start": 1324.1399999999999,
      "Time_End": 1331.26,
      "Text": " the attack. This issue isn't specific to Mono's simple check trust testing utility. Any"
    },
    {
      "Time_Start": 1331.26,
      "Time_End": 1337.26,
      "Text": " Mono application that uses this class for verifying untrusted executables is potentially"
    },
    {
      "Time_Start": 1337.26,
      "Time_End": 1343.26,
      "Text": " vulnerable. Trail of Bits is a security consulting firm that helps organizations verify"
    },
    {
      "Time_Start": 1346.56,
      "Time_End": 1352.26,
      "Text": " engineer secure applications. They have quite a few open source tools and one of those"
    },
    {
      "Time_Start": 1352.26,
      "Time_End": 1359.1,
      "Text": " projects includes authentic code. Authentic code is a cross platform library that allows"
    },
    {
      "Time_Start": 1359.1,
      "Time_End": 1365.4199999999998,
      "Text": " you to verify a digital signature of a portable executable. The intent is to provide"
    },
    {
      "Time_Start": 1365.4199999999998,
      "Time_End": 1370.4199999999998,
      "Text": " similar functionality to API like WinVerify Trust on non-Windows platforms. Unlike WinVerify"
    },
    {
      "Time_Start": 1371.3400000000001,
      "Time_End": 1379.3400000000001,
      "Text": " Trust, however, authentic code only verifies an authentic code signature. It doesn't verify"
    },
    {
      "Time_Start": 1379.3400000000001,
      "Time_End": 1386.38,
      "Text": " a certificate's chain of trust. The chain of trust isn't relevant to EKUs. You can verify"
    },
    {
      "Time_Start": 1386.38,
      "Time_End": 1391.0800000000002,
      "Text": " that a leaf certificate is allowed to be used for code signing without verifying that it was"
    },
    {
      "Time_Start": 1391.0800000000002,
      "Time_End": 1397.0800000000002,
      "Text": " issued by a trusted root certificate authority. Unfortunately, authentic code is not"
    },
    {
      "Time_Start": 1401.3000000000002,
      "Time_End": 1408.0,
      "Text": " vulnerable to the EKU attack, allowing attackers to sign code with an unrelated certificate."
    },
    {
      "Time_Start": 1408.0,
      "Time_End": 1414.92,
      "Text": " Fair disclaimer, the real world implications of the EKU attack with authentic code are"
    },
    {
      "Time_Start": 1414.92,
      "Time_End": 1419.5800000000002,
      "Text": " limited. For example, according to the authors I spoke with, authentic code is frequently"
    },
    {
      "Time_Start": 1419.5800000000002,
      "Time_End": 1425.46,
      "Text": " used in CICD stacks for basic authentic code validation. Of course, given it's open"
    },
    {
      "Time_Start": 1425.46,
      "Time_End": 1431.46,
      "Text": " source nature, it's hard to quantify its use with certainty. When I was, I also wanted to"
    },
    {
      "Time_Start": 1435.1200000000001,
      "Time_End": 1440.28,
      "Text": " review a bonus example. When I was reviewing authentic code's implementation of signature"
    },
    {
      "Time_Start": 1440.28,
      "Time_End": 1447.0,
      "Text": " verification, I noticed that it deviated from the authentic code specification. On the"
    },
    {
      "Time_Start": 1447.0,
      "Time_End": 1452.74,
      "Text": " left, we have the same diagram from the earlier slide, showing a high level overview of"
    },
    {
      "Time_Start": 1452.74,
      "Time_End": 1458.78,
      "Text": " how portable executables are verified under authentic code. On the right, I've modified the"
    },
    {
      "Time_Start": 1458.78,
      "Time_End": 1465.6200000000001,
      "Text": " diagram to reflect authentic code's implementation of the specification. So according to the"
    },
    {
      "Time_Start": 1465.6200000000001,
      "Time_End": 1470.7,
      "Text": " authentic code specification, you're supposed to hash the contents of an executable by"
    },
    {
      "Time_Start": 1470.7,
      "Time_End": 1478.7,
      "Text": " concatenating the hashes of the PE header, sorted sections and any extra data. Authentic code"
    },
    {
      "Time_Start": 1478.78,
      "Time_End": 1485.66,
      "Text": " ignored these PE sections. Instead, they'd hash the PE header and the rest of the file,"
    },
    {
      "Time_Start": 1485.66,
      "Time_End": 1491.74,
      "Text": " excluding the security directory. From a practical stance, what this meant was that it would"
    },
    {
      "Time_Start": 1491.74,
      "Time_End": 1497.1200000000001,
      "Text": " take everything before the security directory and everything after the security directory"
    },
    {
      "Time_Start": 1497.1200000000001,
      "Time_End": 1504.54,
      "Text": " and then combine the two and calculate a hash on that result. On the earlier slide about"
    },
    {
      "Time_Start": 1504.54,
      "Time_End": 1510.42,
      "Text": " attacking digital signatures, I mentioned how you shouldn't ever roll your own crypto or"
    },
    {
      "Time_Start": 1510.42,
      "Time_End": 1516.42,
      "Text": " deviate from the specification. I was curious, what are the implications of this deviation?"
    },
    {
      "Time_Start": 1520.3,
      "Time_End": 1526.26,
      "Text": " Unfortunately, this deviation led to a pretty big flaw. I found that by embedding the"
    },
    {
      "Time_Start": 1526.26,
      "Time_End": 1533.54,
      "Text": " security directory within a PE section, I could modify the code of an executable without"
    },
    {
      "Time_Start": 1533.54,
      "Time_End": 1539.3,
      "Text": " changing its authentic code hash according to authentic code. The problem was that since"
    },
    {
      "Time_Start": 1539.3,
      "Time_End": 1543.8799999999999,
      "Text": " authentic code skips over the security directory, it would hash everything up to the"
    },
    {
      "Time_Start": 1543.8799999999999,
      "Time_End": 1550.04,
      "Text": " modified PE section, ignore the security directory with malicious code and hash everything"
    },
    {
      "Time_Start": 1550.04,
      "Time_End": 1556.72,
      "Text": " after. You could move around the security directory and the authentic code hash, as"
    },
    {
      "Time_Start": 1556.72,
      "Time_End": 1562.72,
      "Text": " calculated by authentic code, would remain unmodified. So I'm going to talk a little bit"
    },
    {
      "Time_Start": 1563.54,
      "Time_End": 1568.96,
      "Text": " more about this. I was able to leverage this attack to replace the entry point of a"
    },
    {
      "Time_Start": 1568.96,
      "Time_End": 1576.92,
      "Text": " legitimate Microsoft executable with malicious shellcode. This issue is not related to EKUs. It"
    },
    {
      "Time_Start": 1576.92,
      "Time_End": 1582.34,
      "Text": " was simply an extra implementation flaw that I stumbled upon. But it highlights the"
    },
    {
      "Time_Start": 1582.34,
      "Time_End": 1588.18,
      "Text": " importance of sticking with the specification and how one small mistake when implementing"
    },
    {
      "Time_Start": 1588.18,
      "Time_End": 1594.18,
      "Text": " digital signatures can have a devastating impact. Let's discuss ClickOnce. ClickOnce is a"
    },
    {
      "Time_Start": 1600.9,
      "Time_End": 1606.18,
      "Text": " deployment technology that allows developers to create self-updating applications that can"
    },
    {
      "Time_Start": 1606.18,
      "Time_End": 1612.18,
      "Text": " be installed or run with minimal user interaction. Under the hood, ClickOnce deployments are"
    },
    {
      "Time_Start": 1612.6000000000001,
      "Time_End": 1618.6000000000001,
      "Text": " made up of application files, a deployment manifest and an optional application manifest. The"
    },
    {
      "Time_Start": 1624.52,
      "Time_End": 1631.0600000000002,
      "Text": " cool part of ClickOnce is that you can install or run applications from a website. The"
    },
    {
      "Time_Start": 1631.0600000000002,
      "Time_End": 1636.1000000000001,
      "Text": " picture shows what a ClickOnce prompt can look like, which can be triggered by a link in a"
    },
    {
      "Time_Start": 1636.14,
      "Time_End": 1642.14,
      "Text": " browser that supports ClickOnce. ClickOnce applications can be signed automatically with"
    },
    {
      "Time_Start": 1649.1000000000001,
      "Time_End": 1655.5600000000002,
      "Text": " Visual Studio or manually with Mage. The diagram below demonstrates this. First, we take an"
    },
    {
      "Time_Start": 1655.5600000000002,
      "Time_End": 1661.1000000000001,
      "Text": " unsigned ClickOnce deployment. We sign the application manifest in the application files"
    },
    {
      "Time_Start": 1661.1000000000001,
      "Time_End": 1666.8600000000001,
      "Text": " directory. We sign the deployment manifest in the application files directory. And then we"
    },
    {
      "Time_Start": 1666.8600000000001,
      "Time_End": 1671.8600000000001,
      "Text": " optionally sign the application manifest in the root directory. This gives us a signed"
    },
    {
      "Time_Start": 1671.8600000000001,
      "Time_End": 1677.8600000000001,
      "Text": " ClickOnce deployment. Once the deployment was signed, it was uploaded to a web server for"
    },
    {
      "Time_Start": 1680.44,
      "Time_End": 1686.5200000000002,
      "Text": " testing. The picture below shows you what this ClickOnce prompt can look like in Microsoft"
    },
    {
      "Time_Start": 1686.52,
      "Time_End": 1692.52,
      "Text": " Edge. It asks, do you want to open test ClickOnce application from the domain that you're"
    },
    {
      "Time_Start": 1694.32,
      "Time_End": 1700.32,
      "Text": " visiting? The page itself can have any content you want. Unfortunately, ClickOnce was"
    },
    {
      "Time_Start": 1702.78,
      "Time_End": 1708.7,
      "Text": " impacted by this attack. As you can see in the picture below, the publisher shows as the"
    },
    {
      "Time_Start": 1708.7,
      "Time_End": 1715.4,
      "Text": " domain that I had registered an SSL certificate for. If you try to use a certificate that was"
    },
    {
      "Time_Start": 1715.44,
      "Time_End": 1720.2800000000002,
      "Text": " not issued by a trusted authority, well, it would show that error in saying that the"
    },
    {
      "Time_Start": 1720.2800000000002,
      "Time_End": 1725.1200000000001,
      "Text": " certificate is not trusted. But unfortunately, because ClickOnce didn't actually validate"
    },
    {
      "Time_Start": 1725.1200000000001,
      "Time_End": 1731.1200000000001,
      "Text": " EKUs, it considers the certificate that I signed my deployment with as legitimate. What"
    },
    {
      "Time_Start": 1735.5400000000002,
      "Time_End": 1741.1200000000001,
      "Text": " about other uses of digital signatures that we didn't cover? I want to talk a little bit about"
    },
    {
      "Time_Start": 1741.1200000000001,
      "Time_End": 1747.2600000000002,
      "Text": " some related work. In 2014, researchers from the University of Texas and California"
    },
    {
      "Time_Start": 1747.2600000000002,
      "Time_End": 1753.8400000000001,
      "Text": " released using frankincerts for automated adversarial testing of certificate validation and"
    },
    {
      "Time_Start": 1753.8400000000001,
      "Time_End": 1760.5400000000002,
      "Text": " SSL slash TLS implementations. As the name suggests, the researchers generated mutated"
    },
    {
      "Time_Start": 1760.5400000000002,
      "Time_End": 1766.96,
      "Text": " certificates with different combinations of extensions and constraints. The idea was to"
    },
    {
      "Time_Start": 1767.0,
      "Time_End": 1774.26,
      "Text": " look for inconsistencies between implementations. Now, this paper exclusively focuses on SSL"
    },
    {
      "Time_Start": 1774.26,
      "Time_End": 1780.26,
      "Text": " and TLS implementations in OpenSSL, NSS, etc. Of relevance to this talk, the researchers"
    },
    {
      "Time_Start": 1785.8,
      "Time_End": 1793.8,
      "Text": " found several libraries that failed to validate the appropriate EKU. Instead of malformed"
    },
    {
      "Time_Start": 1793.8,
      "Time_End": 1799.1399999999999,
      "Text": " certificates for digital signatures and executables, they looked at abusing them in the"
    },
    {
      "Time_Start": 1799.1399999999999,
      "Time_End": 1803.8999999999999,
      "Text": " browser. If you're interested in reading more, I'd recommend that you check out the link"
    },
    {
      "Time_Start": 1803.8999999999999,
      "Time_End": 1809.8999999999999,
      "Text": " below. We additionally verified that common libraries like OpenSSL validated these EKUs"
    },
    {
      "Time_Start": 1816.06,
      "Time_End": 1822.1399999999999,
      "Text": " appropriately. Now, if you use these libraries for solely verifying the authenticity of a"
    },
    {
      "Time_Start": 1822.18,
      "Time_End": 1828.48,
      "Text": " certificate without specifying a purpose or there's no default, you can still be exposed to"
    },
    {
      "Time_Start": 1828.48,
      "Time_End": 1834.48,
      "Text": " an EKU attack. For example, in OpenSSL, you can specify context for X509 verification as seen"
    },
    {
      "Time_Start": 1836.3600000000001,
      "Time_End": 1841.94,
      "Text": " in the picture below, which can include these EKU defaults. For example, if I set the"
    },
    {
      "Time_Start": 1841.94,
      "Time_End": 1847.64,
      "Text": " context that I'm an SSL client, OpenSSL has the correct defaults to validate that the"
    },
    {
      "Time_Start": 1847.64,
      "Time_End": 1853.14,
      "Text": " client authentication, excuse me, server authentication EKU is present on the server"
    },
    {
      "Time_Start": 1853.14,
      "Time_End": 1859.14,
      "Text": " certificate and vice versa if you say that you're an SSL server. Let's review some of the"
    },
    {
      "Time_Start": 1861.8200000000002,
      "Time_End": 1868.22,
      "Text": " takeaways and techniques. In this project, we discovered numerous implementations of"
    },
    {
      "Time_Start": 1868.22,
      "Time_End": 1874.3200000000002,
      "Text": " digital signatures that failed to validate the extended key usage field. This would allow"
    },
    {
      "Time_Start": 1874.32,
      "Time_End": 1880.1599999999999,
      "Text": " an attacker to abuse certificates with a substantially lower bar for identity"
    },
    {
      "Time_Start": 1880.1599999999999,
      "Time_End": 1886.04,
      "Text": " verification in important context, like code signing. The diagram below demonstrates this"
    },
    {
      "Time_Start": 1886.04,
      "Time_End": 1893.4199999999998,
      "Text": " attack. First, an attacker buys or generates a low cost certificate, whether this be SSL,"
    },
    {
      "Time_Start": 1893.4199999999998,
      "Time_End": 1900.4199999999998,
      "Text": " SMIM, etc., is up to them. Next, they sign unrelated data with the mismatched certificate."
    },
    {
      "Time_Start": 1900.42,
      "Time_End": 1905.9,
      "Text": " This could include modifying the signing tools to allow this in the first place. Then"
    },
    {
      "Time_Start": 1905.9,
      "Time_End": 1913.3600000000001,
      "Text": " vulnerable apps fail to validate and detect the invalid certificate. As a result, users can"
    },
    {
      "Time_Start": 1913.3600000000001,
      "Time_End": 1919.94,
      "Text": " receive a false sense of trust. It can bypass important access controls and more depending"
    },
    {
      "Time_Start": 1919.94,
      "Time_End": 1925.94,
      "Text": " on the context. So how do you protect your implementation? Well, number one, always"
    },
    {
      "Time_Start": 1925.94,
      "Time_End": 1931.94,
      "Text": " fix, excuse me, always validate EKUs in your application to ensure that certificates are"
    },
    {
      "Time_Start": 1934.64,
      "Time_End": 1941.8600000000001,
      "Text": " used for their intended purposes. Use libraries that properly implement EKU checks. Trust,"
    },
    {
      "Time_Start": 1941.8600000000001,
      "Time_End": 1947.96,
      "Text": " but verify key principles in your application's design. Every single implementation that was"
    },
    {
      "Time_Start": 1947.96,
      "Time_End": 1954.3,
      "Text": " vulnerable to this attack we covered today were supposed to check for EKUs. No one verified"
    },
    {
      "Time_Start": 1954.32,
      "Time_End": 1961.1,
      "Text": " that they did. Implement regular security testing, especially in components using"
    },
    {
      "Time_Start": 1961.1,
      "Time_End": 1967.84,
      "Text": " cryptography for crucial futures. Your implementation is much more likely to be vulnerable"
    },
    {
      "Time_Start": 1967.84,
      "Time_End": 1972.84,
      "Text": " than a cryptographic algorithm. What is Microsoft doing to protect customers? Well, number"
    },
    {
      "Time_Start": 1976.58,
      "Time_End": 1982.56,
      "Text": " one, we've released patches for all first party issues. The third party vulnerabilities we've"
    },
    {
      "Time_Start": 1982.56,
      "Time_End": 1988.96,
      "Text": " discussed were also fixed. We're continuing to work with impacted third party vendors to"
    },
    {
      "Time_Start": 1988.96,
      "Time_End": 1994.3,
      "Text": " address their implementations. And we also continue to explore issues in digital signature"
    },
    {
      "Time_Start": 1994.3,
      "Time_End": 2000.3,
      "Text": " implementations. Below is a list of relevant CVEs that were issued as a result of this work."
    },
    {
      "Time_Start": 2005.34,
      "Time_End": 2009.52,
      "Text": " Thanks for coming to my talk. And now is the time for questions as time permits."
    },
    {
      "Time_Start": 2009.52,
      "Time_End": 2015.52,
      "Text": " So the question was, would cert pinning help in this context? So it can help in the sense"
    },
    {
      "Time_Start": 2015.52,
      "Time_End": 2021.52,
      "Text": " that if there's only a certain subset of trusted authorities that can issue certificates that"
    },
    {
      "Time_Start": 2022.28,
      "Time_End": 2028.28,
      "Text": " your application accepts, well then it becomes much harder for an attacker to generate a"
    },
    {
      "Time_Start": 2028.28,
      "Time_End": 2034.28,
      "Text": " certificate, like an SSL certificate, under that authority. So it would have to be, let's say"
    },
    {
      "Time_Start": 2034.28,
      "Time_End": 2040.28,
      "Text": " you're using your own CA, yes, that can definitely protect it as long as an attacker can't"
    },
    {
      "Time_Start": 2058.66,
      "Time_End": 2063.46,
      "Text": " generate a certificate under that CA. But if it's something like you use Digi cert or"
    },
    {
      "Time_Start": 2063.48,
      "Time_End": 2067.98,
      "Text": " something, some specific trusted authority that an attacker could be able to access or"
    },
    {
      "Time_Start": 2067.98,
      "Time_End": 2074.0,
      "Text": " generate certificates under, then it doesn't help much in that context. If there's any other"
    },
    {
      "Time_Start": 2074.0,
      "Time_End": 2080.0,
      "Text": " questions, feel free to come up to the stage and I'd love to discuss the issues with you."
    }
  ]
}