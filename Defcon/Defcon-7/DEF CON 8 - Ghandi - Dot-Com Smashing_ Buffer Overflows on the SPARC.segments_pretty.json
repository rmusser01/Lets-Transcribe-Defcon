{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 23.76,
      "Text": "This text was transcribed using whisper model: large-v2\n\n I'm going to try and focus on this on doing overflows on other architectures, most notably"
    },
    {
      "Time_Start": 23.76,
      "Time_End": 26.32,
      "Text": " the Spark."
    },
    {
      "Time_Start": 26.32,
      "Time_End": 30.32,
      "Text": " The Spark, for those who are unfamiliar, or probably have just heard of them, is, oh,"
    },
    {
      "Time_Start": 30.32,
      "Time_End": 35.84,
      "Text": " well this is what I'm going to talk about, sorry, I'm getting out of order, I do a crash"
    },
    {
      "Time_Start": 35.84,
      "Time_End": 41.72,
      "Text": " course on the Spark and Spark assembly, just because I'm going to focus a lot on writing"
    },
    {
      "Time_Start": 41.72,
      "Time_End": 48.32,
      "Text": " the shellcode and the payload, because that's what differs the most between Intel and Spark,"
    },
    {
      "Time_Start": 48.32,
      "Time_End": 53.56,
      "Text": " and a lot of the techniques that was sort of talked about, about how to deliver the"
    },
    {
      "Time_Start": 53.64,
      "Time_End": 58.760000000000005,
      "Text": " shellcode equally applies here. There are some little nuances that will make it different,"
    },
    {
      "Time_Start": 58.760000000000005,
      "Time_End": 65.0,
      "Text": " but as a general conceptual overview, it's the same. The stack is much funkier on the"
    },
    {
      "Time_Start": 65.0,
      "Time_End": 70.48,
      "Text": " Spark, and I'll make sure I cover that. I'll cover some of the tools that I'm using to"
    },
    {
      "Time_Start": 70.48,
      "Time_End": 75.96000000000001,
      "Text": " develop the shellcode and its examples. I'll be doing everything on a Solaris box, this"
    },
    {
      "Time_Start": 75.96000000000001,
      "Time_End": 81.44,
      "Text": " one right here, and Solaris is so nice to come with. A wonderful debugger, ADB, is an"
    },
    {
      "Time_Start": 81.84,
      "Time_End": 86.48,
      "Text": " assembly language level debugger, so you can step through, look at the registers, look"
    },
    {
      "Time_Start": 86.48,
      "Time_End": 91.84,
      "Text": " at, you know, patch binaries, you can patch values in memory, and do things a lot easier"
    },
    {
      "Time_Start": 91.84,
      "Time_End": 98.84,
      "Text": " than you can with GDB. And I will speak up, as everyone is motioning towards me to do."
    },
    {
      "Time_Start": 99.03999999999999,
      "Time_End": 103.88,
      "Text": " Then I'll discuss exactly what happens on an overflow, and start discussing shellcode"
    },
    {
      "Time_Start": 103.88,
      "Time_End": 108.2,
      "Text": " and some methods of delivery. And I'll be giving some examples, too, because I like"
    },
    {
      "Time_Start": 108.2,
      "Time_End": 115.2,
      "Text": " doing that. Okay. Spark. Stands for Scalable Processor Architecture, created by Sun in"
    },
    {
      "Time_Start": 116.60000000000001,
      "Time_End": 120.92,
      "Text": " the early 80s. It was based on the RISC designs out of UC Berkeley, and basically the whole"
    },
    {
      "Time_Start": 120.92,
      "Time_End": 126.08,
      "Text": " philosophy was make the chip as simple as possible so it's blazing fast. And part of"
    },
    {
      "Time_Start": 126.08,
      "Time_End": 131.68,
      "Text": " what this is is a 32-bit wide path. Everything in Spark is really pretty, because every instruction"
    },
    {
      "Time_Start": 131.68,
      "Time_End": 138.16,
      "Text": " is 32 bits wide. Your shellcode is nice and square. It's really fun. It makes things just"
    },
    {
      "Time_Start": 138.32,
      "Time_End": 143.52,
      "Text": " typically easier for calculating the size of your shellcode and calculating jump addresses"
    },
    {
      "Time_Start": 143.52,
      "Time_End": 148.68,
      "Text": " and stuff like that. It's a pipelined architecture, which will, you know, I just had to mention,"
    },
    {
      "Time_Start": 148.68,
      "Time_End": 153.92,
      "Text": " because it will get you in some places. Every clock cycle, it basically executes one and"
    },
    {
      "Time_Start": 153.92,
      "Time_End": 157.84,
      "Text": " a half-ish instructions, where it basically prepares the second instruction. So you have"
    },
    {
      "Time_Start": 157.84,
      "Time_End": 162.24,
      "Text": " to watch out when you're branching that when you branch, jump to another location in code,"
    },
    {
      "Time_Start": 162.24,
      "Time_End": 167.51999999999998,
      "Text": " you will execute the statement after the branch. So just keep that in mind when you're writing"
    },
    {
      "Time_Start": 167.52,
      "Time_End": 174.20000000000002,
      "Text": " your stuff. Another thing to speed this up is the load store architecture. All logical"
    },
    {
      "Time_Start": 174.20000000000002,
      "Time_End": 179.44,
      "Text": " and arithmetic instructions only operate on the registers. You can't just increment something"
    },
    {
      "Time_Start": 179.44,
      "Time_End": 185.66000000000003,
      "Text": " in memory, because that would involve making the chip smarter and slower. And the one thing"
    },
    {
      "Time_Start": 185.66000000000003,
      "Time_End": 190.12,
      "Text": " unique to the Spark is this wacky invention called register windows, which I will cover"
    },
    {
      "Time_Start": 190.12,
      "Time_End": 197.12,
      "Text": " in great depth, because it's kind of crazy. Memory access, basically it's relatively simple."
    },
    {
      "Time_Start": 197.84,
      "Time_End": 201.04000000000002,
      "Text": " The only instructions that can access memory are load and store, and that whole family"
    },
    {
      "Time_Start": 201.04000000000002,
      "Time_End": 207.88,
      "Text": " of instructions, load by byte, load by half word, so on and so on. And all memory access"
    },
    {
      "Time_Start": 207.88,
      "Time_End": 214.60000000000002,
      "Text": " is register indirect, meaning that you have to write something in the value contained"
    },
    {
      "Time_Start": 214.60000000000002,
      "Time_End": 218.76000000000002,
      "Text": " in a register, whereas each register acts like a pointer, basically, as they would in"
    },
    {
      "Time_Start": 218.76000000000002,
      "Time_End": 225.76000000000002,
      "Text": " C. So it's, you know, this chip was actually written for C compilers, so it does, if you"
    },
    {
      "Time_Start": 226.0,
      "Time_End": 232.76,
      "Text": " think in C, you, the Spark will be very nice to you. Yeah, all instructions are one word,"
    },
    {
      "Time_Start": 232.76,
      "Time_End": 239.39999999999998,
      "Text": " very nice. The registers, RISC chips always have tons of registers, which make things"
    },
    {
      "Time_Start": 239.39999999999998,
      "Time_End": 245.32,
      "Text": " really easy. At each given point in time, you have access to 32 registers. The chip"
    },
    {
      "Time_Start": 245.32,
      "Time_End": 249.48,
      "Text": " may actually have more registers than that, more general purpose integer registers, but"
    },
    {
      "Time_Start": 249.48,
      "Time_End": 254.39999999999998,
      "Text": " you can only see 32 of them at a time because of the register windows, which I'll talk about."
    },
    {
      "Time_Start": 254.4,
      "Time_End": 259.2,
      "Text": " You always have the global registers, you have eight of them, that are accessible across"
    },
    {
      "Time_Start": 259.2,
      "Time_End": 264.76,
      "Text": " every function. You have the output registers, which you load up the arguments to a function"
    },
    {
      "Time_Start": 264.76,
      "Time_End": 269.92,
      "Text": " to be calling. You have the local registers, which are local to your subroutine. The inputs,"
    },
    {
      "Time_Start": 269.92,
      "Time_End": 278.04,
      "Text": " which are the, your caller's output registers. Things to note, the output register 6 is the"
    },
    {
      "Time_Start": 278.04,
      "Time_End": 284.72,
      "Text": " stack pointer. That points to the bottom of your stack, bottom being the lowest memory"
    },
    {
      "Time_Start": 284.72,
      "Time_End": 291.24,
      "Text": " address. The input 6 is the frame pointer, which is your caller's stack pointer, and"
    },
    {
      "Time_Start": 291.24,
      "Time_End": 300.92,
      "Text": " also it points to the top of your stack space. How register windows work is it's a circular"
    },
    {
      "Time_Start": 300.92,
      "Time_End": 308.40000000000003,
      "Text": " stack of 16 registers. The inputs and, or the outputs and the local, which are rotated"
    },
    {
      "Time_Start": 308.40000000000003,
      "Time_End": 313.04,
      "Text": " among functions so you don't have to worry about pushing arguments onto the stack or"
    },
    {
      "Time_Start": 313.04,
      "Time_End": 318.20000000000005,
      "Text": " so on, and to speed up function calls because it was written for C and that's what you do"
    },
    {
      "Time_Start": 318.20000000000005,
      "Time_End": 325.08000000000004,
      "Text": " all the time. The caller's output registers become the input registers in the next function,"
    },
    {
      "Time_Start": 325.08000000000004,
      "Time_End": 328.76,
      "Text": " and these are all handled by the save and restore instructions. The save and restore"
    },
    {
      "Time_Start": 329.24,
      "Time_End": 333.48,
      "Text": " instructions allocate your new register set and they also allocate the stack on the space,"
    },
    {
      "Time_Start": 333.48,
      "Time_End": 339.08,
      "Text": " or the space on the stack, which we will, we have to get the subroutine calling conventions."
    },
    {
      "Time_Start": 339.08,
      "Time_End": 344.76,
      "Text": " Basically to call a subroutine, very simple, you just place the arguments in the output"
    },
    {
      "Time_Start": 344.76,
      "Time_End": 349.56,
      "Text": " registers, use the call instruction to actually jump to the location in memory containing"
    },
    {
      "Time_Start": 349.56,
      "Time_End": 354.88,
      "Text": " the code for the function. The callee uses the save instruction to allocate a register"
    },
    {
      "Time_Start": 354.88,
      "Time_End": 362.64,
      "Text": " window, and it will also allocate their stack frame, and with that they calculate the minimum"
    },
    {
      "Time_Start": 362.64,
      "Time_End": 367.56,
      "Text": " space they need for the stack in addition to anything they need for local variables."
    },
    {
      "Time_Start": 367.56,
      "Time_End": 374.08,
      "Text": " That's all allocated in one instruction. Interesting thing to note is that when you are allocating"
    },
    {
      "Time_Start": 374.08,
      "Time_End": 377.96,
      "Text": " space on the stack for the register window, they're not actually written there. They're"
    },
    {
      "Time_Start": 377.96,
      "Time_End": 383.48,
      "Text": " only written there when the system runs out of register windows, and when that happens,"
    },
    {
      "Time_Start": 383.48,
      "Time_End": 388.92,
      "Text": " a trap is called that signals the operating system that it needs to flush some of these"
    },
    {
      "Time_Start": 388.92,
      "Time_End": 392.84000000000003,
      "Text": " registers out to the memory stack, and so basically what you're doing is you're saying,"
    },
    {
      "Time_Start": 392.84000000000003,
      "Time_End": 397.16,
      "Text": " when you need to dump them, dump them here. So you're not actually guaranteed to have"
    },
    {
      "Time_Start": 397.16,
      "Time_End": 402.52000000000004,
      "Text": " them written there, which is kind of difficult because the point of overflowing the buffer"
    },
    {
      "Time_Start": 402.52000000000004,
      "Time_End": 407.52000000000004,
      "Text": " is to override the return address, but if the return address is in a register, you have"
    },
    {
      "Time_Start": 407.64,
      "Time_End": 414.64,
      "Text": " complications. And the callee does its thing, and at the end it does a ret, which is return"
    },
    {
      "Time_Start": 415.79999999999995,
      "Time_End": 422.79999999999995,
      "Text": " to the caller, which just basically jumps to the value stored in the input 7 register"
    },
    {
      "Time_Start": 423.59999999999997,
      "Time_End": 428.79999999999995,
      "Text": " plus 8, because the 8 is added because of the register, the branch delay slot that when"
    },
    {
      "Time_Start": 428.79999999999995,
      "Time_End": 432.15999999999997,
      "Text": " it's called, it executes that instruction and the next instruction, so it has to go"
    },
    {
      "Time_Start": 432.28000000000003,
      "Time_End": 435.72,
      "Text": " 8 back."
    },
    {
      "Time_Start": 435.72,
      "Time_End": 442.72,
      "Text": " Simple example. We have our main, just we'll call the function foo, and we'll set the output"
    },
    {
      "Time_Start": 443.32000000000005,
      "Time_End": 449.6,
      "Text": " register 0 to dead beef. This is executed because it is in the branch delay slot. Control"
    },
    {
      "Time_Start": 449.6,
      "Time_End": 454.92,
      "Text": " transfers over to foo, which saves. The save instruction is interesting because the first"
    },
    {
      "Time_Start": 454.92,
      "Time_End": 460.64000000000004,
      "Text": " argument, oh, one thing to note about Spark assembly is the destination is always on the"
    },
    {
      "Time_Start": 460.8,
      "Time_End": 467.59999999999997,
      "Text": " right, so it was save starting at the original stack pointer and decrement the stack pointer"
    },
    {
      "Time_Start": 467.59999999999997,
      "Time_End": 474.15999999999997,
      "Text": " by 96 bytes, which is the minimum stack frame needed to dump the registers, and store that"
    },
    {
      "Time_Start": 474.15999999999997,
      "Time_End": 480.24,
      "Text": " value as the new stack pointer, and in between those is when the register window is rotated."
    },
    {
      "Time_Start": 480.24,
      "Time_End": 487.24,
      "Text": " So the value of the stack pointer, the first operand is now in the frame pointer register."
    },
    {
      "Time_Start": 488.24,
      "Time_End": 495.24,
      "Text": " Then it just loads the value stored at the memory address, stored in register input 0,"
    },
    {
      "Time_Start": 497.52,
      "Time_End": 503.08,
      "Text": " and puts that value in register local 0, adds 42 to it, storing the result in register local"
    },
    {
      "Time_Start": 503.08,
      "Time_End": 510.08,
      "Text": " 1, and similarly stores the result back in dead beef. Then it returns, and returns to"
    },
    {
      "Time_Start": 510.36,
      "Time_End": 514.04,
      "Text": " transfer the control back, and because of the branch delay slot, the restore flips the"
    },
    {
      "Time_Start": 514.0799999999999,
      "Time_End": 520.3199999999999,
      "Text": " register window back and deallocates the stack, so when transfer is controlled back, the caller"
    },
    {
      "Time_Start": 520.3199999999999,
      "Time_End": 525.76,
      "Text": " thinks the world is right again. I want to define traps for you. These are typically"
    },
    {
      "Time_Start": 525.76,
      "Time_End": 531.0799999999999,
      "Text": " called interrupts in other operating systems and architectures. They are transfers of control"
    },
    {
      "Time_Start": 531.0799999999999,
      "Time_End": 536.4399999999999,
      "Text": " to supervisor software, meaning it's a request from the application or from other supervisor"
    },
    {
      "Time_Start": 536.4399999999999,
      "Time_End": 543.4399999999999,
      "Text": " code or from the actual hardware for the operating system to get up and do something."
    },
    {
      "Time_Start": 544.48,
      "Time_End": 551.48,
      "Text": " These are handled for window overflow and underflow conditions where the operating system"
    },
    {
      "Time_Start": 552.12,
      "Time_End": 558.16,
      "Text": " has to dump them to the memory stack or restore them. The question is, why do we care?"
    },
    {
      "Time_Start": 558.16,
      "Time_End": 563.4399999999999,
      "Text": " System calls. If you're familiar with Unix kernels, they are all based upon having tons"
    },
    {
      "Time_Start": 563.4399999999999,
      "Time_End": 569.7199999999999,
      "Text": " of system calls that will do everything for you. These are all in the man section, the"
    },
    {
      "Time_Start": 569.72,
      "Time_End": 575.0,
      "Text": " manual pages, section 2, open, close, exec, fork, all these fun things are all there"
    },
    {
      "Time_Start": 575.0,
      "Time_End": 581.44,
      "Text": " for you. To make a system call, all you do is look up in syscall.h the system call number"
    },
    {
      "Time_Start": 581.44,
      "Time_End": 587.5600000000001,
      "Text": " of the system call you want to execute, throw that in global 1, and execute trap 8. A simple"
    },
    {
      "Time_Start": 587.5600000000001,
      "Time_End": 594.5600000000001,
      "Text": " example here. We are going to set the output register to 0, because global 0 is basically"
    },
    {
      "Time_Start": 595.5600000000001,
      "Time_End": 602.0400000000001,
      "Text": " the dev null register. It's hard coded 0. 23 is the index of the set UID system call."
    },
    {
      "Time_Start": 602.0400000000001,
      "Time_End": 609.0400000000001,
      "Text": " Move that to global 1, do the trap. Notice there is no branch delay slot after a trap."
    },
    {
      "Time_Start": 610.08,
      "Time_End": 617.08,
      "Text": " It's only on branches and calls. Now just execute set UID 0, which we'll see why we"
    },
    {
      "Time_Start": 617.08,
      "Time_End": 624.08,
      "Text": " need to do that soon. The stack. Like other architectures, the stack goes downward, and"
    },
    {
      "Time_Start": 625.32,
      "Time_End": 631.32,
      "Text": " it reserves the space for the window in case of overflow or underflow. And basically, in"
    },
    {
      "Time_Start": 631.32,
      "Time_End": 638.32,
      "Text": " a well behaved convention obeying functions, you, all automatic variables are referenced"
    },
    {
      "Time_Start": 639.32,
      "Time_End": 644.2800000000001,
      "Text": " by negative offsets from the frame pointer, because as my little art in the next slide"
    },
    {
      "Time_Start": 644.2800000000001,
      "Time_End": 650.1200000000001,
      "Text": " will show you, the first part of the stack in the high memory address is space, if any,"
    },
    {
      "Time_Start": 650.12,
      "Time_End": 654.88,
      "Text": " for automatic variables, so you just index them that way, and then the bottom of the"
    },
    {
      "Time_Start": 654.88,
      "Time_End": 660.72,
      "Text": " stack is stuff for the register windows. But you actually don't need to reference those,"
    },
    {
      "Time_Start": 660.72,
      "Time_End": 666.16,
      "Text": " because nothing is guaranteed to be there, so why would you want to do that? And here"
    },
    {
      "Time_Start": 666.16,
      "Time_End": 671.48,
      "Text": " is a basically a struct representation of the minimum stack frame. And they do some"
    },
    {
      "Time_Start": 671.48,
      "Time_End": 678.48,
      "Text": " interesting stuff here. You have 8 words allotted for the local registers, and then you have"
    },
    {
      "Time_Start": 680.12,
      "Time_End": 684.84,
      "Text": " 6 for the input registers, and notice these two are also the input registers. We have"
    },
    {
      "Time_Start": 684.84,
      "Time_End": 691.84,
      "Text": " the frame pointer and the saved program counter, which is where we'll be jumping back to, so"
    },
    {
      "Time_Start": 692.5600000000001,
      "Time_End": 697.88,
      "Text": " basically you have the 8 locals and those next 3 lines form the 8 inputs, which means"
    },
    {
      "Time_Start": 697.88,
      "Time_End": 704.88,
      "Text": " you can only pass 6 arguments through the registers to a function. Then we have the"
    },
    {
      "Time_Start": 705.88,
      "Time_End": 710.88,
      "Text": " structure return address for returning compound values. Made a slide to throw that in there"
    },
    {
      "Time_Start": 710.88,
      "Time_End": 715.4,
      "Text": " for fun. So you could store a pointer on the stack instead of putting it in a register,"
    },
    {
      "Time_Start": 715.4,
      "Time_End": 722.24,
      "Text": " I'm not sure why. And then we have the argument dump area, which is so that the function being"
    },
    {
      "Time_Start": 722.24,
      "Time_End": 729.24,
      "Text": " called, if it so chooses, can dump its arguments that it got on its input registers onto its"
    },
    {
      "Time_Start": 729.76,
      "Time_End": 735.5600000000001,
      "Text": " stack. Okay. If you need more registers, you can do that and get them all. And then we"
    },
    {
      "Time_Start": 735.5600000000001,
      "Time_End": 742.5600000000001,
      "Text": " have the arg X area. This is the argument extension. For more than 6 arguments to a"
    },
    {
      "Time_Start": 742.6,
      "Time_End": 749.6,
      "Text": " function, this stack, this space just kind of grows as far as needed to place the arguments"
    },
    {
      "Time_Start": 750.24,
      "Time_End": 756.8,
      "Text": " there. This is allotted with the caller's save instruction, which will put those in"
    },
    {
      "Time_Start": 756.8000000000001,
      "Time_End": 761.8000000000001,
      "Text": " there. They load them in. The function will know to reference them as negative to the"
    },
    {
      "Time_Start": 761.8000000000001,
      "Time_End": 768.8000000000001,
      "Text": " frame pointer, as yes. And that's how that works. We won't really be using that, but"
    },
    {
      "Time_Start": 770.0400000000001,
      "Time_End": 775.36,
      "Text": " here's a nice ASCII art depiction of the stack. The stack goes this way, and I have it going"
    },
    {
      "Time_Start": 775.36,
      "Time_End": 780.6,
      "Text": " left to right just so you can read it and you can see the string buffers as they are."
    },
    {
      "Time_Start": 780.6,
      "Time_End": 785.44,
      "Text": " Locals, inputs, the structure, return address, the instruction pointer, the argument dump"
    },
    {
      "Time_Start": 785.6400000000001,
      "Time_End": 792.6400000000001,
      "Text": " area, 24 bytes. I have the sizes used by them up there. The argument dump area is just that"
    },
    {
      "Time_Start": 793.44,
      "Time_End": 797.4000000000001,
      "Text": " one byte. It's also sometimes referred to as the hidden word, which is used to make"
    },
    {
      "Time_Start": 797.4000000000001,
      "Time_End": 804.24,
      "Text": " sure that the stack is double word aligned. The stack and the saved program counter must"
    },
    {
      "Time_Start": 804.24,
      "Time_End": 809.24,
      "Text": " always be double word aligned, or else your chip will get very angry with you. And we're"
    },
    {
      "Time_Start": 809.24,
      "Time_End": 813.32,
      "Text": " going to make it very angry, but not so angry that it barfs. And then automatic variables"
    },
    {
      "Time_Start": 813.32,
      "Time_End": 818.6800000000001,
      "Text": " are stored here. Like right here in my example, I have a string pointer called buff of indeterminate"
    },
    {
      "Time_Start": 818.6800000000001,
      "Time_End": 823.6400000000001,
      "Text": " size. It doesn't really matter. And then we have the frame pointer, which is the boundary"
    },
    {
      "Time_Start": 823.6400000000001,
      "Time_End": 829.6800000000001,
      "Text": " between our next or our caller's stack frame. There are his locals, his inputs, and my little"
    },
    {
      "Time_Start": 829.6800000000001,
      "Time_End": 834.1600000000001,
      "Text": " asterisks. That's his saved program counter. That's our target. That's what we need to"
    },
    {
      "Time_Start": 834.1600000000001,
      "Time_End": 839.72,
      "Text": " hit. And it's pretty easy to see that if the buffer grows outside of its boundaries, you"
    },
    {
      "Time_Start": 839.72,
      "Time_End": 846.72,
      "Text": " just overwrite his registers and just basically take him over, which actually presents the"
    },
    {
      "Time_Start": 847.6,
      "Time_End": 853.28,
      "Text": " interesting thing is you're not overflowing. You're not overflowing and taking over the"
    },
    {
      "Time_Start": 853.28,
      "Time_End": 859.9200000000001,
      "Text": " function that with the fixed length buffer in it. You are overflowing and taking control"
    },
    {
      "Time_Start": 859.9200000000001,
      "Time_End": 864.72,
      "Text": " from his caller, which is very interesting because sometimes your caller can call the"
    },
    {
      "Time_Start": 864.72,
      "Time_End": 869.96,
      "Text": " overflowable function, return, call another function, which will overwrite your wonderful"
    },
    {
      "Time_Start": 869.96,
      "Time_End": 876.52,
      "Text": " stack frame and shell code, and then basically you're screwed. But, of course, you just attended"
    },
    {
      "Time_Start": 876.52,
      "Time_End": 879.96,
      "Text": " the Greg Kogelman's talk on how to do cool things with the stack and where you can put"
    },
    {
      "Time_Start": 879.96,
      "Time_End": 885.72,
      "Text": " the code. And so something like that should not be a problem. But this is what's going"
    },
    {
      "Time_Start": 885.72,
      "Time_End": 891.4,
      "Text": " to happen when we are overflowing the buffer. Just I'm just going to trace through over"
    },
    {
      "Time_Start": 891.4,
      "Time_End": 896.8,
      "Text": " how the register windows rotate the registers and how things change. Obviously the previous"
    },
    {
      "Time_Start": 896.8,
      "Time_End": 903.3199999999999,
      "Text": " stack frames saved program counter is overwritten, as is all his other registers. The function"
    },
    {
      "Time_Start": 903.3199999999999,
      "Time_End": 910.3199999999999,
      "Text": " returns his, let's see, his frame pointer becomes the target address, and his input"
    },
    {
      "Time_Start": 911.9599999999999,
      "Time_End": 916.52,
      "Text": " seven register becomes the target address also. And the stack pointer is still valid."
    },
    {
      "Time_Start": 916.52,
      "Time_End": 921.8,
      "Text": " The stack pointer will still be the pointer to his stack, which has not been totally free"
    },
    {
      "Time_Start": 921.8,
      "Time_End": 928.8,
      "Text": " wide at this point. All his values that he assumed to be safe have just been totally"
    },
    {
      "Time_Start": 929.16,
      "Time_End": 935.4399999999999,
      "Text": " messed up, so he just freaks out, hopefully getting an error condition immediately and"
    },
    {
      "Time_Start": 935.4399999999999,
      "Time_End": 942.4399999999999,
      "Text": " returning. And if he does, he tries to jump to the input seven plus eight, our target"
    },
    {
      "Time_Start": 943.36,
      "Time_End": 950.36,
      "Text": " address, plus eight bytes, and that is where we would take over control. This is your stack"
    },
    {
      "Time_Start": 950.84,
      "Time_End": 957.84,
      "Text": " on drugs. Basically we have all these registers or these areas on the stack are fine, and"
    },
    {
      "Time_Start": 958.0,
      "Time_End": 962.8000000000001,
      "Text": " then our buff, we just overflow and write our target address off into the horizon as"
    },
    {
      "Time_Start": 962.8000000000001,
      "Time_End": 968.08,
      "Text": " far, you can basically write it as far as you want, because nothing is going to behave"
    },
    {
      "Time_Start": 968.2,
      "Time_End": 970.2,
      "Text": " well at this point. Yes?"
    },
    {
      "Time_Start": 970.2,
      "Time_End": 977.2,
      "Text": " Oh, thank you for reminding me. Okay. Basically we are told that we are not guaranteed that"
    },
    {
      "Time_Start": 982.5200000000001,
      "Time_End": 989.5200000000001,
      "Text": " these values will be there, but what happens is basically implementations of the Spark"
    },
    {
      "Time_Start": 989.5200000000001,
      "Time_End": 994.9200000000001,
      "Text": " architecture as an open architecture are allowed to have anywhere from I think eight to 40"
    },
    {
      "Time_Start": 994.9200000000001,
      "Time_End": 999.1600000000001,
      "Text": " register windows. Luckily those register windows are always filled even like in the"
    },
    {
      "Time_Start": 999.1600000000001,
      "Time_End": 1004.44,
      "Text": " lowest stages of the kernel, so you can basically assume that every time we do a save or restore,"
    },
    {
      "Time_Start": 1004.44,
      "Time_End": 1008.8800000000001,
      "Text": " they will be restored from the stack, or saved to the stack and restored from the stack."
    },
    {
      "Time_Start": 1008.8800000000001,
      "Time_End": 1015.8800000000001,
      "Text": " So that when we, when the overflowed function does a restore, we will assume that it's,"
    },
    {
      "Time_Start": 1016.0400000000001,
      "Time_End": 1020.44,
      "Text": " the registers that it was thought it had in the register window have become, you know,"
    },
    {
      "Time_Start": 1020.6,
      "Time_End": 1027.6000000000001,
      "Text": " written to the stack, and so it restores them from the caller's stack. So basically what"
    },
    {
      "Time_Start": 1028.68,
      "Time_End": 1033.4,
      "Text": " it does is we have our target address written all the way through there, and it just loads"
    },
    {
      "Time_Start": 1033.4,
      "Time_End": 1037.68,
      "Text": " up its registers as it transfers control to the caller, loads up its registers with the"
    },
    {
      "Time_Start": 1037.68,
      "Time_End": 1042.3200000000002,
      "Text": " target address. I will do some examples, and I will show you what this looks like when"
    },
    {
      "Time_Start": 1042.3200000000002,
      "Time_End": 1046.72,
      "Text": " stepping through the program, and you will see all the registers are just totally just"
    },
    {
      "Time_Start": 1046.72,
      "Time_End": 1053.72,
      "Text": " spammed over. One of the very nice tools that Solaris comes with is just the disassembler."
    },
    {
      "Time_Start": 1053.72,
      "Time_End": 1060.64,
      "Text": " Have you ever looked into basically writing the shell code, writing the assembly code,"
    },
    {
      "Time_Start": 1060.64,
      "Time_End": 1065.1200000000001,
      "Text": " and then changing it to the bytes? It's a pain in the butt, but this makes it rather"
    },
    {
      "Time_Start": 1065.1200000000001,
      "Time_End": 1069.24,
      "Text": " easy, especially when you just throw a Perl script on top of it, and it's a nice little"
    },
    {
      "Time_Start": 1069.24,
      "Time_End": 1075.52,
      "Text": " chug, and you have a nice little header file that you can use. There are freeware Spark"
    },
    {
      "Time_Start": 1075.52,
      "Time_End": 1082.52,
      "Text": " disassemblers available. I just found a page about two hours ago off of Linuxassembly.org"
    },
    {
      "Time_Start": 1082.6,
      "Time_End": 1089.6,
      "Text": " has a link to some Spark assembly examples, and on this guy's page, he has his own Spark"
    },
    {
      "Time_Start": 1090.44,
      "Time_End": 1095.0,
      "Text": " disassembler and Spark assembler and a couple others that you could use for Linux and or"
    },
    {
      "Time_Start": 1095.0,
      "Time_End": 1102.0,
      "Text": " BSD, all running on Spark, of course. Excuse me?"
    },
    {
      "Time_Start": 1106.52,
      "Time_End": 1113.52,
      "Text": " Is it free? Oh, very nice. Okay. Well, if I'm sure we can find that, if you want to"
    },
    {
      "Time_Start": 1118.52,
      "Time_End": 1125.52,
      "Text": " give me the URL, I can throw it on here for people. Oh, I forgot who already, but someone"
    },
    {
      "Time_Start": 1126.68,
      "Time_End": 1133.68,
      "Text": " has a really good free disassembler. GNU? There's a GNU disassembler?"
    },
    {
      "Time_Start": 1136.52,
      "Time_End": 1143.52,
      "Text": " Oh, wow. I was unaware that they had a disassembler. Well, I have done my research. Okay."
    },
    {
      "Time_Start": 1149.6,
      "Time_End": 1154.72,
      "Text": " And the other tool that we'll be using extensively is the absolute debugger, because this thing"
    },
    {
      "Time_Start": 1154.72,
      "Time_End": 1159.8,
      "Text": " I, correct me if I'm wrong again, I have not seen anything like this for any of the free"
    },
    {
      "Time_Start": 1159.8,
      "Time_End": 1165.72,
      "Text": " operating systems. They tend to use GDB for their kernel debuggers and everything else,"
    },
    {
      "Time_Start": 1165.72,
      "Time_End": 1172.36,
      "Text": " but I have not seen something that is as assembly language as this one is, as assembly level."
    },
    {
      "Time_Start": 1172.36,
      "Time_End": 1176.2,
      "Text": " Rather funky syntax to get used to if you're coming from the world of nice and pretty hand"
    },
    {
      "Time_Start": 1176.2,
      "Time_End": 1181.72,
      "Text": " holding debuggers. Arguments are address, how many iterations to do, and command and"
    },
    {
      "Time_Start": 1181.72,
      "Time_End": 1188.72,
      "Text": " modifiers as you can see. First instruction, it says starting at the address of main in"
    },
    {
      "Time_Start": 1188.76,
      "Time_End": 1193.2,
      "Text": " the object file. The question mark means in the object file. The slash means in the memory"
    },
    {
      "Time_Start": 1193.2,
      "Time_End": 1198.8,
      "Text": " image, whether it be a core file or the actual memory of the running process. What I'm saying"
    },
    {
      "Time_Start": 1198.8,
      "Time_End": 1205.8,
      "Text": " on the first one is dump ten instructions or disassemble ten instructions starting at"
    },
    {
      "Time_Start": 1206.08,
      "Time_End": 1211.18,
      "Text": " main. One of the wonderful idiosyncrasies of this program is everything on this side"
    },
    {
      "Time_Start": 1211.18,
      "Time_End": 1217.76,
      "Text": " of the question mark or slash is in hex. Everything on that side is in decimal. But there are"
    },
    {
      "Time_Start": 1217.76,
      "Time_End": 1222.44,
      "Text": " modifiers you can use to put them either way, but we should all be very fluid with"
    },
    {
      "Time_Start": 1222.44,
      "Time_End": 1228.64,
      "Text": " conversions even though I'm not. The second example, just display the words stored at"
    },
    {
      "Time_Start": 1228.64,
      "Time_End": 1234.92,
      "Text": " code babe. That's not a real address, but I like it. We can also just query individual"
    },
    {
      "Time_Start": 1234.92,
      "Time_End": 1240.56,
      "Text": " registers. Basically have like a pseudo redirection instruction that will say give me the address"
    },
    {
      "Time_Start": 1240.56,
      "Time_End": 1245.0,
      "Text": " of the stack pointer, assign it to the variable X and it will print it out for you. The next"
    },
    {
      "Time_Start": 1245.0,
      "Time_End": 1251.04,
      "Text": " instruction says display 24 words starting at the stack pointer. That will give you the"
    },
    {
      "Time_Start": 1251.04,
      "Time_End": 1256.12,
      "Text": " full minimum stack frame. And then from there, after that point, it will be automatic variables"
    },
    {
      "Time_Start": 1256.12,
      "Time_End": 1261.24,
      "Text": " if any, but every function must have at least those and you can check them out. Here's a"
    },
    {
      "Time_Start": 1261.24,
      "Time_End": 1268.24,
      "Text": " more interesting one. In the address of the frame pointer plus 3C, which I can't remember."
    },
    {
      "Time_Start": 1269.24,
      "Time_End": 1275.92,
      "Text": " I'm on the spot, so I can't do math. That will be the saved program counter. Write the"
    },
    {
      "Time_Start": 1275.92,
      "Time_End": 1281.08,
      "Text": " value dead beef. So then you just write the value, step through and you will see the program"
    },
    {
      "Time_Start": 1281.08,
      "Time_End": 1288.08,
      "Text": " try and jump to it. See the caller try and jump to it when it becomes time. The ADB will"
    },
    {
      "Time_Start": 1288.48,
      "Time_End": 1292.32,
      "Text": " also do interactive debugging. Some simple stuff like this. You don't really \u2011\u2011 it's"
    },
    {
      "Time_Start": 1292.32,
      "Time_End": 1298.8,
      "Text": " not pertinent, but I threw it on there because I needed space. Wow, this is very difficult"
    },
    {
      "Time_Start": 1298.8,
      "Time_End": 1305.8,
      "Text": " to see. This is a contrived session of using ADB to examine what happens when we overflow"
    },
    {
      "Time_Start": 1305.84,
      "Time_End": 1309.1599999999999,
      "Text": " a program. I wrote a simple program called smash me, which I'll show you in a couple"
    },
    {
      "Time_Start": 1309.1599999999999,
      "Time_End": 1315.76,
      "Text": " minutes. Basically just says the fatal flaw, does a stir copy or a stir cat into a fixed"
    },
    {
      "Time_Start": 1315.76,
      "Time_End": 1320.28,
      "Text": " length buffer. And it just takes the argument on the command line, so I'm just saying run"
    },
    {
      "Time_Start": 1320.28,
      "Time_End": 1326.16,
      "Text": " it with this argument, and I said first to set the break \u2011\u2011 there also is no prompt"
    },
    {
      "Time_Start": 1326.16,
      "Time_End": 1332.2,
      "Text": " in ADB, so it's kind of hard to follow along. I said smash colon B means set a break point"
    },
    {
      "Time_Start": 1332.2,
      "Time_End": 1338.6399999999999,
      "Text": " at the smash function, which is I have main and I call smash, which has the overflow."
    },
    {
      "Time_Start": 1338.6399999999999,
      "Time_End": 1345.24,
      "Text": " And then we run it with that argument, stops at the beginning of smash. We're stepping"
    },
    {
      "Time_Start": 1345.24,
      "Time_End": 1352.24,
      "Text": " through, I'll get a stack pointer, and we're going to store the value, go through, we're"
    },
    {
      "Time_Start": 1353.28,
      "Time_End": 1359.0,
      "Text": " just stepping through, watching it. It's going to call, I think right there at the bottom"
    },
    {
      "Time_Start": 1359.0,
      "Time_End": 1366.0,
      "Text": " of your screen is where it calls stir cat. But right now we're going to watch \u2011\u2011 I"
    },
    {
      "Time_Start": 1366.52,
      "Time_End": 1372.8,
      "Text": " can't remember how I do this. Oh, yes. I call stir cat. First I look at our stack pointer"
    },
    {
      "Time_Start": 1372.8,
      "Time_End": 1379.2,
      "Text": " and I look at the frame pointer, our caller stack frame, and then I step over that instruction,"
    },
    {
      "Time_Start": 1379.2,
      "Time_End": 1384.8,
      "Text": " which will call our \u2011\u2011 will call stir cat, and we're going to watch what happens"
    },
    {
      "Time_Start": 1384.8,
      "Time_End": 1391.56,
      "Text": " after that. The colon E means step to the next instruction, but don't follow any jumps"
    },
    {
      "Time_Start": 1391.56,
      "Time_End": 1398.56,
      "Text": " or calls. As you can see, the saved program counter is overwritten, as is his entire stack"
    },
    {
      "Time_Start": 1399.56,
      "Time_End": 1406.56,
      "Text": " frame. He's not happy. And then I basically just step through to the end, and I go right"
    },
    {
      "Time_Start": 1408.96,
      "Time_End": 1415.72,
      "Text": " here to where he returns, and so when he returns, his \u2011\u2011 the stuff store on his stack is"
    },
    {
      "Time_Start": 1415.72,
      "Time_End": 1420.36,
      "Text": " loaded off the stack into registers and then using the restore instruction, it's flipped"
    },
    {
      "Time_Start": 1420.36,
      "Time_End": 1427.36,
      "Text": " over to his caller's local and output registers. And so now we have them all loaded in back"
    },
    {
      "Time_Start": 1428.6,
      "Time_End": 1432.9199999999998,
      "Text": " in control of main, they're all loaded in there, and I'm going to step through the last"
    },
    {
      "Time_Start": 1432.9199999999998,
      "Time_End": 1437.6,
      "Text": " instructions of main where it tries to do a return right here, and it says a bus error"
    },
    {
      "Time_Start": 1437.6,
      "Time_End": 1443.84,
      "Text": " because the address 41414141 is not aligned. You'll get that last way just to see when"
    },
    {
      "Time_Start": 1443.84,
      "Time_End": 1450.84,
      "Text": " you've messed up, quit out of that. I'll run through that again later with a real world"
    },
    {
      "Time_Start": 1450.96,
      "Time_End": 1457.0,
      "Text": " example. I'm going to start talking now about how to write assembler code that we'll use"
    },
    {
      "Time_Start": 1457.04,
      "Time_End": 1462.44,
      "Text": " as mobile code, position independent code, we can just throw in there and it will just"
    },
    {
      "Time_Start": 1462.44,
      "Time_End": 1468.84,
      "Text": " execute on its own behalf and take control of the process. Basically, two ways to write"
    },
    {
      "Time_Start": 1468.84,
      "Time_End": 1473.68,
      "Text": " this is you can \u2011\u2011 using your compiler, you can make a ASM block, which basically"
    },
    {
      "Time_Start": 1473.68,
      "Time_End": 1477.68,
      "Text": " just says this is straight assembly code and you just write it in there, compile the program,"
    },
    {
      "Time_Start": 1477.68,
      "Time_End": 1484.68,
      "Text": " you run it, and if it gives you a shell, you obviously know it's working. And then after"
    },
    {
      "Time_Start": 1484.8400000000001,
      "Time_End": 1489.48,
      "Text": " that I throw the function into a character array and then I cast that array to a function"
    },
    {
      "Time_Start": 1489.48,
      "Time_End": 1495.24,
      "Text": " pointer, execute the function pointer as the final stress test. Here's my first example"
    },
    {
      "Time_Start": 1495.24,
      "Time_End": 1502.24,
      "Text": " of some Spark shell code. This is somewhat brain dead in some ways, but I'll explain."
    },
    {
      "Time_Start": 1502.68,
      "Time_End": 1508.16,
      "Text": " This representation does contain null bytes in it, so it's useless basically, but it's"
    },
    {
      "Time_Start": 1508.16,
      "Time_End": 1515.16,
      "Text": " ordered in a simpleish way. I'll show you how we're going to write it. I think I'm \u2011\u2011"
    },
    {
      "Time_Start": 1515.48,
      "Time_End": 1520.0400000000002,
      "Text": " I write my shell code at first as if it's a well\u2011behaved function, so I allocate in"
    },
    {
      "Time_Start": 1520.0400000000002,
      "Time_End": 1527.0400000000002,
      "Text": " a new register window and I just basically \u2011\u2011 I'm calling exec, so I'm creating the character"
    },
    {
      "Time_Start": 1527.1200000000001,
      "Time_End": 1533.76,
      "Text": " array of the function to execute and I'm creating the arg vector. Throw that in there. I'm just"
    },
    {
      "Time_Start": 1533.76,
      "Time_End": 1538.24,
      "Text": " giving it a null for the environment pointer because, okay, it's a little bit messy, but"
    },
    {
      "Time_Start": 1538.24,
      "Time_End": 1545.24,
      "Text": " it's not a problem. One very handy thing about Spark is that it's big Indian and so you can"
    },
    {
      "Time_Start": 1546.08,
      "Time_End": 1553.08,
      "Text": " write strings in a relatively straightforward way just straight to the stack. One way to"
    },
    {
      "Time_Start": 1553.6,
      "Time_End": 1560.6,
      "Text": " do this is if you're lazy, most of the Unixes will come with the octal dump program and"
    },
    {
      "Time_Start": 1560.6000000000001,
      "Time_End": 1566.7600000000002,
      "Text": " if you just do echo, string, pipe, octal dump, slash X, it will give you a nice hex"
    },
    {
      "Time_Start": 1566.7600000000002,
      "Time_End": 1571.2,
      "Text": " and you basically just chop it into words and start storing them on the stack and you"
    },
    {
      "Time_Start": 1571.2,
      "Time_End": 1577.68,
      "Text": " have a string. I'm sure there are ways to do the cool little jumping thing that will"
    },
    {
      "Time_Start": 1577.68,
      "Time_End": 1582.2,
      "Text": " actually load the address of the string so you can just write it straight, but that's"
    },
    {
      "Time_Start": 1582.2,
      "Time_End": 1589.2,
      "Text": " a little over the top for now. Yeah, and you can basically see I set 59 to the system call"
    },
    {
      "Time_Start": 1590.2,
      "Time_End": 1596.76,
      "Text": " number, execute the system call. This can basically be looked at as a well-behaved function"
    },
    {
      "Time_Start": 1596.76,
      "Time_End": 1603.76,
      "Text": " to just exec a shell. Then I chop it down a little more. It doesn't assume it's a well-behaved"
    },
    {
      "Time_Start": 1606.16,
      "Time_End": 1610.28,
      "Text": " function. I am lying on that second line. Ignore that. Basically I chop out the save"
    },
    {
      "Time_Start": 1610.28,
      "Time_End": 1616.96,
      "Text": " and restores and I just start using the current stack pointer because in the situation where"
    },
    {
      "Time_Start": 1616.96,
      "Time_End": 1622.68,
      "Text": " the overflow occurs, assuming the well-behaved function assumes you have valid stack pointers"
    },
    {
      "Time_Start": 1622.68,
      "Time_End": 1626.72,
      "Text": " and frame pointers. You can get in situations where your stack pointer will be pointing"
    },
    {
      "Time_Start": 1626.72,
      "Time_End": 1632.8,
      "Text": " to right behind your code and as you're storing memory, you'll be chasing your code as your"
    },
    {
      "Time_Start": 1632.8,
      "Time_End": 1639.8,
      "Text": " code executes and you're overwriting behind it and you don't want to be there. So this"
    },
    {
      "Time_Start": 1639.88,
      "Time_End": 1644.8,
      "Text": " kind of, this code also will not work because it assumes that the frame pointer is valid,"
    },
    {
      "Time_Start": 1644.84,
      "Time_End": 1649.44,
      "Text": " as I discussed before, the frame pointer will be the target address and so you're stepping"
    },
    {
      "Time_Start": 1649.44,
      "Time_End": 1655.3999999999999,
      "Text": " on your toes here. But this is another example of just chopping things down. You know, you"
    },
    {
      "Time_Start": 1655.3999999999999,
      "Time_End": 1662.3999999999999,
      "Text": " can see I set, here I'll explain the string more. I set the two words and two following"
    },
    {
      "Time_Start": 1663.1599999999999,
      "Time_End": 1668.2,
      "Text": " registers to a stored double word instruction starting at the address of the frame pointer"
    },
    {
      "Time_Start": 1668.2,
      "Time_End": 1674.0,
      "Text": " minus 16 so it writes the full eight byte value down. And I basically am constructing"
    },
    {
      "Time_Start": 1674.0,
      "Time_End": 1681.0,
      "Text": " in memory the string followed by the, followed by a null so that I can use it for both the"
    },
    {
      "Time_Start": 1682.44,
      "Time_End": 1689.44,
      "Text": " name of the program to execute and I build a pointer to that array of character pointers"
    },
    {
      "Time_Start": 1689.96,
      "Time_End": 1695.96,
      "Text": " to use as the arg vector. If you've seen Aleph Juan's code in the, especially the stack for"
    },
    {
      "Time_Start": 1696.0,
      "Time_End": 1703.0,
      "Text": " fun and profit, he does this also. Very easy and straightforward way to do it. Here is"
    },
    {
      "Time_Start": 1703.88,
      "Time_End": 1708.3600000000001,
      "Text": " my even better shell code. I'm not saying it's really great, but in writing this, there's"
    },
    {
      "Time_Start": 1708.3600000000001,
      "Time_End": 1715.0,
      "Text": " an interesting caveat that is not addressed in smashing the stack for fun and profit."
    },
    {
      "Time_Start": 1715.0,
      "Time_End": 1722.0,
      "Text": " Under system v systems, the shell, the born shell slash bin sh, when passed an effective"
    },
    {
      "Time_Start": 1722.48,
      "Time_End": 1729.48,
      "Text": " UID of less than 100 will discard it so that effective UID is triggered when the program"
    },
    {
      "Time_Start": 1730.76,
      "Time_End": 1735.6,
      "Text": " is, has the SUID bit set which means it keeps your real user ID saying this is who you really"
    },
    {
      "Time_Start": 1735.6,
      "Time_End": 1740.72,
      "Text": " are but effectively your root. And then it calls the shell and the shell discards the"
    },
    {
      "Time_Start": 1740.72,
      "Time_End": 1745.72,
      "Text": " effective UID and so basically you, you know, you found that you've exploited a SUID program"
    },
    {
      "Time_Start": 1745.76,
      "Time_End": 1752.76,
      "Text": " and you still have your own privileges and you're not very pleased. Yes?"
    },
    {
      "Time_Start": 1755.6000000000001,
      "Time_End": 1762.6000000000001,
      "Text": " The second one, it contains a no byte in this, oh, thank you. Okay. The set is a synthetic"
    },
    {
      "Time_Start": 1764.1200000000001,
      "Time_End": 1769.76,
      "Text": " instruction meaning the assembler basically expands it for you. And the set, because everything"
    },
    {
      "Time_Start": 1769.76,
      "Time_End": 1775.2,
      "Text": " is 32 bits, how can you write a 32 bit value in the instruction? Because it splits it into"
    },
    {
      "Time_Start": 1775.2,
      "Time_End": 1780.52,
      "Text": " two. It first writes the, uses the set high instruction to write the first, the highest"
    },
    {
      "Time_Start": 1780.52,
      "Time_End": 1786.6,
      "Text": " order 13 bits to the register and then does an or with the lower 13 bits, with the lower"
    },
    {
      "Time_Start": 1786.6,
      "Time_End": 1791.08,
      "Text": " 8 bits to complete the whole value. And we'll see when I disassemble the shell code how"
    },
    {
      "Time_Start": 1791.08,
      "Time_End": 1797.44,
      "Text": " it's changed over and I'm just lazy so I just do the set because it's easier to see the"
    },
    {
      "Time_Start": 1797.44,
      "Time_End": 1804.44,
      "Text": " string there instead of two words. But, yeah, that will eliminate the no byte. The no byte"
    },
    {
      "Time_Start": 1806.64,
      "Time_End": 1813.64,
      "Text": " will still be in the set, in the or, but because of the way that the op code for or is aligned"
    },
    {
      "Time_Start": 1813.76,
      "Time_End": 1819.1200000000001,
      "Text": " with the bits, it will not be on the correct boundaries to be a, in fact, no byte. It will"
    },
    {
      "Time_Start": 1819.1200000000001,
      "Time_End": 1824.6000000000001,
      "Text": " be spread across. Don't have a diagram of that, but you can take my word for it or call"
    },
    {
      "Time_Start": 1824.6000000000001,
      "Time_End": 1830.72,
      "Text": " me a liar and chase me out to the parking lot. It's your choice. Let's see, nothing"
    },
    {
      "Time_Start": 1830.72,
      "Time_End": 1837.72,
      "Text": " else really changed here. You'll notice that I do not trust the frame pointer anymore because"
    },
    {
      "Time_Start": 1837.8000000000002,
      "Time_End": 1841.4,
      "Text": " I've stepped through with the assembly debugger and I'm like, wait, why am I doing that? That"
    },
    {
      "Time_Start": 1841.4,
      "Time_End": 1847.0400000000002,
      "Text": " is just whack. And so everything relative to the stack pointer, I waste four bytes before"
    },
    {
      "Time_Start": 1847.0400000000002,
      "Time_End": 1851.5200000000002,
      "Text": " the stack pointer because storing straight to the stack pointer introduces a no byte."
    },
    {
      "Time_Start": 1851.56,
      "Time_End": 1856.68,
      "Text": " You'll notice when I'm trying to set a register to zero, I can't use the straightforward instruction"
    },
    {
      "Time_Start": 1856.68,
      "Time_End": 1861.92,
      "Text": " by just setting to zero or moving the global register over because that introduces a no"
    },
    {
      "Time_Start": 1861.92,
      "Time_End": 1868.0,
      "Text": " byte so you just do something like, you know, XORs or there's a thousand different creative"
    },
    {
      "Time_Start": 1868.0,
      "Time_End": 1875.0,
      "Text": " ways you can do that just to feel fun. Let's talk a little bit about the delivery, but"
    },
    {
      "Time_Start": 1875.84,
      "Time_End": 1882.04,
      "Text": " not that much because it is basically treated better than I could by Greg. Same on other"
    },
    {
      "Time_Start": 1882.04,
      "Time_End": 1888.92,
      "Text": " architectures either. You need to do the no ops sled and then the shell code and then"
    },
    {
      "Time_Start": 1888.92,
      "Time_End": 1893.96,
      "Text": " write the jump address off into infinity and let it jump back, which is \u2011\u2011 has the"
    },
    {
      "Time_Start": 1893.96,
      "Time_End": 1899.04,
      "Text": " problem of if the caller of the overflowable function calls another function, you're not"
    },
    {
      "Time_Start": 1899.04,
      "Time_End": 1904.8,
      "Text": " necessarily toast, you're just basically dodging bullets. Or you can just write the"
    },
    {
      "Time_Start": 1904.8,
      "Time_End": 1910.44,
      "Text": " jump address to overwrite the saved program counter and then put the no ops after it and"
    },
    {
      "Time_Start": 1910.44,
      "Time_End": 1914.6399999999999,
      "Text": " the code after it. So basically you're jumping backwards in the stack to beyond to the caller"
    },
    {
      "Time_Start": 1914.6399999999999,
      "Time_End": 1921.6399999999999,
      "Text": " of the caller of the overflowable function, the meta caller in this case. And basically,"
    },
    {
      "Time_Start": 1922.8,
      "Time_End": 1926.32,
      "Text": " you know, because the register will be \u2011\u2011 the saved program counter will be borked by"
    },
    {
      "Time_Start": 1926.32,
      "Time_End": 1931.9199999999998,
      "Text": " that point, you don't have to worry about those stack frames, they can just go to hell."
    },
    {
      "Time_Start": 1931.9199999999998,
      "Time_End": 1938.12,
      "Text": " Greg Hoglund talked a lot about this. Very well, I might add. Okay. Some real world examples"
    },
    {
      "Time_Start": 1938.12,
      "Time_End": 1945.12,
      "Text": " if I can find a place to put this microphone."
    },
    {
      "Time_Start": 1956.32,
      "Time_End": 1963.32,
      "Text": " Okay. Can everyone see the shell? Okay. Looks good."
    },
    {
      "Time_Start": 1987.1599999999999,
      "Time_End": 1991.76,
      "Text": " Okay. First we're going to have a nice little simple smash me example. Here is the source"
    },
    {
      "Time_Start": 1991.76,
      "Time_End": 1998.76,
      "Text": " code for that. Very, very simple. Smash with the ARGV1 stir cat to 128 byte buffer. Now"
    },
    {
      "Time_Start": 2000.56,
      "Time_End": 2007.56,
      "Text": " we run a meta smash me, which will smash smash me. One thing you'll basically always see"
    },
    {
      "Time_Start": 2008.84,
      "Time_End": 2013.76,
      "Text": " is the calling function will calculate \u2011\u2011 will get the value of its stack pointer, because"
    },
    {
      "Time_Start": 2014.0,
      "Time_End": 2017.44,
      "Text": " it will calculate the offset from its stack pointer so it can try and guess the stack"
    },
    {
      "Time_Start": 2017.44,
      "Time_End": 2022.48,
      "Text": " pointer of the function it's trying to overflow, because there will always be a defined number"
    },
    {
      "Time_Start": 2022.48,
      "Time_End": 2026.44,
      "Text": " of bytes down the stack, a certain number of function calls down the stack."
    },
    {
      "Time_Start": 2026.44,
      "Time_End": 2032.08,
      "Text": " And so basically what you're going to be doing is you're just going to be creating a very"
    },
    {
      "Time_Start": 2032.08,
      "Time_End": 2039.08,
      "Text": " large string. In this program, what I do is I write \u2011\u2011 I pass in the argument of"
    },
    {
      "Time_Start": 2039.4,
      "Time_End": 2044.16,
      "Text": " the buffer size that I'm trying to overflow. And so what I do is I write no ops all the"
    },
    {
      "Time_Start": 2044.16,
      "Time_End": 2047.7600000000002,
      "Text": " way up to where the shell code must fit, then write the shell code so it's all within the"
    },
    {
      "Time_Start": 2047.7600000000002,
      "Time_End": 2053.92,
      "Text": " buffer, and then just write tons of return addresses. And the return address is calculated"
    },
    {
      "Time_Start": 2053.92,
      "Time_End": 2058.92,
      "Text": " as an offset from the stack pointer of the meta smash me process."
    },
    {
      "Time_Start": 2058.92,
      "Time_End": 2065.92,
      "Text": " So I just calculate the egg size. And it kind of just tells you what it's doing. And it"
    },
    {
      "Time_Start": 2066.92,
      "Time_End": 2073.28,
      "Text": " writes \u2011\u2011 like, the no op I have here is \u2011\u2011 I cannot remember what instruction"
    },
    {
      "Time_Start": 2073.28,
      "Time_End": 2080.28,
      "Text": " that is. Just trust me that it's a basic instruction that does nothing, essentially."
    },
    {
      "Time_Start": 2081.08,
      "Time_End": 2085.96,
      "Text": " And just copy the memory in to the egg. And so the egg represents the entire string I'm"
    },
    {
      "Time_Start": 2085.96,
      "Time_End": 2092.52,
      "Text": " trying to pass it with, and I call the function. So let's see what happens if we say the offset"
    },
    {
      "Time_Start": 2092.52,
      "Time_End": 2098.84,
      "Text": " is zero. Notice that the shell code I'm using in this example is 64 bytes. So we'll have"
    },
    {
      "Time_Start": 2098.84,
      "Time_End": 2105.84,
      "Text": " 64 bytes of no ops and the shell code. So we don't have that big of a window."
    },
    {
      "Time_Start": 2107.28,
      "Time_End": 2114.28,
      "Text": " It's not happy. So fire up our debugger. Meta smash me \u2011\u2011 legal instruction. Notice"
    },
    {
      "Time_Start": 2115.28,
      "Time_End": 2122.28,
      "Text": " how the registers are just basically splatted. And so we can just check out our frame pointer"
    },
    {
      "Time_Start": 2125.32,
      "Time_End": 2129.84,
      "Text": " and see what they point to. They point to themselves again. Because basically I did"
    },
    {
      "Time_Start": 2129.84,
      "Time_End": 2134.2000000000003,
      "Text": " not go back far enough in the stack where I'm just pointing back at my target address."
    },
    {
      "Time_Start": 2134.2000000000003,
      "Time_End": 2140.2000000000003,
      "Text": " So let's see. Minus 500. 500 hex notice. That is well beyond it."
    },
    {
      "Time_Start": 2140.52,
      "Time_End": 2147.52,
      "Text": " Okay. So what I'm going to do is \u2011\u2011 where am I? Got my shell code. Actually, no. I'll"
    },
    {
      "Time_Start": 2155.64,
      "Time_End": 2162.64,
      "Text": " look at my no op. You'll see that byte there. And basically I'm going to search through"
    },
    {
      "Time_Start": 2163.3199999999997,
      "Time_End": 2169.4399999999996,
      "Text": " memory for where that thing is. And that will basically calculate the offset for me. So"
    },
    {
      "Time_Start": 2169.44,
      "Time_End": 2176.44,
      "Text": " I'm going to say we'll start at 500 hex bytes down the stack from the frame pointer. Do"
    },
    {
      "Time_Start": 2176.8,
      "Time_End": 2183.8,
      "Text": " a search for the 32 bit value. All right. Okay. Search for that value. Shows me the"
    },
    {
      "Time_Start": 2191.48,
      "Time_End": 2198.48,
      "Text": " first occurrence of it is. And now I'm going to do my poem."
    },
    {
      "Time_Start": 2199.44,
      "Time_End": 2206.44,
      "Text": " Command X calculator. Is that the value we want? 980. So that right there is our offset."
    },
    {
      "Time_Start": 2206.44,
      "Time_End": 2213.44,
      "Text": " So let's quit out of that and let's put GDB to the test. Go back. We have a shell. We"
    },
    {
      "Time_Start": 2213.44,
      "Time_End": 2220.44,
      "Text": " basically landed exactly at the first no op. Thank you."
    },
    {
      "Time_Start": 2244.44,
      "Time_End": 2250.56,
      "Text": " But that's some precision that we don't really need. Basically we know that we have 64 bytes."
    },
    {
      "Time_Start": 2250.56,
      "Time_End": 2255.16,
      "Text": " So basically we only have to be within 50 bytes or so. So we can just go back and go,"
    },
    {
      "Time_Start": 2255.16,
      "Time_End": 2262.16,
      "Text": " you know, try 1,000. No, not happy. 1,050. Bingo. And so the larger the buffer is, basically"
    },
    {
      "Time_Start": 2263.52,
      "Time_End": 2270.04,
      "Text": " you \u2011\u2011 the more leeway you have. Which we'll go and we'll see an ellipsis example."
    },
    {
      "Time_Start": 2270.04,
      "Time_End": 2275.88,
      "Text": " This is old. This was discovered by Onion, I think, in September of 1998 or somewhere"
    },
    {
      "Time_Start": 2275.88,
      "Time_End": 2281.6,
      "Text": " like that. And Sun took about a year to post a fix for it. So I just took all the patches"
    },
    {
      "Time_Start": 2281.6,
      "Time_End": 2288.6,
      "Text": " off my system. I'm feeling kind of vulnerable right now. But it's for the greater good."
    },
    {
      "Time_Start": 2289.2,
      "Time_End": 2294.84,
      "Text": " The details of this bug are there's an overflow in libc and it's parsing of the LC messages"
    },
    {
      "Time_Start": 2294.84,
      "Time_End": 2300.32,
      "Text": " environment variable where you can overflow that and basically so any program becomes"
    },
    {
      "Time_Start": 2300.32,
      "Time_End": 2306.76,
      "Text": " vulnerable to it. So here's my little program right here. I just ask what program to call,"
    },
    {
      "Time_Start": 2306.76,
      "Time_End": 2313.76,
      "Text": " how big the buffer is, and what the opposite is. And I'll show you the program in a second."
    },
    {
      "Time_Start": 2314.92,
      "Time_End": 2321.92,
      "Text": " Pretty much the same thing as the last one. Just throws it in the environment. You know,"
    },
    {
      "Time_Start": 2322.92,
      "Time_End": 2329.92,
      "Text": " you will have to \u2011\u2011 you'll have to basically write a program to exploit each one you're"
    },
    {
      "Time_Start": 2331.12,
      "Time_End": 2335.04,
      "Text": " going for, typically, just so you can customize it, but it's not that big of a deal. And what"
    },
    {
      "Time_Start": 2335.04,
      "Time_End": 2342.04,
      "Text": " we can do is we can \u2011\u2011 I'm just going to try \u2011\u2011 let's go for bin RSH. And I"
    },
    {
      "Time_Start": 2343.36,
      "Time_End": 2350.36,
      "Text": " basically went through with Perl and basically kept giving larger buffers in LC messages"
    },
    {
      "Time_Start": 2350.7200000000003,
      "Time_End": 2354.04,
      "Text": " until I got one that died. Somewhere around 1,000 bytes. That's what I assume the size"
    },
    {
      "Time_Start": 2354.04,
      "Time_End": 2361.04,
      "Text": " of the buffer is. So with offset zero. It dies. Okay. Well, I know now that because"
    },
    {
      "Time_Start": 2361.6,
      "Time_End": 2368.6,
      "Text": " it is 1,000 bytes of no ops, 1,000 minus 64, I have a very gaping large window. And so"
    },
    {
      "Time_Start": 2371.1200000000003,
      "Time_End": 2378.1200000000003,
      "Text": " I'm just going to try by offsets of 500. No. No. No. No. No. No. No. No. No. No. No. No."
    },
    {
      "Time_Start": 2380.36,
      "Time_End": 2387.36,
      "Text": " No. There we go. And that basically gives me a root shell because in this shell code"
    },
    {
      "Time_Start": 2387.84,
      "Time_End": 2394.84,
      "Text": " that I'm using, I made sure to call set UID zero. So bin shell is happy and trust me."
    },
    {
      "Time_Start": 2396.88,
      "Time_End": 2401.4,
      "Text": " And it's basically like that. I can use any SUID program on the system at this point."
    },
    {
      "Time_Start": 2401.4,
      "Time_End": 2408.4,
      "Text": " So let's do a find user bin. Okay. Anyone have a favorite?"
    },
    {
      "Time_Start": 2411.36,
      "Time_End": 2417.0,
      "Text": " I'll do bin password because that one's nice and easy. But I basically just sat down today"
    },
    {
      "Time_Start": 2417.0,
      "Time_End": 2421.2000000000003,
      "Text": " and decided which ones I could get. And basically some of these didn't have the overflow in"
    },
    {
      "Time_Start": 2421.2000000000003,
      "Time_End": 2425.1200000000003,
      "Text": " them because they didn't use the locale support and libc to use it. But the vast majority"
    },
    {
      "Time_Start": 2425.1200000000003,
      "Time_End": 2432.1200000000003,
      "Text": " of them did. So let's start with password. And oh, wow. Looks like they don't go very"
    },
    {
      "Time_Start": 2432.64,
      "Time_End": 2439.64,
      "Text": " far down on the stack and make it really easy for us. So let's see. What else do I have"
    },
    {
      "Time_Start": 2441.64,
      "Time_End": 2448.64,
      "Text": " that's really fun to show you? Okay. Let's go for some really cool shell code that mostly"
    },
    {
      "Time_Start": 2449.24,
      "Time_End": 2456.24,
      "Text": " works. I spent the last couple days on this. Strange, strange bug. It's driving me nuts."
    },
    {
      "Time_Start": 2457.2400000000002,
      "Time_End": 2464.2400000000002,
      "Text": " But here's an alternate way to develop shell code instead of using the ASM blocks. Just"
    },
    {
      "Time_Start": 2466.2400000000002,
      "Time_End": 2469.28,
      "Text": " write the assembly file and basically you throw it through the assembler, create the"
    },
    {
      "Time_Start": 2469.28,
      "Time_End": 2474.44,
      "Text": " object file, and then I have a main function in a C program that just calls this function"
    },
    {
      "Time_Start": 2474.44,
      "Time_End": 2480.5200000000004,
      "Text": " bind shell. And that's a simple way for me to test it so I can go through here. And mostly"
    },
    {
      "Time_Start": 2480.52,
      "Time_End": 2487.52,
      "Text": " because the ASM block just makes Emacs go hairy and I like Emacs. So don't throw anything."
    },
    {
      "Time_Start": 2487.52,
      "Time_End": 2494.52,
      "Text": " Okay. What I'm doing oh, let's see. Where's the source for this originally? First I wrote"
    },
    {
      "Time_Start": 2500.84,
      "Time_End": 2506.08,
      "Text": " basically what I wanted to do in C. Create a socket, set it up, bind it, listen, set"
    },
    {
      "Time_Start": 2506.08,
      "Time_End": 2510.2799999999997,
      "Text": " the first connection, dupe the file descriptors for standard in, standard out, standard error"
    },
    {
      "Time_Start": 2510.2799999999997,
      "Time_End": 2517.2799999999997,
      "Text": " to the socket, and run bin shell. And I just kind of went through. Translated this into"
    },
    {
      "Time_Start": 2521.68,
      "Time_End": 2528.48,
      "Text": " assembly because everything is just a system call. So I do a trap. Let's see. Right there"
    },
    {
      "Time_Start": 2528.48,
      "Time_End": 2534.56,
      "Text": " is the socket call by 230. These are the higher numbered ones will change from system to system"
    },
    {
      "Time_Start": 2534.56,
      "Time_End": 2540.52,
      "Text": " so you'll have to look them up on Linux or BSD on there. Just straightforward assembly"
    },
    {
      "Time_Start": 2540.52,
      "Time_End": 2547.52,
      "Text": " programming basically. Going through, go bind, store it all, yada, yada, yada. Compiling"
    },
    {
      "Time_Start": 2551.36,
      "Time_End": 2557.04,
      "Text": " the, and I just inserted my standard shell code right there. Using the compiler to output"
    },
    {
      "Time_Start": 2557.04,
      "Time_End": 2561.36,
      "Text": " assembly code will be very helpful in figuring out how the compiler does stuff. But it is"
    },
    {
      "Time_Start": 2561.36,
      "Time_End": 2566.4,
      "Text": " deceptive in a lot of ways because the compiler doesn't like telling you in the various libraries"
    },
    {
      "Time_Start": 2566.4,
      "Time_End": 2570.1200000000003,
      "Text": " that it's just doing system calls for all of these. So you'll go through like six different"
    },
    {
      "Time_Start": 2570.1200000000003,
      "Time_End": 2574.56,
      "Text": " layered functions, underscore, underscore, socket, underscore, capital U, that will finally"
    },
    {
      "Time_Start": 2574.56,
      "Time_End": 2581.56,
      "Text": " say oh, I just do a trap. But just look through syscall.H and you'll see what it really does."
    },
    {
      "Time_Start": 2581.56,
      "Time_End": 2587.44,
      "Text": " It will get angry at you. But we tested. I just compiled it and linked the two things"
    },
    {
      "Time_Start": 2587.44,
      "Time_End": 2593.96,
      "Text": " together. Oh, yeah. That's the bug. For some reason when I run it straight, it decides"
    },
    {
      "Time_Start": 2593.96,
      "Time_End": 2598.88,
      "Text": " that it will not block and wait for it to accept. It will just kind of do something"
    },
    {
      "Time_Start": 2598.88,
      "Time_End": 2604.4,
      "Text": " and the thread will just continue on and execute the shell. But when I run it through the debugger"
    },
    {
      "Time_Start": 2604.4,
      "Time_End": 2611.4,
      "Text": " and say what's it called, bind shell break and I run it and I say yeah, continue. And"
    },
    {
      "Time_Start": 2618.16,
      "Time_End": 2625.16,
      "Text": " I just told it to bind to localhost part 2000. Yes. Keep going. It likes to say I'm about"
    },
    {
      "Time_Start": 2625.88,
      "Time_End": 2631.04,
      "Text": " to exec something and things will change. So I'll stop for you. But just ignore that."
    },
    {
      "Time_Start": 2631.04,
      "Time_End": 2635.7200000000003,
      "Text": " And basically we have a very mutated, very ugly environment. It's shell right here. Like"
    },
    {
      "Time_Start": 2635.7200000000003,
      "Time_End": 2642.7200000000003,
      "Text": " it's not found, colon. And you can get enough done from here to do what you need to do."
    },
    {
      "Time_Start": 2643.5200000000004,
      "Time_End": 2650.5200000000004,
      "Text": " And obviously it's running as me because I just ran it from the command line. But you"
    },
    {
      "Time_Start": 2651.5600000000004,
      "Time_End": 2657.0800000000004,
      "Text": " just basically through the things I've showed you, convert it to shell code and throw in"
    },
    {
      "Time_Start": 2657.0800000000004,
      "Time_End": 2664.0800000000004,
      "Text": " the process and you'll have a bind shell. To do so, I have a nice little view here."
    },
    {
      "Time_Start": 2665.08,
      "Time_End": 2672.08,
      "Text": " Just to help me out with writing these, I made my disk 2H. And so if I go through to"
    },
    {
      "Time_Start": 2674.6,
      "Time_End": 2681.6,
      "Text": " my code, let's see. What I do is I write 3.C, test it out in there. Then I disassemble it"
    },
    {
      "Time_Start": 2684.2799999999997,
      "Time_End": 2691.2799999999997,
      "Text": " to 3. I disassemble it to 3.disk. Main 3. Little noise at the top. So I just chop those"
    },
    {
      "Time_Start": 2691.7200000000003,
      "Time_End": 2696.7200000000003,
      "Text": " off until I just have the disassembled code. Shouldn't hurt you to cut out three lines."
    },
    {
      "Time_Start": 2696.7200000000003,
      "Time_End": 2701.7200000000003,
      "Text": " Don't want the script to do everything for you. And then just a simple, like, you know,"
    },
    {
      "Time_Start": 2701.7200000000003,
      "Time_End": 2706.7200000000003,
      "Text": " filter. You can do this in Perl. You can do this in whatever you want. But I did it in"
    },
    {
      "Time_Start": 2706.7200000000003,
      "Time_End": 2713.7200000000003,
      "Text": " C because it's fun. 3.disk, type to that. And it gives you a nice little header file"
    },
    {
      "Time_Start": 2713.7200000000003,
      "Time_End": 2720.7200000000003,
      "Text": " to include. And this is a quick way to check for null bytes. And just look at your code."
    },
    {
      "Time_Start": 2721.5600000000004,
      "Time_End": 2728.5600000000004,
      "Text": " My hand side by side and feel warm and fuzzy. But basically with just a couple little tools,"
    },
    {
      "Time_Start": 2729.6400000000003,
      "Time_End": 2735.0800000000004,
      "Text": " you can just tinker around with, you know, writing shell code and stuff. And then amazingly"
    },
    {
      "Time_Start": 2735.0800000000004,
      "Time_End": 2740.32,
      "Text": " you will wake up and say, wait a minute. I'm actually decent at assembly programming now."
    },
    {
      "Time_Start": 2740.32,
      "Time_End": 2746.36,
      "Text": " This is useful. To be the example, I didn't do well in my assembly class until I started"
    },
    {
      "Time_Start": 2746.36,
      "Time_End": 2750.0800000000004,
      "Text": " doing this stuff. And of course, the semester had ended. And now I know everything and can"
    },
    {
      "Time_Start": 2750.08,
      "Time_End": 2757.08,
      "Text": " pay attention to class anyway. So grades mean nothing. I don't think I have anything"
    },
    {
      "Time_Start": 2757.4,
      "Time_End": 2764.4,
      "Text": " else to show you. And I think I'm out of time. Oh, yes. Some links to useful things. Linux"
    },
    {
      "Time_Start": 2769.7599999999998,
      "Time_End": 2774.92,
      "Text": " assembly.org, obviously focused on Linux and Intel architecture. But they have some great"
    },
    {
      "Time_Start": 2774.96,
      "Time_End": 2780.36,
      "Text": " info on there on straight from the beaten path and show you some spark stuff, some BSD"
    },
    {
      "Time_Start": 2780.36,
      "Time_End": 2785.52,
      "Text": " stuff. They have a nice little suite of basically the bin utility. A lot of the smaller utilities"
    },
    {
      "Time_Start": 2785.52,
      "Time_End": 2791.6800000000003,
      "Text": " written in assembly. So, you know, your standard 100K executable is now like 3K. Because all"
    },
    {
      "Time_Start": 2791.6800000000003,
      "Time_End": 2796.84,
      "Text": " they do is call the traps themselves. It's not portable, but it's really small and useful"
    },
    {
      "Time_Start": 2796.84,
      "Time_End": 2803.56,
      "Text": " for good disks. Shellcode.org, I just saw coming across either bug tracker, some ending"
    },
    {
      "Time_Start": 2803.72,
      "Time_End": 2809.24,
      "Text": " list. Today, currently down, we'll have a lot of resources to various shellcodes for"
    },
    {
      "Time_Start": 2809.24,
      "Time_End": 2816.24,
      "Text": " various operating systems. FRAC55 has a really nice article about writing shellcode on MIPS"
    },
    {
      "Time_Start": 2816.7999999999997,
      "Time_End": 2823.7999999999997,
      "Text": " under IRIX, MIPS being another of the pioneering RISC chips. Very similar to this. It's a very"
    },
    {
      "Time_Start": 2824.7599999999998,
      "Time_End": 2831.24,
      "Text": " good read also. And this stuff eventually will be on dopesquad.net slash security whenever"
    },
    {
      "Time_Start": 2831.2400000000002,
      "Time_End": 2837.8,
      "Text": " I finish it up and put it up there. So you can look there. But if you see a 404, don't"
    },
    {
      "Time_Start": 2837.8,
      "Time_End": 2839.0000000000005,
      "Text": " have a heart attack."
    }
  ]
}